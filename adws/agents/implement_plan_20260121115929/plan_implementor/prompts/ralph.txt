/ralph-loop:ralph-loop

You have an implementation plan to execute. The plan is at: ../adws\adw_plans\20260121115150_implementation_plan.md

## Plan Content

# Implementation Plan - app

**Date:** 2026-01-21
**Audit Type:** general
**Generated By:** Claude Opus (ADW Pipeline)

---

## Summary

| Metric | Value |
|--------|-------|
| Files to modify | 7 |
| Risk level | LOW |
| Estimated changes | Convert imperative loops to functional patterns, extract shared logic, improve purity |

## Implementation Order

List files in dependency order (leaves first):
1. `app/src/lib/safeJson.js` - No dependents (true leaf)
2. `app/src/logic/rules/leases/isLeaseActive.js` - No dependents (true leaf)
3. `app/src/logic/rules/leases/canHardDeleteLease.js` - 1 dependent
4. `app/src/logic/processors/leases/sortLeases.js` - 1 dependent
5. `app/src/logic/processors/leases/filterLeases.js` - 1 dependent
6. `app/src/logic/calculators/scheduling/isContiguousSelection.js` - 1 dependent
7. `app/src/logic/rules/scheduling/isScheduleContiguous.js` - 2 dependents

---

## File Changes

### 1. `app/src/lib/safeJson.js`

**Reason:** Function lacks type validation and could benefit from more explicit null handling. The arrow function style is inconsistent with other lib utilities.
**Dependents:** None (true leaf file)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Safe JSON parsing utility
 * Prevents errors from malformed JSON strings
 */

/**
 * Safely parse a JSON string with fallback
 * @param {string} jsonString - The JSON string to parse
 * @param {*} fallback - The fallback value to return on parse failure (default: null)
 * @returns {*} Parsed JSON object or fallback value
 */
export const safeJsonParse = (jsonString, fallback = null) => {
  if (!jsonString) return fallback;

  try {
    return JSON.parse(jsonString);
  } catch (error) {
    if (import.meta.env.DEV) {
      console.warn('JSON parse failed:', error.message);
    }
    return fallback;
  }
};
```

#### Refactored Code
```javascript
/**
 * Safe JSON parsing utility
 * Prevents errors from malformed JSON strings
 */

/**
 * Safely parse a JSON string with fallback
 *
 * @intent Parse JSON without throwing, returning fallback on failure
 * @rule Returns fallback for null, undefined, empty string, or non-string input
 * @rule Returns fallback for malformed JSON
 * @rule Logs warning in development mode only
 *
 * @param {string} jsonString - The JSON string to parse
 * @param {*} fallback - The fallback value to return on parse failure (default: null)
 * @returns {*} Parsed JSON object or fallback value
 *
 * @example
 * safeJsonParse('{"name":"John"}') // { name: 'John' }
 * safeJsonParse('invalid', []) // []
 * safeJsonParse(null, {}) // {}
 */
export function safeJsonParse(jsonString, fallback = null) {
  // Handle null, undefined, and non-string inputs
  if (jsonString === null || jsonString === undefined) {
    return fallback;
  }

  if (typeof jsonString !== 'string') {
    return fallback;
  }

  // Handle empty string
  if (jsonString.trim().length === 0) {
    return fallback;
  }

  try {
    return JSON.parse(jsonString);
  } catch (error) {
    if (import.meta.env.DEV) {
      console.warn('JSON parse failed:', error.message);
    }
    return fallback;
  }
}
```

#### Changes Made
- Converted arrow function to named function declaration (consistency with codebase)
- Added explicit null/undefined checks (more explicit than falsy check)
- Added type check for non-string inputs
- Added empty string check with trim
- Added JSDoc @intent, @rule, and @example annotations

---

### 2. `app/src/logic/rules/leases/isLeaseActive.js`

**Reason:** Functions create `new Date()` internally, making them impure and hard to test. All three functions (`isLeaseActive`, `isLeaseUpcoming`, `isLeaseExpired`) share this issue.
**Dependents:** None (true leaf file)
**Risk:** LOW

#### Current Code
```javascript
/**
 * isLeaseActive - Check if a lease is currently active
 *
 * A lease is considered active if:
 * - Status is 'active'
 * - Current date is within the reservation period
 *
 * @param {Object} lease - Adapted lease object
 * @returns {boolean} Whether the lease is currently active
 */
export function isLeaseActive(lease) {
  if (!lease) return false;

  // Status must be 'active'
  if (lease.status !== 'active') {
    return false;
  }

  // If no dates set, consider it active based on status alone
  if (!lease.startDate && !lease.endDate) {
    return true;
  }

  const now = new Date();

  // Check if we're within the date range
  if (lease.startDate && now < lease.startDate) {
    return false; // Not started yet
  }

  if (lease.endDate && now > lease.endDate) {
    return false; // Already ended
  }

  return true;
}

/**
 * isLeaseUpcoming - Check if a lease is scheduled but not started
 * @param {Object} lease
 * @returns {boolean}
 */
export function isLeaseUpcoming(lease) {
  if (!lease) return false;
  if (lease.status !== 'active' && lease.status !== 'pending') return false;
  if (!lease.startDate) return false;

  const now = new Date();
  return now < lease.startDate;
}

/**
 * isLeaseExpired - Check if a lease has passed its end date
 * @param {Object} lease
 * @returns {boolean}
 */
export function isLeaseExpired(lease) {
  if (!lease) return false;
  if (!lease.endDate) return false;

  const now = new Date();
  return now > lease.endDate;
}

export default isLeaseActive;
```

#### Refactored Code
```javascript
/**
 * Lease temporal status rules
 *
 * These functions determine lease status based on dates.
 * All accept an optional `asOf` date parameter for testability.
 */

/**
 * isLeaseActive - Check if a lease is currently active
 *
 * @intent Determine if a lease is in active status and within its date range
 * @rule Status must be 'active'
 * @rule If no dates set, consider active based on status alone
 * @rule Must be on or after startDate (if set)
 * @rule Must be on or before endDate (if set)
 *
 * @param {Object} lease - Adapted lease object
 * @param {Date} [asOf=new Date()] - Reference date for comparison (enables testing)
 * @returns {boolean} Whether the lease is currently active
 *
 * @example
 * isLeaseActive({ status: 'active', startDate: yesterday, endDate: tomorrow }) // true
 * isLeaseActive({ status: 'active', startDate: tomorrow }) // false (not started)
 */
export function isLeaseActive(lease, asOf = new Date()) {
  if (!lease) return false;

  // Status must be 'active'
  if (lease.status !== 'active') {
    return false;
  }

  // If no dates set, consider it active based on status alone
  if (!lease.startDate && !lease.endDate) {
    return true;
  }

  // Check if we're within the date range
  const isAfterStart = !lease.startDate || asOf >= lease.startDate;
  const isBeforeEnd = !lease.endDate || asOf <= lease.endDate;

  return isAfterStart && isBeforeEnd;
}

/**
 * isLeaseUpcoming - Check if a lease is scheduled but not started
 *
 * @intent Determine if a lease will begin in the future
 * @rule Status must be 'active' or 'pending'
 * @rule startDate must exist and be in the future
 *
 * @param {Object} lease - Adapted lease object
 * @param {Date} [asOf=new Date()] - Reference date for comparison (enables testing)
 * @returns {boolean} Whether the lease is upcoming
 *
 * @example
 * isLeaseUpcoming({ status: 'active', startDate: tomorrow }) // true
 * isLeaseUpcoming({ status: 'active', startDate: yesterday }) // false
 */
export function isLeaseUpcoming(lease, asOf = new Date()) {
  if (!lease) return false;

  const validStatuses = ['active', 'pending'];
  if (!validStatuses.includes(lease.status)) return false;

  if (!lease.startDate) return false;

  return asOf < lease.startDate;
}

/**
 * isLeaseExpired - Check if a lease has passed its end date
 *
 * @intent Determine if a lease's end date has passed
 * @rule endDate must exist and be in the past
 *
 * @param {Object} lease - Adapted lease object
 * @param {Date} [asOf=new Date()] - Reference date for comparison (enables testing)
 * @returns {boolean} Whether the lease has expired
 *
 * @example
 * isLeaseExpired({ endDate: yesterday }) // true
 * isLeaseExpired({ endDate: tomorrow }) // false
 * isLeaseExpired({ endDate: null }) // false
 */
export function isLeaseExpired(lease, asOf = new Date()) {
  if (!lease) return false;
  if (!lease.endDate) return false;

  return asOf > lease.endDate;
}

export default isLeaseActive;
```

#### Changes Made
- Added optional `asOf` parameter to all functions (enables deterministic testing)
- Extracted `validStatuses` array in `isLeaseUpcoming` for clarity
- Converted imperative if-chain in `isLeaseActive` to declarative boolean expressions
- Added comprehensive JSDoc with @intent, @rule, and @example annotations
- Functions remain pure when `asOf` is provided explicitly

---

### 3. `app/src/logic/rules/leases/canHardDeleteLease.js`

**Reason:** Contains duplicate logic between `canHardDeleteLease` and `getHardDeleteBlockReason`. The active stays filter is duplicated exactly.
**Dependents:** `useLeasesOverviewPageLogic.js`
**Risk:** LOW

#### Current Code
```javascript
/**
 * canHardDeleteLease - Determine if a lease can be permanently deleted
 *
 * Business Rules (more restrictive than soft delete):
 * - Only cancelled leases can be hard-deleted
 * - Lease must have no active stays
 * - Lease must have no pending payments
 * - Lease should ideally have no associated documents (warn but allow)
 *
 * @param {Object} lease - Adapted lease object
 * @returns {boolean} Whether the lease can be permanently deleted
 */
export function canHardDeleteLease(lease) {
  if (!lease) return false;

  // Must be cancelled first
  if (lease.status !== 'cancelled') {
    return false;
  }

  // Check for active stays
  if (lease.stays && lease.stays.length > 0) {
    const activeStays = lease.stays.filter((stay) =>
      ['active', 'upcoming', 'in-progress'].includes(stay.status?.toLowerCase())
    );

    if (activeStays.length > 0) {
      return false;
    }
  }

  // Check for unpaid balance
  if (lease.totalRent > 0 && lease.paidToDate > 0) {
    // If there's been any payment, be cautious about hard delete
    // Allow it, but the UI should warn about this
  }

  return true;
}

/**
 * Get reason why hard delete is not allowed
 * @param {Object} lease - Adapted lease object
 * @returns {string|null} Reason string or null if allowed
 */
export function getHardDeleteBlockReason(lease) {
  if (!lease) return 'Lease not found';

  if (lease.status !== 'cancelled') {
    return `Lease must be cancelled first (current status: ${lease.status})`;
  }

  if (lease.stays && lease.stays.length > 0) {
    const activeStays = lease.stays.filter((stay) =>
      ['active', 'upcoming', 'in-progress'].includes(stay.status?.toLowerCase())
    );

    if (activeStays.length > 0) {
      return `Lease has ${activeStays.length} active stay(s)`;
    }
  }

  return null;
}

export default canHardDeleteLease;
```

#### Refactored Code
```javascript
/**
 * Hard delete eligibility rules for leases
 *
 * Business Rules (more restrictive than soft delete):
 * - Only cancelled leases can be hard-deleted
 * - Lease must have no active stays
 * - Lease must have no pending payments (warn but allow)
 */

/**
 * Status values that indicate an active stay
 * @type {string[]}
 */
const ACTIVE_STAY_STATUSES = ['active', 'upcoming', 'in-progress'];

/**
 * Check if a stay is currently active
 *
 * @param {Object} stay - Stay object
 * @returns {boolean} Whether the stay is active
 */
const isActiveStay = (stay) =>
  ACTIVE_STAY_STATUSES.includes(stay.status?.toLowerCase());

/**
 * Get the count of active stays in a lease
 *
 * @param {Object} lease - Adapted lease object
 * @returns {number} Count of active stays
 */
const getActiveStayCount = (lease) => {
  if (!lease.stays || !Array.isArray(lease.stays)) {
    return 0;
  }
  return lease.stays.filter(isActiveStay).length;
};

/**
 * canHardDeleteLease - Determine if a lease can be permanently deleted
 *
 * @intent Check all prerequisites for permanent lease deletion
 * @rule Lease must exist
 * @rule Status must be 'cancelled'
 * @rule No active, upcoming, or in-progress stays
 *
 * @param {Object} lease - Adapted lease object
 * @returns {boolean} Whether the lease can be permanently deleted
 *
 * @example
 * canHardDeleteLease({ status: 'cancelled', stays: [] }) // true
 * canHardDeleteLease({ status: 'active', stays: [] }) // false
 */
export function canHardDeleteLease(lease) {
  // Use the block reason check - if null, deletion is allowed
  return getHardDeleteBlockReason(lease) === null;
}

/**
 * Get reason why hard delete is not allowed
 *
 * @intent Provide user-friendly explanation for deletion block
 * @rule Returns null if deletion is allowed
 * @rule Checks in order: existence, status, active stays
 *
 * @param {Object} lease - Adapted lease object
 * @returns {string|null} Reason string or null if allowed
 *
 * @example
 * getHardDeleteBlockReason({ status: 'active' }) // "Lease must be cancelled first (current status: active)"
 * getHardDeleteBlockReason({ status: 'cancelled', stays: [] }) // null
 */
export function getHardDeleteBlockReason(lease) {
  if (!lease) {
    return 'Lease not found';
  }

  if (lease.status !== 'cancelled') {
    return `Lease must be cancelled first (current status: ${lease.status})`;
  }

  const activeStayCount = getActiveStayCount(lease);
  if (activeStayCount > 0) {
    return `Lease has ${activeStayCount} active stay(s)`;
  }

  return null;
}

export default canHardDeleteLease;
```

#### Changes Made
- Extracted `ACTIVE_STAY_STATUSES` constant (single source of truth)
- Created `isActiveStay` predicate function (reusable, testable)
- Created `getActiveStayCount` helper (eliminates duplication)
- Simplified `canHardDeleteLease` to delegate to `getHardDeleteBlockReason` (DRY)
- Added type safety check for `lease.stays` array
- Added JSDoc with @intent, @rule, and @example annotations

---

### 4. `app/src/logic/processors/leases/sortLeases.js`

**Reason:** The `getFieldValue` function uses a switch statement that could be a lookup object. Also, the comparison logic can be simplified using a more functional approach.
**Dependents:** `useLeasesOverviewPageLogic.js`
**Risk:** LOW

#### Current Code
```javascript
/**
 * sortLeases - Sort leases by specified field and order
 *
 * @param {Array} leases - Array of adapted lease objects
 * @param {Object} sortConfig - Sort configuration
 * @param {string} sortConfig.field - Field to sort by
 * @param {string} sortConfig.order - 'asc' or 'desc'
 * @returns {Array} Sorted leases (new array, doesn't mutate input)
 */
export function sortLeases(leases, { field = 'createdAt', order = 'desc' }) {
  if (!Array.isArray(leases)) return [];

  const sortedLeases = [...leases];

  sortedLeases.sort((a, b) => {
    let valueA = getFieldValue(a, field);
    let valueB = getFieldValue(b, field);

    // Handle null/undefined values - push them to the end
    if (valueA == null && valueB == null) return 0;
    if (valueA == null) return 1;
    if (valueB == null) return -1;

    // Compare based on type
    let comparison = 0;

    if (valueA instanceof Date && valueB instanceof Date) {
      comparison = valueA.getTime() - valueB.getTime();
    } else if (typeof valueA === 'number' && typeof valueB === 'number') {
      comparison = valueA - valueB;
    } else {
      // String comparison
      comparison = String(valueA).localeCompare(String(valueB));
    }

    return order === 'desc' ? -comparison : comparison;
  });

  return sortedLeases;
}

/**
 * Get the value of a field from a lease object
 * Handles nested fields and common aliases
 */
function getFieldValue(lease, field) {
  switch (field) {
    case 'createdAt':
      return lease.createdAt;
    case 'startDate':
      return lease.startDate;
    case 'endDate':
      return lease.endDate;
    case 'totalRent':
      return lease.totalRent;
    case 'totalCompensation':
      return lease.totalCompensation;
    case 'agreementNumber':
      return lease.agreementNumber;
    case 'status':
      return lease.status;
    case 'guestEmail':
      return lease.guest?.email;
    case 'hostEmail':
      return lease.host?.email;
    case 'listingName':
      return lease.listing?.name;
    default:
      return lease[field];
  }
}

export default sortLeases;
```

#### Refactored Code
```javascript
/**
 * Lease sorting processor
 *
 * Pure function that returns a new sorted array without mutating input.
 */

/**
 * Field accessor map for nested/aliased fields
 * Maps sort field names to accessor functions
 *
 * @type {Object.<string, function(Object): *>}
 */
const FIELD_ACCESSORS = {
  createdAt: (lease) => lease.createdAt,
  startDate: (lease) => lease.startDate,
  endDate: (lease) => lease.endDate,
  totalRent: (lease) => lease.totalRent,
  totalCompensation: (lease) => lease.totalCompensation,
  agreementNumber: (lease) => lease.agreementNumber,
  status: (lease) => lease.status,
  guestEmail: (lease) => lease.guest?.email,
  hostEmail: (lease) => lease.host?.email,
  listingName: (lease) => lease.listing?.name,
};

/**
 * Get the value of a field from a lease object
 * Handles nested fields and common aliases
 *
 * @param {Object} lease - Lease object
 * @param {string} field - Field name or alias
 * @returns {*} Field value or undefined
 */
const getFieldValue = (lease, field) => {
  const accessor = FIELD_ACCESSORS[field];
  return accessor ? accessor(lease) : lease[field];
};

/**
 * Compare two values with null-safety
 * Nulls are pushed to the end of the list
 *
 * @param {*} valueA - First value
 * @param {*} valueB - Second value
 * @returns {number} Comparison result (-1, 0, or 1)
 */
const compareValues = (valueA, valueB) => {
  // Handle null/undefined values - push them to the end
  if (valueA == null && valueB == null) return 0;
  if (valueA == null) return 1;
  if (valueB == null) return -1;

  // Date comparison
  if (valueA instanceof Date && valueB instanceof Date) {
    return valueA.getTime() - valueB.getTime();
  }

  // Numeric comparison
  if (typeof valueA === 'number' && typeof valueB === 'number') {
    return valueA - valueB;
  }

  // String comparison (fallback)
  return String(valueA).localeCompare(String(valueB));
};

/**
 * sortLeases - Sort leases by specified field and order
 *
 * @intent Create a new sorted array without mutating the input
 * @rule Returns empty array for non-array input
 * @rule Null/undefined values sort to the end
 * @rule Supports Date, number, and string comparisons
 *
 * @param {Array} leases - Array of adapted lease objects
 * @param {Object} sortConfig - Sort configuration
 * @param {string} [sortConfig.field='createdAt'] - Field to sort by
 * @param {string} [sortConfig.order='desc'] - 'asc' or 'desc'
 * @returns {Array} Sorted leases (new array, doesn't mutate input)
 *
 * @example
 * sortLeases(leases, { field: 'totalRent', order: 'asc' })
 * sortLeases(leases, { field: 'guestEmail', order: 'desc' })
 */
export function sortLeases(leases, { field = 'createdAt', order = 'desc' } = {}) {
  if (!Array.isArray(leases)) return [];

  const direction = order === 'desc' ? -1 : 1;

  return [...leases].sort((a, b) => {
    const valueA = getFieldValue(a, field);
    const valueB = getFieldValue(b, field);
    return direction * compareValues(valueA, valueB);
  });
}

export default sortLeases;
```

#### Changes Made
- Replaced switch statement with `FIELD_ACCESSORS` lookup object (more maintainable)
- Extracted `compareValues` function (single responsibility, testable)
- Introduced `direction` multiplier instead of ternary in return (cleaner)
- Combined spread + sort into single expression (slightly more functional)
- Added default value for sortConfig parameter (defensive)
- Added comprehensive JSDoc with @intent, @rule, and @example annotations

---

### 5. `app/src/logic/processors/leases/filterLeases.js`

**Reason:** The early returns in the filter callback can be simplified to a single boolean expression. The searchable fields could be extracted for clarity.
**Dependents:** `useLeasesOverviewPageLogic.js`
**Risk:** LOW

#### Current Code
```javascript
/**
 * filterLeases - Filter leases by search query and status
 *
 * @param {Array} leases - Array of adapted lease objects
 * @param {Object} filters - Filter configuration
 * @param {string} filters.searchQuery - Text search query
 * @param {string} filters.statusFilter - Status to filter by ('all' for no filter)
 * @returns {Array} Filtered leases
 */
export function filterLeases(leases, { searchQuery = '', statusFilter = 'all' }) {
  if (!Array.isArray(leases)) return [];

  return leases.filter((lease) => {
    // Status filter
    if (statusFilter && statusFilter !== 'all') {
      if (lease.status !== statusFilter) {
        return false;
      }
    }

    // Search filter
    if (searchQuery) {
      const query = searchQuery.toLowerCase().trim();

      // Search across multiple fields
      const searchableFields = [
        lease.id,
        lease.agreementNumber,
        lease.guest?.email,
        lease.guest?.firstName,
        lease.guest?.lastName,
        lease.host?.email,
        lease.host?.firstName,
        lease.host?.lastName,
        lease.listing?.name,
        lease.listing?.address,
        lease.listing?.neighborhood,
      ];

      const matchesSearch = searchableFields.some((field) => {
        if (!field) return false;
        return String(field).toLowerCase().includes(query);
      });

      if (!matchesSearch) {
        return false;
      }
    }

    return true;
  });
}

export default filterLeases;
```

#### Refactored Code
```javascript
/**
 * Lease filtering processor
 *
 * Pure function that returns a new filtered array without mutating input.
 */

/**
 * Extract searchable text fields from a lease
 *
 * @param {Object} lease - Adapted lease object
 * @returns {string[]} Array of searchable field values
 */
const getSearchableFields = (lease) => [
  lease.id,
  lease.agreementNumber,
  lease.guest?.email,
  lease.guest?.firstName,
  lease.guest?.lastName,
  lease.host?.email,
  lease.host?.firstName,
  lease.host?.lastName,
  lease.listing?.name,
  lease.listing?.address,
  lease.listing?.neighborhood,
];

/**
 * Check if a lease matches the status filter
 *
 * @param {Object} lease - Adapted lease object
 * @param {string} statusFilter - Status to filter by ('all' to skip)
 * @returns {boolean} Whether the lease matches the status filter
 */
const matchesStatusFilter = (lease, statusFilter) =>
  !statusFilter || statusFilter === 'all' || lease.status === statusFilter;

/**
 * Check if a lease matches the search query
 *
 * @param {Object} lease - Adapted lease object
 * @param {string} query - Lowercase, trimmed search query
 * @returns {boolean} Whether the lease matches the search query
 */
const matchesSearchQuery = (lease, query) => {
  if (!query) return true;

  return getSearchableFields(lease).some(
    (field) => field && String(field).toLowerCase().includes(query)
  );
};

/**
 * filterLeases - Filter leases by search query and status
 *
 * @intent Filter lease list by status and/or text search across multiple fields
 * @rule Returns empty array for non-array input
 * @rule Status filter 'all' shows all statuses
 * @rule Search is case-insensitive and matches partial strings
 *
 * @param {Array} leases - Array of adapted lease objects
 * @param {Object} filters - Filter configuration
 * @param {string} [filters.searchQuery=''] - Text search query
 * @param {string} [filters.statusFilter='all'] - Status to filter by ('all' for no filter)
 * @returns {Array} Filtered leases (new array, doesn't mutate input)
 *
 * @example
 * filterLeases(leases, { statusFilter: 'active' })
 * filterLeases(leases, { searchQuery: 'john', statusFilter: 'all' })
 */
export function filterLeases(leases, { searchQuery = '', statusFilter = 'all' } = {}) {
  if (!Array.isArray(leases)) return [];

  const normalizedQuery = searchQuery.toLowerCase().trim();

  return leases.filter((lease) =>
    matchesStatusFilter(lease, statusFilter) &&
    matchesSearchQuery(lease, normalizedQuery)
  );
}

export default filterLeases;
```

#### Changes Made
- Extracted `getSearchableFields` function (single responsibility, extensible)
- Extracted `matchesStatusFilter` predicate (testable, readable)
- Extracted `matchesSearchQuery` predicate (testable, readable)
- Replaced early returns with single boolean expression (more declarative)
- Normalized search query once outside filter loop (performance)
- Added default value for filters parameter (defensive)
- Added comprehensive JSDoc with @intent, @rule, and @example annotations

---

### 6. `app/src/logic/calculators/scheduling/isContiguousSelection.js`

**Reason:** This is a duplicate of `isScheduleContiguous.js` in rules/scheduling/. The rules version is more comprehensive with better documentation and validation. This calculator version should be removed and imports redirected.
**Dependents:** `availabilityValidation.js`
**Risk:** LOW (single dependent, simple redirect)

#### Current Code
```javascript
/**
 * Check if selected days form a contiguous block.
 * Handles week wrap-around cases (e.g., Fri-Mon).
 *
 * @.claude\plans\Deprecated\Context\Option Sets\ZEP - Curation Parameters(OS).md {number[]} selectedDays - Array of day indices (0-6).
 * @returns {boolean} True if days are contiguous.
 */
export function isContiguousSelection(selectedDays) {
  if (!selectedDays || selectedDays.length === 0) return false;
  if (selectedDays.length === 1) return true;
  if (selectedDays.length >= 6) return true;

  const sorted = [...selectedDays].sort((a, b) => a - b);
  const isStandardContiguous = sorted.every((day, i) => i === 0 || day === sorted[i - 1] + 1);
  if (isStandardContiguous) return true;

  // Wrap-around check
  const hasZero = sorted.includes(0);
  const hasSix = sorted.includes(6);
  if (hasZero && hasSix) {
    const allDays = [0, 1, 2, 3, 4, 5, 6];
    const notSelectedDays = allDays.filter(d => !sorted.includes(d));

    const minNotSelected = Math.min(...notSelectedDays);
    const maxNotSelected = Math.max(...notSelectedDays);

    return notSelectedDays.length === (maxNotSelected - minNotSelected + 1);
  }

  return false;
}
```

#### Refactored Code
```javascript
/**
 * Check if selected days form a contiguous block.
 *
 * DEPRECATED: This file is a duplicate of isScheduleContiguous in rules/scheduling/.
 * Re-exports from the canonical location for backward compatibility.
 *
 * @see {import('../../rules/scheduling/isScheduleContiguous.js')}
 */

import { isScheduleContiguous } from '../../rules/scheduling/isScheduleContiguous.js';

/**
 * Check if selected days form a contiguous block.
 * Handles week wrap-around cases (e.g., Fri-Mon).
 *
 * @deprecated Use isScheduleContiguous from rules/scheduling/ instead
 * @param {number[]} selectedDays - Array of day indices (0-6).
 * @returns {boolean} True if days are contiguous.
 *
 * @example
 * isContiguousSelection([1, 2, 3, 4, 5]) // true (Mon-Fri)
 * isContiguousSelection([5, 6, 0]) // true (Fri-Sun, wraps)
 */
export function isContiguousSelection(selectedDays) {
  // Delegate to the canonical implementation
  // Handle the parameter difference (array vs object with selectedDayIndices)
  return isScheduleContiguous({ selectedDayIndices: selectedDays });
}
```

#### Changes Made
- Replaced duplicate implementation with re-export from canonical location
- Added @deprecated tag to guide developers to the canonical version
- Added adapter to handle parameter format difference (array vs object)
- Preserves backward compatibility for existing imports
- Consolidates contiguous selection logic to single source of truth

---

### 7. `app/src/logic/rules/scheduling/isScheduleContiguous.js`

**Reason:** Contains for-loops that can be converted to functional patterns. The wrap-around logic can be simplified.
**Dependents:** `useScheduleSelectorLogicCore.js`, `validateScheduleWorkflow.js`
**Risk:** LOW (well-tested business logic, functional refactor only)

#### Current Code
```javascript
/**
 * Check if selected days form a contiguous (consecutive) block.
 *
 * @intent Enforce the business rule that split lease stays must be consecutive nights.
 * @rule Days must be consecutive (Mon-Fri ✓, Mon+Wed ✗).
 * @rule Handles week wrap-around cases (Fri-Sun ✓, Sat-Tue ✓).
 * @rule For wrap-around, uses inverse logic: if unselected days are contiguous, selected days wrap around properly.
 * @rule 6 or more days is always contiguous (only 1 gap maximum).
 *
 * This function consolidates the contiguous validation logic that previously existed in:
 * - availabilityValidation.js (isContiguousSelection)
 * - scheduleSelector/validators.js (isContiguous)
 *
 * @param {object} params - Named parameters.
 * @param {number[]} params.selectedDayIndices - Array of day indices (0=Sunday, 1=Monday, ..., 6=Saturday).
 * @returns {boolean} True if days are contiguous, false otherwise.
 *
 * @throws {Error} If selectedDayIndices is not an array.
 * @throws {Error} If any day index is invalid (not 0-6).
 *
 * @example
 * isScheduleContiguous({ selectedDayIndices: [1, 2, 3, 4, 5] }) // => true (Mon-Fri)
 * isScheduleContiguous({ selectedDayIndices: [1, 3, 5] }) // => false (Mon, Wed, Fri - not contiguous)
 * isScheduleContiguous({ selectedDayIndices: [5, 6, 0] }) // => true (Fri-Sun, wraps around week)
 * isScheduleContiguous({ selectedDayIndices: [6, 0, 1, 2] }) // => true (Sat-Tue, wraps around week)
 */
export function isScheduleContiguous({ selectedDayIndices }) {
  // No Fallback: Validate input
  if (!Array.isArray(selectedDayIndices)) {
    throw new Error(
      `isScheduleContiguous: selectedDayIndices must be an array, got ${typeof selectedDayIndices}`
    )
  }

  // Empty selection is not contiguous
  if (selectedDayIndices.length === 0) {
    return false
  }

  // Single day is contiguous
  if (selectedDayIndices.length === 1) {
    return true
  }

  // Validate all day indices
  for (const day of selectedDayIndices) {
    if (typeof day !== 'number' || isNaN(day) || day < 0 || day > 6) {
      throw new Error(
        `isScheduleContiguous: Invalid day index ${day}, must be 0-6`
      )
    }
  }

  const sorted = [...selectedDayIndices].sort((a, b) => a - b)

  // If 6 or more days selected, it's contiguous (only 1 gap or no gaps)
  if (sorted.length >= 6) {
    return true
  }

  // Check for standard contiguous sequence (no wrap around)
  let isStandardContiguous = true
  for (let i = 1; i < sorted.length; i++) {
    if (sorted[i] !== sorted[i - 1] + 1) {
      isStandardContiguous = false
      break
    }
  }

  if (isStandardContiguous) {
    return true
  }

  // Check if selection includes both Sunday (0) and Saturday (6) - wrap-around case
  const hasZero = sorted.includes(0)
  const hasSix = sorted.includes(6)

  if (hasZero && hasSix) {
    // Week wrap-around case: use inverse logic (check not-selected days)
    // If the NOT selected days are contiguous, then selected days wrap around and are contiguous
    const allDays = [0, 1, 2, 3, 4, 5, 6]
    const notSelectedDays = allDays.filter(d => !sorted.includes(d))

    if (notSelectedDays.length === 0) {
      return true // All days selected
    }

    // Check if not-selected days form a contiguous block
    const minNotSelected = Math.min(...notSelectedDays)
    const maxNotSelected = Math.max(...notSelectedDays)

    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = []
    for (let i = minNotSelected; i <= maxNotSelected; i++) {
      expectedNotSelected.push(i)
    }

    // If not-selected days are contiguous, then selected days wrap around properly
    const notSelectedContiguous = notSelectedDays.length === expectedNotSelected.length &&
      notSelectedDays.every((day, index) => day === expectedNotSelected[index])

    return notSelectedContiguous
  }

  return false
}
```

#### Refactored Code
```javascript
/**
 * Schedule contiguity rules
 *
 * Validates that selected days form consecutive nights for split lease stays.
 */

/**
 * All valid day indices (0=Sunday through 6=Saturday)
 * @type {number[]}
 */
const ALL_DAYS = [0, 1, 2, 3, 4, 5, 6];

/**
 * Validate that a day index is valid (0-6)
 *
 * @param {*} day - Value to validate
 * @returns {boolean} Whether the day is a valid index
 */
const isValidDayIndex = (day) =>
  typeof day === 'number' && !isNaN(day) && day >= 0 && day <= 6;

/**
 * Check if an array of sorted days is contiguous (no gaps)
 *
 * @param {number[]} sortedDays - Sorted array of day indices
 * @returns {boolean} Whether days are consecutive
 */
const isConsecutive = (sortedDays) =>
  sortedDays.every((day, index) =>
    index === 0 || day === sortedDays[index - 1] + 1
  );

/**
 * Check if unselected days form a contiguous block
 * (if they do, the selected days properly wrap around the week)
 *
 * @param {number[]} sortedSelectedDays - Sorted array of selected day indices
 * @returns {boolean} Whether unselected days are contiguous
 */
const areUnselectedDaysContiguous = (sortedSelectedDays) => {
  const selectedSet = new Set(sortedSelectedDays);
  const unselectedDays = ALL_DAYS.filter((d) => !selectedSet.has(d));

  // If all days selected, wrap-around is trivially true
  if (unselectedDays.length === 0) {
    return true;
  }

  // Check if unselected days are consecutive
  return isConsecutive(unselectedDays);
};

/**
 * Check if selected days form a contiguous (consecutive) block.
 *
 * @intent Enforce the business rule that split lease stays must be consecutive nights.
 * @rule Days must be consecutive (Mon-Fri OK, Mon+Wed NOT OK).
 * @rule Handles week wrap-around cases (Fri-Sun OK, Sat-Tue OK).
 * @rule For wrap-around, uses inverse logic: if unselected days are contiguous, selected days wrap properly.
 * @rule 6 or more days is always contiguous (only 1 gap maximum possible).
 *
 * @param {object} params - Named parameters.
 * @param {number[]} params.selectedDayIndices - Array of day indices (0=Sunday through 6=Saturday).
 * @returns {boolean} True if days are contiguous, false otherwise.
 *
 * @throws {Error} If selectedDayIndices is not an array.
 * @throws {Error} If any day index is invalid (not 0-6).
 *
 * @example
 * isScheduleContiguous({ selectedDayIndices: [1, 2, 3, 4, 5] }) // true (Mon-Fri)
 * isScheduleContiguous({ selectedDayIndices: [1, 3, 5] }) // false (Mon, Wed, Fri - gaps)
 * isScheduleContiguous({ selectedDayIndices: [5, 6, 0] }) // true (Fri-Sun, wraps)
 * isScheduleContiguous({ selectedDayIndices: [6, 0, 1, 2] }) // true (Sat-Tue, wraps)
 */
export function isScheduleContiguous({ selectedDayIndices }) {
  // No Fallback: Validate input type
  if (!Array.isArray(selectedDayIndices)) {
    throw new Error(
      `isScheduleContiguous: selectedDayIndices must be an array, got ${typeof selectedDayIndices}`
    );
  }

  // Empty selection is not contiguous
  if (selectedDayIndices.length === 0) {
    return false;
  }

  // Single day is contiguous
  if (selectedDayIndices.length === 1) {
    return true;
  }

  // Validate all day indices (using functional check)
  const invalidDay = selectedDayIndices.find((day) => !isValidDayIndex(day));
  if (invalidDay !== undefined) {
    throw new Error(
      `isScheduleContiguous: Invalid day index ${invalidDay}, must be 0-6`
    );
  }

  const sorted = [...selectedDayIndices].sort((a, b) => a - b);

  // If 6 or more days selected, it's contiguous (at most 1 gap)
  if (sorted.length >= 6) {
    return true;
  }

  // Check for standard contiguous sequence (no wrap-around)
  if (isConsecutive(sorted)) {
    return true;
  }

  // Check for wrap-around case (selection includes both Sunday=0 and Saturday=6)
  const hasZero = sorted[0] === 0;
  const hasSix = sorted[sorted.length - 1] === 6;

  if (hasZero && hasSix) {
    // Week wrap-around: check if unselected days are contiguous
    return areUnselectedDaysContiguous(sorted);
  }

  return false;
}
```

#### Changes Made
- Extracted `ALL_DAYS` constant (single source of truth)
- Extracted `isValidDayIndex` predicate (reusable validation)
- Extracted `isConsecutive` function (replaces for-loop with `every`)
- Extracted `areUnselectedDaysContiguous` function (encapsulates wrap-around logic)
- Replaced `sorted.includes(0/6)` with index checks (more efficient for sorted arrays)
- Used `Set` for faster lookup in unselected days calculation
- Replaced for-loop validation with `find` + conditional (functional pattern)
- Eliminated nested for-loop for generating expected range (unnecessary)
- Added JSDoc annotations to helper functions

---

## Verification Steps

1. `cd app && bun run lint` - Expect 0 errors
2. `cd app && bun run build` - Expect successful build
3. Manual verification of affected pages:
   - Leases Overview page (uses filterLeases, sortLeases, canHardDeleteLease, adaptLeaseFromSupabase)
   - Search page (indirectly uses isScheduleContiguous via schedule selector)
4. Run existing tests if available

## Rollback Plan

If validation fails, reset these files:
- `app/src/lib/safeJson.js`
- `app/src/logic/rules/leases/isLeaseActive.js`
- `app/src/logic/rules/leases/canHardDeleteLease.js`
- `app/src/logic/processors/leases/sortLeases.js`
- `app/src/logic/processors/leases/filterLeases.js`
- `app/src/logic/calculators/scheduling/isContiguousSelection.js`
- `app/src/logic/rules/scheduling/isScheduleContiguous.js`

## Key Patterns Applied

| Pattern | Files | Description |
|---------|-------|-------------|
| Pure functions with optional date injection | `isLeaseActive.js` | Pass `asOf` parameter for testability |
| Lookup objects instead of switch | `sortLeases.js` | `FIELD_ACCESSORS` map |
| Extracted predicates | `filterLeases.js`, `canHardDeleteLease.js` | Small focused functions |
| Single source of truth | `isContiguousSelection.js` | Re-export from canonical location |
| `every`/`some`/`filter` over for-loops | `isScheduleContiguous.js`, `sortLeases.js` | Functional array methods |
| Constant extraction | `canHardDeleteLease.js`, `isScheduleContiguous.js` | `ACTIVE_STAY_STATUSES`, `ALL_DAYS` |

---

## File References

All files modified in this plan:
- `C:\Users\Split Lease\Documents\Split Lease\app\src\lib\safeJson.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\logic\rules\leases\isLeaseActive.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\logic\rules\leases\canHardDeleteLease.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\logic\processors\leases\sortLeases.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\logic\processors\leases\filterLeases.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\logic\calculators\scheduling\isContiguousSelection.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\logic\rules\scheduling\isScheduleContiguous.js`

Files that depend on the modified files:
- `C:\Users\Split Lease\Documents\Split Lease\app\src\islands\pages\LeasesOverviewPage\useLeasesOverviewPageLogic.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\islands\pages\LeasesOverviewPage\components\LeaseCard.jsx`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\lib\availabilityValidation.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\islands\shared\useScheduleSelectorLogicCore.js`
- `C:\Users\Split Lease\Documents\Split Lease\app\src\logic\workflows\scheduling\validateScheduleWorkflow.js`


## Your Task

Implement ALL changes described in the plan above. For each file listed:

1. **Read** the current file content
2. **Locate** the code section to modify (match the "Current Code" block)
3. **Replace** with the "Refactored Code" block EXACTLY as shown
4. **Verify** the file was modified correctly by reading it back

## Rules

- Follow the **Implementation Order** specified in the plan
- Do NOT skip any files
- Do NOT commit changes (we validate first)
- Do NOT run build commands
- If a file doesn't exist or code doesn't match, report the error and continue

## On Completion

When all files are implemented, output:
```
IMPLEMENTATION COMPLETE
Files modified: [count]
```

Begin implementation now.
