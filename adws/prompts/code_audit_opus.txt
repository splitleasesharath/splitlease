/ralph-loop:ralph-loop

Audit the codebase at: {target_path}

---

## REFACTORING DEFINITION (CRITICAL)

**ADW refactoring is BEHAVIOR-PRESERVING.** The goal is to make code more pure/functional WITHOUT changing what it does.

### What "Refactor" Means

| ✅ This IS Refactoring | ❌ This is NOT Refactoring |
|------------------------|---------------------------|
| `arr.push(x)` → `[...arr, x]` | Adding validation that wasn't there |
| `for` loop → `.map()` | Fixing an off-by-one error |
| Extract pure function | Adding a new parameter |
| `let` → `const` | Changing error messages |
| Remove dead code | Adding logging |
| Inline trivial helper | Changing default values |

### HARD REQUIREMENTS

1. **All exported signatures must remain IDENTICAL** - function names, parameters, return types unchanged
2. **All behavior must be UNCHANGED** - same inputs → same outputs, same side effects in same order
3. **All changes must pass** `tsc --noEmit` and `bun run build`
4. **Changes must be small and reversible** - one concept per chunk

### VIOLATION PROTOCOL

```
If ANY rule is violated: STOP. That is NOT a refactor—it is a bug introduction.
```

**Bugs that exist in the codebase MUST REMAIN as bugs.** We are NOT fixing anything. We are ONLY restructuring code to be more functional while preserving EXACT behavior.

---

## TARGET FILE SCOPE (JS/TS ONLY)

This audit targets **JavaScript and TypeScript files ONLY**:

| Extension | Included | Extension | Included |
|-----------|----------|-----------|----------|
| `.js` | ✅ Yes | `.py` | ❌ No |
| `.jsx` | ✅ Yes | `.css` | ❌ No |
| `.ts` | ✅ Yes | `.json` | ❌ No |
| `.tsx` | ✅ Yes | `.md` | ❌ No |
| `.mjs` | ✅ Yes | Other | ❌ No |
| `.cjs` | ✅ Yes | | |

**Skip all non-JS/TS files.** Focus only on React components, utilities, logic, and Edge Functions.

---

## PRE-COMPUTED DEPENDENCY CONTEXT

The following dependency analysis was generated by AST parsing (100% accurate):

{semantic_context}

### How to Use This Context

1. **Symbol Table**: Shows what each file exports. When renaming a function, this tells you exactly where it's defined.

2. **Dependency Graph**: Shows what each file imports. Use this instead of scanning files yourself.

3. **Reverse Dependencies**: Shows who depends on each file. When modifying `pricing.js`, the reverse deps tell you EVERY file that imports from it.

**IMPORTANT**: Trust this data—it's machine-parsed, not inferred. Use it for:
- Identifying affected files (don't guess, look up in reverse_dependencies)
- Grouping cascading changes (all dependents of a modified file go together)
- Ordering chunks (files with no dependents can be modified first)

---

## YOUR TASK

1. **Scan all JS/TS files** in {target_path} recursively (ignore non-JS/TS files).
2. **Identify FP violations:** mutation, imperative loops, impure functions, mixed concerns, or specifically {audit_type} issues.
3. **For each issue, determine cascading impact:**
   - Use the provided dependency graph to identify affected files (do NOT re-scan files).
   - Use reverse_dependencies to find ALL consumers of modified code.
   - Include ALL affected files in the same chunk or related chunks.
   - List page URLs (e.g., "/search, /view-split-lease").
   - If it's a shared utility or logic, identify all entry points via reverse deps.
   - If uncertain, use "AUTO".

4. **Create a chunk-based refactoring plan** at: .claude/plans/New/{timestamp}_code_refactor_plan.md

**CRITICAL: Group chunks by affected page group, ordered by dependency.**

### CHUNK CATEGORIES (Execute in Order)

Chunks MUST be categorized and ordered:

| Category | Code | Purpose | Execute When |
|----------|------|---------|--------------|
| **SCAFFOLD** | `S` | Create new files, add exports | FIRST (before migrate) |
| **MIGRATE** | `M` | Update existing code, change imports | SECOND (after scaffold) |
| **CLEANUP** | `C` | Remove old code, unused imports | LAST (after migrate) |

**Dependency Rule**: If Chunk B imports from Chunk A's new export, Chunk A MUST be SCAFFOLD and come BEFORE Chunk B.

---

### OUTPUT STRUCTURE

```markdown
# Code Refactoring Plan - {target_path}

Date: {date}
Audit Type: {audit_type}

## Page Group: /search

### Chunk 1: [Brief description]
**Category:** MIGRATE
**Files Affected:** [path(s)]
**Line:** [line range]
**Expected Affected Pages:** /search
**Depends On:** (none)

**Current Code** (`path:line-range`):
```javascript
[exact code]
```

**Refactored Code** (`path:line-range`):
```javascript
[refactored code]
```

### Chunk 2: [Brief description]
**Category:** SCAFFOLD
...

## Page Group: /view-split-lease

### Chunk 3: [Brief description]
**Category:** CLEANUP
**Depends On:** Chunk 1, Chunk 2
...

## Page Group: GLOBAL (Affects Multiple Pages)

### Chunk 4: [Brief description for shared utilities]
...
```

---

**CRITICAL FORMATTING RULES:**
1. **Group by Page Group** header (use "GLOBAL" for shared/utility code).
2. **One chunk = one atomic, behavior-preserving refactor**.
3. **MANDATORY: Each chunk MUST have TWO complete code blocks (Current vs Refactored)**.
4. **MANDATORY: Each chunk MUST specify Category (SCAFFOLD, MIGRATE, or CLEANUP)**.
5. **MANDATORY: Each chunk MUST specify Depends On (list chunk numbers or "none")**.
6. **Line numbers must be accurate** - use format `path:startLine-endLine`.
7. **Include affected pages in EACH chunk metadata**.
8. **All SCAFFOLD chunks must come before MIGRATE chunks that depend on them**.

### FP REFACTORING PATTERNS TO APPLY

Only apply these behavior-preserving transformations:

| Pattern | Before | After |
|---------|--------|-------|
| Mutation → Immutable | `arr.push(x)` | `[...arr, x]` |
| Loop → Map | `for (i=0; i<arr.length; i++) { results.push(arr[i].x) }` | `arr.map(item => item.x)` |
| Loop → Filter | `for (item of arr) { if (cond) results.push(item) }` | `arr.filter(item => cond)` |
| Loop → Reduce | `let sum = 0; for (n of arr) sum += n` | `arr.reduce((sum, n) => sum + n, 0)` |
| let → const | `let x = 5; return x;` | `const x = 5; return x;` |
| Extract Pure | Mixed I/O + calculation | Separate pure calc function |
