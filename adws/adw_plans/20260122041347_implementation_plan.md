# Implementation Plan - app/src General Code Quality Audit

**Date:** 2026-01-22
**Audit Type:** general
**Generated By:** Claude Opus (ADW Pipeline)

---

## Summary

| Metric | Value |
|--------|-------|
| Files to modify | 6 |
| Risk level | LOW |
| Estimated changes | Extract magic numbers, consolidate duplicated verification logic, add missing index exports |

## Issues Identified

### 1. Magic Numbers in Score Calculations
- `calculateBoroughScore.js` line 62: hardcoded `15` for adjacent borough score
- `calculatePriceScore.js` lines 78-86: hardcoded `15`, `10`, `5` for threshold scores
- `calculateHostScore.js` lines 48-51: hardcoded `3`, `1` for verification score mapping
- `formatMatchResult.js` lines 99-142: hardcoded score thresholds for descriptions

### 2. Duplicated Verification Field Extraction
- `isVerifiedHost.js` lines 41-45 and 74-77: identical verification field extraction logic duplicated in both `isVerifiedHost()` and `countHostVerifications()`

### 3. Missing Index Exports
- `extractBorough.js` and its helper functions are not exported from `processors/matching/index.js`

### 4. Unnecessary Parameter Duplication
- `calculateBoroughScore.js` duplicates borough extraction logic that exists in `extractBorough.js`
- `calculateMatchHeuristics.js` lines 46-55 duplicates the same borough extraction pattern

---

## Implementation Order

1. `app/src/logic/calculators/matching/constants.js` - Add missing score constants
2. `app/src/logic/calculators/matching/calculateBoroughScore.js` - Use constants instead of magic number
3. `app/src/logic/calculators/matching/calculatePriceScore.js` - Use constants for threshold scores
4. `app/src/logic/calculators/matching/calculateHostScore.js` - Use constants for verification score mapping
5. `app/src/logic/rules/matching/isVerifiedHost.js` - Extract shared verification field accessor
6. `app/src/logic/processors/matching/index.js` - Add missing exports

---

## File Changes

### 1. `app/src/logic/calculators/matching/constants.js`

**Reason:** Add missing score constants for adjacent borough, price thresholds, and host verification scores to eliminate magic numbers across multiple files.
**Dependents:** 6 (within matching module)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Quick Match Scoring Constants
 *
 * Defines weights, thresholds, and reference data for the matching algorithm.
 * Maximum possible score is 95 (price drop heuristic not implemented due to missing data).
 *
 * @module logic/calculators/matching/constants
 */

/**
 * Score weights for each matching criterion.
 * Total: 95 points (5 points unavailable due to missing price history data)
 */
export const MATCH_WEIGHTS = {
  BOROUGH: 25,        // Location proximity
  PRICE: 20,          // Price similarity
  SCHEDULE: 20,       // Schedule day overlap
  WEEKLY_STAY: 15,    // Support for 7-night stays
  DURATION: 10,       // Minimum nights compatibility
  HOST: 5             // Host verification proxy
  // PRICE_DROP: 5    // Not implemented (no price history tracking)
};

/**
 * NYC borough adjacency map for location scoring.
 * Adjacent boroughs receive partial score (15 points vs 25 for exact match).
 */
export const NYC_BOROUGH_ADJACENCY = {
  manhattan: ['brooklyn', 'queens', 'bronx'],
  brooklyn: ['manhattan', 'queens', 'staten island'],
  queens: ['manhattan', 'brooklyn', 'bronx'],
  bronx: ['manhattan', 'queens'],
  'staten island': ['brooklyn']
};

/**
 * Score tiers for categorizing match quality.
 * Used by formatMatchResult to assign tier labels.
 */
export const SCORE_TIERS = {
  EXCELLENT: 75,  // 75+ = excellent match
  GOOD: 50,       // 50-74 = good match
  FAIR: 25        // 25-49 = fair match, below = poor match
};

/**
 * Price proximity thresholds for scoring.
 * Each threshold maps to a score value.
 */
export const PRICE_THRESHOLDS = {
  WITHIN_10_PERCENT: 0.10,  // 20 points
  WITHIN_20_PERCENT: 0.20,  // 15 points
  WITHIN_30_PERCENT: 0.30,  // 10 points
  WITHIN_50_PERCENT: 0.50   // 5 points
};

/**
 * Minimum verification count for host to be considered "verified".
 */
export const MIN_HOST_VERIFICATIONS = 2;

/**
 * Maximum possible score with current data availability.
 */
export const MAX_POSSIBLE_SCORE = 95;

/**
 * Tier labels for display.
 */
export const TIER_LABELS = {
  EXCELLENT: 'excellent',
  GOOD: 'good',
  FAIR: 'fair',
  POOR: 'poor'
};
```

#### Refactored Code
```javascript
/**
 * Quick Match Scoring Constants
 *
 * Defines weights, thresholds, and reference data for the matching algorithm.
 * Maximum possible score is 95 (price drop heuristic not implemented due to missing data).
 *
 * @module logic/calculators/matching/constants
 */

/**
 * Score weights for each matching criterion.
 * Total: 95 points (5 points unavailable due to missing price history data)
 */
export const MATCH_WEIGHTS = {
  BOROUGH: 25,        // Location proximity
  PRICE: 20,          // Price similarity
  SCHEDULE: 20,       // Schedule day overlap
  WEEKLY_STAY: 15,    // Support for 7-night stays
  DURATION: 10,       // Minimum nights compatibility
  HOST: 5             // Host verification proxy
  // PRICE_DROP: 5    // Not implemented (no price history tracking)
};

/**
 * Adjacent borough score (60% of full borough score).
 * Used when boroughs are neighbors but not exact match.
 */
export const ADJACENT_BOROUGH_SCORE = 15;

/**
 * Price proximity scores for each threshold tier.
 * Maps threshold ranges to score values.
 */
export const PRICE_THRESHOLD_SCORES = {
  WITHIN_20_PERCENT: 15,
  WITHIN_30_PERCENT: 10,
  WITHIN_50_PERCENT: 5
};

/**
 * Host verification score mapping.
 * Maps verification count to score value.
 */
export const HOST_VERIFICATION_SCORES = {
  THREE_VERIFICATIONS: 5,  // Full HOST score
  TWO_VERIFICATIONS: 3,
  ONE_VERIFICATION: 1,
  NO_VERIFICATIONS: 0
};

/**
 * NYC borough adjacency map for location scoring.
 * Adjacent boroughs receive partial score (15 points vs 25 for exact match).
 */
export const NYC_BOROUGH_ADJACENCY = {
  manhattan: ['brooklyn', 'queens', 'bronx'],
  brooklyn: ['manhattan', 'queens', 'staten island'],
  queens: ['manhattan', 'brooklyn', 'bronx'],
  bronx: ['manhattan', 'queens'],
  'staten island': ['brooklyn']
};

/**
 * Score tiers for categorizing match quality.
 * Used by formatMatchResult to assign tier labels.
 */
export const SCORE_TIERS = {
  EXCELLENT: 75,  // 75+ = excellent match
  GOOD: 50,       // 50-74 = good match
  FAIR: 25        // 25-49 = fair match, below = poor match
};

/**
 * Price proximity thresholds for scoring.
 * Each threshold maps to a score value.
 */
export const PRICE_THRESHOLDS = {
  WITHIN_10_PERCENT: 0.10,  // 20 points
  WITHIN_20_PERCENT: 0.20,  // 15 points
  WITHIN_30_PERCENT: 0.30,  // 10 points
  WITHIN_50_PERCENT: 0.50   // 5 points
};

/**
 * Minimum verification count for host to be considered "verified".
 */
export const MIN_HOST_VERIFICATIONS = 2;

/**
 * Maximum possible score with current data availability.
 */
export const MAX_POSSIBLE_SCORE = 95;

/**
 * Tier labels for display.
 */
export const TIER_LABELS = {
  EXCELLENT: 'excellent',
  GOOD: 'good',
  FAIR: 'fair',
  POOR: 'poor'
};
```

#### Changes Made
- Added `ADJACENT_BOROUGH_SCORE` constant (value: 15) for adjacent borough partial scoring
- Added `PRICE_THRESHOLD_SCORES` object with score values for each proximity tier
- Added `HOST_VERIFICATION_SCORES` object mapping verification counts to scores

---

### 2. `app/src/logic/calculators/matching/calculateBoroughScore.js`

**Reason:** Replace hardcoded magic number `15` with named constant for adjacent borough score.
**Dependents:** 1 (calculateMatchScore.js)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate borough match score for a candidate listing.
 *
 * @intent Score geographic proximity between candidate and proposal listings.
 * @rule Same borough = 25 points (full match).
 * @rule Adjacent borough = 15 points (partial match).
 * @rule Different/non-adjacent = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object.
 * @param {object} params.proposal - Proposal object with nested listing data.
 * @returns {number} Score from 0-25.
 *
 * @example
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Manhattan' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 25 (exact match)
 *
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Brooklyn' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 15 (adjacent)
 */
import { isBoroughAdjacent } from '../../rules/matching/isBoroughAdjacent.js';
import { MATCH_WEIGHTS } from './constants.js';

export function calculateBoroughScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Extract borough names from both objects, checking multiple possible field names
  const candidateBorough =
    candidateListing.boroughName ||
    candidateListing['Location - Borough'] ||
    null;

  const proposalBorough =
    proposal.listing?.boroughName ||
    proposal.listing?.borough ||
    proposal.listing?.['Location - Borough'] ||
    null;

  if (!candidateBorough || !proposalBorough) {
    return 0;
  }

  const normalizedCandidate = candidateBorough.toLowerCase().trim();
  const normalizedProposal = proposalBorough.toLowerCase().trim();

  // Exact match = full points
  if (normalizedCandidate === normalizedProposal) {
    return MATCH_WEIGHTS.BOROUGH;
  }

  // Adjacent match = partial points (60% of full)
  if (isBoroughAdjacent({ borough1: normalizedProposal, borough2: normalizedCandidate })) {
    return 15;
  }

  // No match
  return 0;
}
```

#### Refactored Code
```javascript
/**
 * Calculate borough match score for a candidate listing.
 *
 * @intent Score geographic proximity between candidate and proposal listings.
 * @rule Same borough = 25 points (full match).
 * @rule Adjacent borough = 15 points (partial match).
 * @rule Different/non-adjacent = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object.
 * @param {object} params.proposal - Proposal object with nested listing data.
 * @returns {number} Score from 0-25.
 *
 * @example
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Manhattan' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 25 (exact match)
 *
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Brooklyn' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 15 (adjacent)
 */
import { isBoroughAdjacent } from '../../rules/matching/isBoroughAdjacent.js';
import { MATCH_WEIGHTS, ADJACENT_BOROUGH_SCORE } from './constants.js';

export function calculateBoroughScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Extract borough names from both objects, checking multiple possible field names
  const candidateBorough =
    candidateListing.boroughName ||
    candidateListing['Location - Borough'] ||
    null;

  const proposalBorough =
    proposal.listing?.boroughName ||
    proposal.listing?.borough ||
    proposal.listing?.['Location - Borough'] ||
    null;

  if (!candidateBorough || !proposalBorough) {
    return 0;
  }

  const normalizedCandidate = candidateBorough.toLowerCase().trim();
  const normalizedProposal = proposalBorough.toLowerCase().trim();

  // Exact match = full points
  if (normalizedCandidate === normalizedProposal) {
    return MATCH_WEIGHTS.BOROUGH;
  }

  // Adjacent match = partial points (60% of full)
  if (isBoroughAdjacent({ borough1: normalizedProposal, borough2: normalizedCandidate })) {
    return ADJACENT_BOROUGH_SCORE;
  }

  // No match
  return 0;
}
```

#### Changes Made
- Imported `ADJACENT_BOROUGH_SCORE` from constants
- Replaced hardcoded `15` with `ADJACENT_BOROUGH_SCORE` constant

---

### 3. `app/src/logic/calculators/matching/calculatePriceScore.js`

**Reason:** Replace hardcoded score values (15, 10, 5) with named constants for better maintainability.
**Dependents:** 1 (calculateMatchScore.js)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate price proximity score for a candidate listing.
 *
 * @intent Score how close candidate pricing is to proposal budget.
 * @rule Within 10% = 20 points (full score).
 * @rule Within 20% = 15 points.
 * @rule Within 30% = 10 points.
 * @rule Within 50% = 5 points.
 * @rule Over 50% = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object with pricing fields.
 * @param {object} params.proposal - Proposal object with nightly price and nights per week.
 * @returns {number} Score from 0-20.
 *
 * @example
 * calculatePriceScore({
 *   candidateListing: { 'ðŸ’°Nightly Host Rate for 4 nights': 105 },
 *   proposal: { nightlyPrice: 100, nightsPerWeek: 4 }
 * })
 * // => 20 (5% difference, within 10%)
 */
import { getNightlyRateByFrequency } from '../pricing/getNightlyRateByFrequency.js';
import { calculatePriceProximity } from './calculatePriceProximity.js';
import { MATCH_WEIGHTS, PRICE_THRESHOLDS } from './constants.js';

export function calculatePriceScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Determine nights per week from proposal
  const nightsPerWeek =
    proposal.nightsPerWeek ||
    proposal.daysSelected?.length ||
    4; // Default to 4 if not specified

  // Get proposal nightly price
  const proposalNightlyRate = proposal.nightlyPrice;

  if (!proposalNightlyRate || proposalNightlyRate <= 0) {
    return 0;
  }

  // Get candidate nightly rate for same frequency
  let candidateNightlyRate;
  try {
    candidateNightlyRate = getNightlyRateByFrequency({
      listing: candidateListing,
      nightsSelected: nightsPerWeek
    });
  } catch {
    // If we can't get a rate for this frequency, return 0
    return 0;
  }

  if (!candidateNightlyRate || candidateNightlyRate <= 0) {
    return 0;
  }

  // Calculate proximity ratio
  let proximity;
  try {
    proximity = calculatePriceProximity({
      candidateNightlyRate,
      proposalNightlyRate
    });
  } catch {
    return 0;
  }

  // Score based on proximity thresholds
  if (proximity <= PRICE_THRESHOLDS.WITHIN_10_PERCENT) {
    return MATCH_WEIGHTS.PRICE; // 20 points
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_20_PERCENT) {
    return 15;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_30_PERCENT) {
    return 10;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_50_PERCENT) {
    return 5;
  }

  return 0;
}
```

#### Refactored Code
```javascript
/**
 * Calculate price proximity score for a candidate listing.
 *
 * @intent Score how close candidate pricing is to proposal budget.
 * @rule Within 10% = 20 points (full score).
 * @rule Within 20% = 15 points.
 * @rule Within 30% = 10 points.
 * @rule Within 50% = 5 points.
 * @rule Over 50% = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object with pricing fields.
 * @param {object} params.proposal - Proposal object with nightly price and nights per week.
 * @returns {number} Score from 0-20.
 *
 * @example
 * calculatePriceScore({
 *   candidateListing: { 'ðŸ’°Nightly Host Rate for 4 nights': 105 },
 *   proposal: { nightlyPrice: 100, nightsPerWeek: 4 }
 * })
 * // => 20 (5% difference, within 10%)
 */
import { getNightlyRateByFrequency } from '../pricing/getNightlyRateByFrequency.js';
import { calculatePriceProximity } from './calculatePriceProximity.js';
import { MATCH_WEIGHTS, PRICE_THRESHOLDS, PRICE_THRESHOLD_SCORES } from './constants.js';

export function calculatePriceScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Determine nights per week from proposal
  const nightsPerWeek =
    proposal.nightsPerWeek ||
    proposal.daysSelected?.length ||
    4; // Default to 4 if not specified

  // Get proposal nightly price
  const proposalNightlyRate = proposal.nightlyPrice;

  if (!proposalNightlyRate || proposalNightlyRate <= 0) {
    return 0;
  }

  // Get candidate nightly rate for same frequency
  let candidateNightlyRate;
  try {
    candidateNightlyRate = getNightlyRateByFrequency({
      listing: candidateListing,
      nightsSelected: nightsPerWeek
    });
  } catch {
    // If we can't get a rate for this frequency, return 0
    return 0;
  }

  if (!candidateNightlyRate || candidateNightlyRate <= 0) {
    return 0;
  }

  // Calculate proximity ratio
  let proximity;
  try {
    proximity = calculatePriceProximity({
      candidateNightlyRate,
      proposalNightlyRate
    });
  } catch {
    return 0;
  }

  // Score based on proximity thresholds
  if (proximity <= PRICE_THRESHOLDS.WITHIN_10_PERCENT) {
    return MATCH_WEIGHTS.PRICE; // 20 points
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_20_PERCENT) {
    return PRICE_THRESHOLD_SCORES.WITHIN_20_PERCENT;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_30_PERCENT) {
    return PRICE_THRESHOLD_SCORES.WITHIN_30_PERCENT;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_50_PERCENT) {
    return PRICE_THRESHOLD_SCORES.WITHIN_50_PERCENT;
  }

  return 0;
}
```

#### Changes Made
- Imported `PRICE_THRESHOLD_SCORES` from constants
- Replaced hardcoded `15` with `PRICE_THRESHOLD_SCORES.WITHIN_20_PERCENT`
- Replaced hardcoded `10` with `PRICE_THRESHOLD_SCORES.WITHIN_30_PERCENT`
- Replaced hardcoded `5` with `PRICE_THRESHOLD_SCORES.WITHIN_50_PERCENT`

---

### 4. `app/src/logic/calculators/matching/calculateHostScore.js`

**Reason:** Replace hardcoded score values (3, 1) with named constants and consolidate verification count to score mapping.
**Dependents:** 1 (calculateMatchScore.js)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate host verification score for a candidate listing.
 *
 * @intent Score host trustworthiness based on verification status.
 * @rule 3 verifications = 5 points (full score).
 * @rule 2 verifications = 3 points.
 * @rule 1 verification = 1 point.
 * @rule 0 verifications = 0 points.
 * @rule Used as proxy for host responsiveness (no response rate data).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.hostData - Host/user object with verification fields.
 * @returns {number} Score from 0-5.
 *
 * @example
 * calculateHostScore({
 *   hostData: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 5 (3 verifications)
 *
 * calculateHostScore({
 *   hostData: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': false,
 *     'user verified?': false
 *   }
 * })
 * // => 1 (1 verification)
 */
import { countHostVerifications } from '../../rules/matching/isVerifiedHost.js';
import { MATCH_WEIGHTS } from './constants.js';

export function calculateHostScore({ hostData }) {
  if (!hostData) {
    return 0;
  }

  const verificationCount = countHostVerifications({ host: hostData });

  // Score mapping based on verification count
  switch (verificationCount) {
    case 3:
      return MATCH_WEIGHTS.HOST; // 5 points
    case 2:
      return 3;
    case 1:
      return 1;
    default:
      return 0;
  }
}
```

#### Refactored Code
```javascript
/**
 * Calculate host verification score for a candidate listing.
 *
 * @intent Score host trustworthiness based on verification status.
 * @rule 3 verifications = 5 points (full score).
 * @rule 2 verifications = 3 points.
 * @rule 1 verification = 1 point.
 * @rule 0 verifications = 0 points.
 * @rule Used as proxy for host responsiveness (no response rate data).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.hostData - Host/user object with verification fields.
 * @returns {number} Score from 0-5.
 *
 * @example
 * calculateHostScore({
 *   hostData: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 5 (3 verifications)
 *
 * calculateHostScore({
 *   hostData: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': false,
 *     'user verified?': false
 *   }
 * })
 * // => 1 (1 verification)
 */
import { countHostVerifications } from '../../rules/matching/isVerifiedHost.js';
import { HOST_VERIFICATION_SCORES } from './constants.js';

export function calculateHostScore({ hostData }) {
  if (!hostData) {
    return HOST_VERIFICATION_SCORES.NO_VERIFICATIONS;
  }

  const verificationCount = countHostVerifications({ host: hostData });

  // Score mapping based on verification count
  switch (verificationCount) {
    case 3:
      return HOST_VERIFICATION_SCORES.THREE_VERIFICATIONS;
    case 2:
      return HOST_VERIFICATION_SCORES.TWO_VERIFICATIONS;
    case 1:
      return HOST_VERIFICATION_SCORES.ONE_VERIFICATION;
    default:
      return HOST_VERIFICATION_SCORES.NO_VERIFICATIONS;
  }
}
```

#### Changes Made
- Imported `HOST_VERIFICATION_SCORES` instead of `MATCH_WEIGHTS`
- Replaced `MATCH_WEIGHTS.HOST` with `HOST_VERIFICATION_SCORES.THREE_VERIFICATIONS`
- Replaced hardcoded `3` with `HOST_VERIFICATION_SCORES.TWO_VERIFICATIONS`
- Replaced hardcoded `1` with `HOST_VERIFICATION_SCORES.ONE_VERIFICATION`
- Replaced hardcoded `0` with `HOST_VERIFICATION_SCORES.NO_VERIFICATIONS`

---

### 5. `app/src/logic/rules/matching/isVerifiedHost.js`

**Reason:** Extract duplicated verification field accessor into a shared helper function to eliminate code duplication between `isVerifiedHost()` and `countHostVerifications()`.
**Dependents:** 2 (calculateHostScore.js, adaptCandidateListing.js)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Check if host has sufficient verification status.
 *
 * @intent Determine host trustworthiness based on verification fields.
 * @rule Counts LinkedIn, Phone, and user verified fields.
 * @rule Host is "verified" if they have >= minimum verifications (default 2).
 * @rule Used as proxy for host responsiveness (no response rate data available).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @param {number} [params.minVerifications=2] - Minimum verifications required.
 * @returns {boolean} True if host meets verification threshold.
 *
 * @example
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => true (2 verifications meet default minimum of 2)
 *
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': false,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => false (only 1 verification)
 */
import { MIN_HOST_VERIFICATIONS } from '../../calculators/matching/constants.js';

export function isVerifiedHost({ host, minVerifications = MIN_HOST_VERIFICATIONS }) {
  if (!host) {
    return false;
  }

  // Count verification fields
  const verifications = [
    host['Verify - Linked In ID'] || host.linkedInVerified || false,
    host['Verify - Phone'] || host.phoneVerified || false,
    host['user verified?'] || host.userVerified || false
  ];

  const verificationCount = verifications.filter(Boolean).length;

  return verificationCount >= minVerifications;
}

/**
 * Count the number of verifications a host has.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @returns {number} Count of verifications (0-3).
 *
 * @example
 * countHostVerifications({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 3
 */
export function countHostVerifications({ host }) {
  if (!host) {
    return 0;
  }

  const verifications = [
    host['Verify - Linked In ID'] || host.linkedInVerified || false,
    host['Verify - Phone'] || host.phoneVerified || false,
    host['user verified?'] || host.userVerified || false
  ];

  return verifications.filter(Boolean).length;
}
```

#### Refactored Code
```javascript
/**
 * Check if host has sufficient verification status.
 *
 * @intent Determine host trustworthiness based on verification fields.
 * @rule Counts LinkedIn, Phone, and user verified fields.
 * @rule Host is "verified" if they have >= minimum verifications (default 2).
 * @rule Used as proxy for host responsiveness (no response rate data available).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @param {number} [params.minVerifications=2] - Minimum verifications required.
 * @returns {boolean} True if host meets verification threshold.
 *
 * @example
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => true (2 verifications meet default minimum of 2)
 *
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': false,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => false (only 1 verification)
 */
import { MIN_HOST_VERIFICATIONS } from '../../calculators/matching/constants.js';

/**
 * Extract verification field values from host object.
 * Handles both Bubble field names and camelCase aliases.
 *
 * @param {object} host - Host/user object with verification fields.
 * @returns {boolean[]} Array of verification boolean values.
 */
function extractVerificationFields(host) {
  return [
    host['Verify - Linked In ID'] || host.linkedInVerified || false,
    host['Verify - Phone'] || host.phoneVerified || false,
    host['user verified?'] || host.userVerified || false
  ];
}

export function isVerifiedHost({ host, minVerifications = MIN_HOST_VERIFICATIONS }) {
  if (!host) {
    return false;
  }

  const verificationCount = extractVerificationFields(host).filter(Boolean).length;

  return verificationCount >= minVerifications;
}

/**
 * Count the number of verifications a host has.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @returns {number} Count of verifications (0-3).
 *
 * @example
 * countHostVerifications({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 3
 */
export function countHostVerifications({ host }) {
  if (!host) {
    return 0;
  }

  return extractVerificationFields(host).filter(Boolean).length;
}
```

#### Changes Made
- Extracted `extractVerificationFields()` helper function to eliminate duplication
- Both `isVerifiedHost()` and `countHostVerifications()` now use the shared helper
- Added JSDoc for the helper function

---

### 6. `app/src/logic/processors/matching/index.js`

**Reason:** Add missing exports for `extractBorough` functions to make them accessible via the module index.
**Dependents:** 0 (index file)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Matching Processors
 *
 * Data transformation functions for Quick Match algorithm.
 * Adapts raw data to normalized formats and formats results for display.
 *
 * @module logic/processors/matching
 */

// Data adapters
export { adaptCandidateListing } from './adaptCandidateListing.js';
export { adaptProposalForMatching } from './adaptProposalForMatching.js';

// Result formatters
export { formatMatchResult, getTier } from './formatMatchResult.js';
```

#### Refactored Code
```javascript
/**
 * Matching Processors
 *
 * Data transformation functions for Quick Match algorithm.
 * Adapts raw data to normalized formats and formats results for display.
 *
 * @module logic/processors/matching
 */

// Data adapters
export { adaptCandidateListing } from './adaptCandidateListing.js';
export { adaptProposalForMatching } from './adaptProposalForMatching.js';

// Borough extraction utilities
export {
  extractBorough,
  extractCandidateBorough,
  extractProposalBorough
} from './extractBorough.js';

// Result formatters
export { formatMatchResult, getTier } from './formatMatchResult.js';
```

#### Changes Made
- Added exports for `extractBorough`, `extractCandidateBorough`, and `extractProposalBorough` from `extractBorough.js`
- Organized exports with a section comment for borough extraction utilities

---

## Edge Cases & Error Handling

- All changes maintain existing error handling patterns (NO FALLBACK philosophy)
- Constants are used by existing validation logic unchanged
- No changes to function signatures or return types

## Testing Considerations

- Verify `calculateBoroughScore` returns `ADJACENT_BOROUGH_SCORE` (15) for adjacent boroughs
- Verify `calculatePriceScore` returns correct threshold scores (15, 10, 5)
- Verify `calculateHostScore` returns correct verification scores (5, 3, 1, 0)
- Verify `countHostVerifications` and `isVerifiedHost` produce identical results as before
- Verify `extractBorough` functions are accessible via index import

## Rollback Strategy

- Each file change is independent and can be reverted individually
- Constants are additive (no removals) so existing code remains compatible
- If issues arise, revert to hardcoded values in calculator files

## Dependencies & Blockers

- None - all changes are within the logic layer with no external dependencies

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Constant value mismatch | Low | Medium | Values are directly copied from existing hardcoded values |
| Import path errors | Low | Low | All imports use existing patterns |
| Behavioral regression | Very Low | Medium | No logic changes, only value extraction to constants |

---

## Files Referenced

| File Path | Purpose |
|-----------|---------|
| `app/src/logic/calculators/matching/constants.js` | Add new score constants |
| `app/src/logic/calculators/matching/calculateBoroughScore.js` | Use ADJACENT_BOROUGH_SCORE |
| `app/src/logic/calculators/matching/calculatePriceScore.js` | Use PRICE_THRESHOLD_SCORES |
| `app/src/logic/calculators/matching/calculateHostScore.js` | Use HOST_VERIFICATION_SCORES |
| `app/src/logic/rules/matching/isVerifiedHost.js` | Extract shared verification helper |
| `app/src/logic/processors/matching/index.js` | Add extractBorough exports |
| `app/src/logic/calculators/matching/index.js` | Reference (exports constants) |
| `app/src/logic/rules/matching/index.js` | Reference (exports rules) |
| `app/src/logic/processors/matching/extractBorough.js` | Reference (contains functions to export) |
| `app/src/logic/calculators/matching/calculateMatchScore.js` | Reference (depends on calculators) |
| `app/src/logic/calculators/matching/calculateMatchHeuristics.js` | Reference (uses constants) |
| `app/src/logic/processors/matching/formatMatchResult.js` | Reference (uses score thresholds) |
