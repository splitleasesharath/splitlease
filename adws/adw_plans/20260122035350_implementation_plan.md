# Implementation Plan - ../app

**Date:** 2026-01-22
**Audit Type:** general
**Generated By:** Claude Opus (ADW Pipeline)

---

## Summary

| Metric | Value |
|--------|-------|
| Files to modify | 7 |
| Risk level | LOW |
| Estimated changes | Extract duplicated validation logic, consolidate borough extraction patterns, add reusable price threshold scoring function |

## Analysis Findings

### Pattern 1: Duplicated Borough Extraction Logic
The borough extraction pattern is duplicated across multiple files:
- `calculateBoroughScore.js` (lines 36-45)
- `calculateMatchHeuristics.js` (lines 46-55)
- `isBoroughMatch.js` (lines 36-37)

### Pattern 2: Duplicated Host Verification Logic
The verification field extraction is duplicated in `isVerifiedHost.js`:
- `isVerifiedHost()` function (lines 41-45)
- `countHostVerifications()` function (lines 74-78)

### Pattern 3: Magic Numbers in Price Score Thresholds
`calculatePriceScore.js` and `formatMatchResult.js` have hardcoded threshold values (15, 10, 5) that should reference constants.

### Pattern 4: Input Validation Patterns
Several calculators have inline validation that could use the established `commonValidators.js` utilities.

## Implementation Order

List files in dependency order (leaves first):
1. `src/logic/processors/matching/extractBorough.js` - NEW FILE (leaf, no dependents)
2. `src/logic/rules/matching/isVerifiedHost.js` - Extract verification fields helper (leaf)
3. `src/logic/calculators/matching/constants.js` - Add threshold score mapping (critical dependency)
4. `src/logic/calculators/matching/calculatePriceScore.js` - Use threshold constants (depends on #3)
5. `src/logic/calculators/matching/calculateBoroughScore.js` - Use extractBorough (depends on #1)
6. `src/logic/calculators/matching/calculateMatchHeuristics.js` - Use extractBorough (depends on #1)
7. `src/logic/processors/matching/formatMatchResult.js` - Use threshold constants (depends on #3)

---

## File Changes

### 1. `src/logic/processors/matching/extractBorough.js` (NEW FILE)

**Reason:** Borough extraction logic is duplicated in 3+ files with identical patterns for handling multiple field name formats
**Dependents:** None (new leaf file)
**Risk:** LOW

#### Current Code
```javascript
// No current file - this is a new extraction
```

#### Refactored Code
```javascript
/**
 * Extract and normalize borough name from listing or proposal objects.
 *
 * @intent Centralize borough field extraction to handle multiple API formats.
 * @rule Checks boroughName, borough, and 'Location - Borough' field names.
 * @rule Returns normalized lowercase, trimmed string or null.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.source - Object containing borough data (listing, proposal.listing, etc).
 * @returns {string|null} Normalized borough name or null if not found.
 *
 * @example
 * extractBorough({ source: { boroughName: 'Manhattan' } })
 * // => 'manhattan'
 *
 * extractBorough({ source: { 'Location - Borough': 'Brooklyn' } })
 * // => 'brooklyn'
 *
 * extractBorough({ source: null })
 * // => null
 */
export function extractBorough({ source }) {
  if (!source || typeof source !== 'object') {
    return null;
  }

  const rawBorough =
    source.boroughName ||
    source.borough ||
    source['Location - Borough'] ||
    null;

  if (!rawBorough || typeof rawBorough !== 'string') {
    return null;
  }

  return rawBorough.toLowerCase().trim();
}

/**
 * Extract borough from a candidate listing.
 *
 * @param {object} candidateListing - Candidate listing object.
 * @returns {string|null} Normalized borough name or null.
 */
export function extractCandidateBorough(candidateListing) {
  return extractBorough({ source: candidateListing });
}

/**
 * Extract borough from a proposal's nested listing.
 *
 * @param {object} proposal - Proposal object with nested listing.
 * @returns {string|null} Normalized borough name or null.
 */
export function extractProposalBorough(proposal) {
  return extractBorough({ source: proposal?.listing });
}
```

#### Changes Made
- Created new processor file for borough extraction
- Added three exported functions: generic `extractBorough`, plus specialized `extractCandidateBorough` and `extractProposalBorough`
- Handles all known field name variations in one place
- Returns normalized (lowercase, trimmed) values

---

### 2. `src/logic/rules/matching/isVerifiedHost.js`

**Reason:** Verification field extraction is duplicated between `isVerifiedHost` and `countHostVerifications` functions
**Dependents:** `calculateHostScore.js`
**Risk:** LOW

#### Current Code
```javascript
/**
 * Check if host has sufficient verification status.
 *
 * @intent Determine host trustworthiness based on verification fields.
 * @rule Counts LinkedIn, Phone, and user verified fields.
 * @rule Host is "verified" if they have >= minimum verifications (default 2).
 * @rule Used as proxy for host responsiveness (no response rate data available).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @param {number} [params.minVerifications=2] - Minimum verifications required.
 * @returns {boolean} True if host meets verification threshold.
 *
 * @example
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => true (2 verifications meet default minimum of 2)
 *
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': false,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => false (only 1 verification)
 */
import { MIN_HOST_VERIFICATIONS } from '../../calculators/matching/constants.js';

export function isVerifiedHost({ host, minVerifications = MIN_HOST_VERIFICATIONS }) {
  if (!host) {
    return false;
  }

  // Count verification fields
  const verifications = [
    host['Verify - Linked In ID'] || host.linkedInVerified || false,
    host['Verify - Phone'] || host.phoneVerified || false,
    host['user verified?'] || host.userVerified || false
  ];

  const verificationCount = verifications.filter(Boolean).length;

  return verificationCount >= minVerifications;
}

/**
 * Count the number of verifications a host has.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @returns {number} Count of verifications (0-3).
 *
 * @example
 * countHostVerifications({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 3
 */
export function countHostVerifications({ host }) {
  if (!host) {
    return 0;
  }

  const verifications = [
    host['Verify - Linked In ID'] || host.linkedInVerified || false,
    host['Verify - Phone'] || host.phoneVerified || false,
    host['user verified?'] || host.userVerified || false
  ];

  return verifications.filter(Boolean).length;
}
```

#### Refactored Code
```javascript
/**
 * Check if host has sufficient verification status.
 *
 * @intent Determine host trustworthiness based on verification fields.
 * @rule Counts LinkedIn, Phone, and user verified fields.
 * @rule Host is "verified" if they have >= minimum verifications (default 2).
 * @rule Used as proxy for host responsiveness (no response rate data available).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @param {number} [params.minVerifications=2] - Minimum verifications required.
 * @returns {boolean} True if host meets verification threshold.
 *
 * @example
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => true (2 verifications meet default minimum of 2)
 *
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': false,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => false (only 1 verification)
 */
import { MIN_HOST_VERIFICATIONS } from '../../calculators/matching/constants.js';

/**
 * Extract verification statuses from host object.
 * Handles both Bubble field names and camelCase aliases.
 *
 * @param {object} host - Host/user object with verification fields.
 * @returns {boolean[]} Array of verification statuses [linkedIn, phone, user].
 */
function getHostVerificationStatuses(host) {
  if (!host) {
    return [false, false, false];
  }

  return [
    Boolean(host['Verify - Linked In ID'] || host.linkedInVerified),
    Boolean(host['Verify - Phone'] || host.phoneVerified),
    Boolean(host['user verified?'] || host.userVerified)
  ];
}

export function isVerifiedHost({ host, minVerifications = MIN_HOST_VERIFICATIONS }) {
  const verificationCount = countHostVerifications({ host });
  return verificationCount >= minVerifications;
}

/**
 * Count the number of verifications a host has.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @returns {number} Count of verifications (0-3).
 *
 * @example
 * countHostVerifications({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 3
 */
export function countHostVerifications({ host }) {
  const statuses = getHostVerificationStatuses(host);
  return statuses.filter(Boolean).length;
}
```

#### Changes Made
- Extracted `getHostVerificationStatuses()` private helper to eliminate duplication
- `isVerifiedHost()` now delegates to `countHostVerifications()` instead of duplicating logic
- Used `Boolean()` for explicit type coercion (clearer intent than `|| false`)
- Reduced code duplication from 12 lines to 4 lines

---

### 3. `src/logic/calculators/matching/constants.js`

**Reason:** Price score thresholds are hardcoded in multiple files; need centralized mapping
**Dependents:** All matching calculators and processors (HIGH IMPACT - but adding, not modifying)
**Risk:** LOW (additive change only)

#### Current Code
```javascript
/**
 * Quick Match Scoring Constants
 *
 * Defines weights, thresholds, and reference data for the matching algorithm.
 * Maximum possible score is 95 (price drop heuristic not implemented due to missing data).
 *
 * @module logic/calculators/matching/constants
 */

/**
 * Score weights for each matching criterion.
 * Total: 95 points (5 points unavailable due to missing price history data)
 */
export const MATCH_WEIGHTS = {
  BOROUGH: 25,        // Location proximity
  PRICE: 20,          // Price similarity
  SCHEDULE: 20,       // Schedule day overlap
  WEEKLY_STAY: 15,    // Support for 7-night stays
  DURATION: 10,       // Minimum nights compatibility
  HOST: 5             // Host verification proxy
  // PRICE_DROP: 5    // Not implemented (no price history tracking)
};

/**
 * NYC borough adjacency map for location scoring.
 * Adjacent boroughs receive partial score (15 points vs 25 for exact match).
 */
export const NYC_BOROUGH_ADJACENCY = {
  manhattan: ['brooklyn', 'queens', 'bronx'],
  brooklyn: ['manhattan', 'queens', 'staten island'],
  queens: ['manhattan', 'brooklyn', 'bronx'],
  bronx: ['manhattan', 'queens'],
  'staten island': ['brooklyn']
};

/**
 * Score tiers for categorizing match quality.
 * Used by formatMatchResult to assign tier labels.
 */
export const SCORE_TIERS = {
  EXCELLENT: 75,  // 75+ = excellent match
  GOOD: 50,       // 50-74 = good match
  FAIR: 25        // 25-49 = fair match, below = poor match
};

/**
 * Price proximity thresholds for scoring.
 * Each threshold maps to a score value.
 */
export const PRICE_THRESHOLDS = {
  WITHIN_10_PERCENT: 0.10,  // 20 points
  WITHIN_20_PERCENT: 0.20,  // 15 points
  WITHIN_30_PERCENT: 0.30,  // 10 points
  WITHIN_50_PERCENT: 0.50   // 5 points
};

/**
 * Minimum verification count for host to be considered "verified".
 */
export const MIN_HOST_VERIFICATIONS = 2;

/**
 * Maximum possible score with current data availability.
 */
export const MAX_POSSIBLE_SCORE = 95;

/**
 * Tier labels for display.
 */
export const TIER_LABELS = {
  EXCELLENT: 'excellent',
  GOOD: 'good',
  FAIR: 'fair',
  POOR: 'poor'
};
```

#### Refactored Code
```javascript
/**
 * Quick Match Scoring Constants
 *
 * Defines weights, thresholds, and reference data for the matching algorithm.
 * Maximum possible score is 95 (price drop heuristic not implemented due to missing data).
 *
 * @module logic/calculators/matching/constants
 */

/**
 * Score weights for each matching criterion.
 * Total: 95 points (5 points unavailable due to missing price history data)
 */
export const MATCH_WEIGHTS = {
  BOROUGH: 25,        // Location proximity
  PRICE: 20,          // Price similarity
  SCHEDULE: 20,       // Schedule day overlap
  WEEKLY_STAY: 15,    // Support for 7-night stays
  DURATION: 10,       // Minimum nights compatibility
  HOST: 5             // Host verification proxy
  // PRICE_DROP: 5    // Not implemented (no price history tracking)
};

/**
 * Partial score for adjacent borough match.
 * Used when candidate is in a neighboring borough to the proposal.
 */
export const ADJACENT_BOROUGH_SCORE = 15;

/**
 * NYC borough adjacency map for location scoring.
 * Adjacent boroughs receive partial score (15 points vs 25 for exact match).
 */
export const NYC_BOROUGH_ADJACENCY = {
  manhattan: ['brooklyn', 'queens', 'bronx'],
  brooklyn: ['manhattan', 'queens', 'staten island'],
  queens: ['manhattan', 'brooklyn', 'bronx'],
  bronx: ['manhattan', 'queens'],
  'staten island': ['brooklyn']
};

/**
 * Score tiers for categorizing match quality.
 * Used by formatMatchResult to assign tier labels.
 */
export const SCORE_TIERS = {
  EXCELLENT: 75,  // 75+ = excellent match
  GOOD: 50,       // 50-74 = good match
  FAIR: 25        // 25-49 = fair match, below = poor match
};

/**
 * Price proximity thresholds for scoring.
 * Each threshold maps to a score value.
 */
export const PRICE_THRESHOLDS = {
  WITHIN_10_PERCENT: 0.10,  // 20 points
  WITHIN_20_PERCENT: 0.20,  // 15 points
  WITHIN_30_PERCENT: 0.30,  // 10 points
  WITHIN_50_PERCENT: 0.50   // 5 points
};

/**
 * Maps price proximity thresholds to their corresponding scores.
 * Ordered from tightest threshold to loosest for sequential checking.
 *
 * @example
 * // Find score for a proximity value
 * const score = PRICE_THRESHOLD_SCORES.find(t => proximity <= t.threshold)?.score ?? 0;
 */
export const PRICE_THRESHOLD_SCORES = [
  { threshold: PRICE_THRESHOLDS.WITHIN_10_PERCENT, score: MATCH_WEIGHTS.PRICE },  // 20 points
  { threshold: PRICE_THRESHOLDS.WITHIN_20_PERCENT, score: 15 },
  { threshold: PRICE_THRESHOLDS.WITHIN_30_PERCENT, score: 10 },
  { threshold: PRICE_THRESHOLDS.WITHIN_50_PERCENT, score: 5 }
];

/**
 * Calculate price score from proximity ratio.
 * Pure function that encapsulates threshold-to-score mapping.
 *
 * @param {number} proximity - Price difference as decimal (e.g., 0.15 = 15%)
 * @returns {number} Score from 0-20
 */
export function getPriceScoreFromProximity(proximity) {
  if (typeof proximity !== 'number' || isNaN(proximity) || proximity < 0) {
    return 0;
  }

  const match = PRICE_THRESHOLD_SCORES.find(tier => proximity <= tier.threshold);
  return match?.score ?? 0;
}

/**
 * Minimum verification count for host to be considered "verified".
 */
export const MIN_HOST_VERIFICATIONS = 2;

/**
 * Maximum possible score with current data availability.
 */
export const MAX_POSSIBLE_SCORE = 95;

/**
 * Tier labels for display.
 */
export const TIER_LABELS = {
  EXCELLENT: 'excellent',
  GOOD: 'good',
  FAIR: 'fair',
  POOR: 'poor'
};
```

#### Changes Made
- Added `ADJACENT_BOROUGH_SCORE` constant (was magic number 15 in calculateBoroughScore)
- Added `PRICE_THRESHOLD_SCORES` array mapping thresholds to scores
- Added `getPriceScoreFromProximity()` pure function to centralize threshold checking logic
- Preserves backward compatibility (existing exports unchanged)

---

### 4. `src/logic/calculators/matching/calculatePriceScore.js`

**Reason:** Replace magic number threshold scores with centralized function from constants
**Dependents:** `calculateMatchScore.js`
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate price proximity score for a candidate listing.
 *
 * @intent Score how close candidate pricing is to proposal budget.
 * @rule Within 10% = 20 points (full score).
 * @rule Within 20% = 15 points.
 * @rule Within 30% = 10 points.
 * @rule Within 50% = 5 points.
 * @rule Over 50% = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object with pricing fields.
 * @param {object} params.proposal - Proposal object with nightly price and nights per week.
 * @returns {number} Score from 0-20.
 *
 * @example
 * calculatePriceScore({
 *   candidateListing: { 'ðŸ’°Nightly Host Rate for 4 nights': 105 },
 *   proposal: { nightlyPrice: 100, nightsPerWeek: 4 }
 * })
 * // => 20 (5% difference, within 10%)
 */
import { getNightlyRateByFrequency } from '../pricing/getNightlyRateByFrequency.js';
import { calculatePriceProximity } from './calculatePriceProximity.js';
import { MATCH_WEIGHTS, PRICE_THRESHOLDS } from './constants.js';

export function calculatePriceScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Determine nights per week from proposal
  const nightsPerWeek =
    proposal.nightsPerWeek ||
    proposal.daysSelected?.length ||
    4; // Default to 4 if not specified

  // Get proposal nightly price
  const proposalNightlyRate = proposal.nightlyPrice;

  if (!proposalNightlyRate || proposalNightlyRate <= 0) {
    return 0;
  }

  // Get candidate nightly rate for same frequency
  let candidateNightlyRate;
  try {
    candidateNightlyRate = getNightlyRateByFrequency({
      listing: candidateListing,
      nightsSelected: nightsPerWeek
    });
  } catch {
    // If we can't get a rate for this frequency, return 0
    return 0;
  }

  if (!candidateNightlyRate || candidateNightlyRate <= 0) {
    return 0;
  }

  // Calculate proximity ratio
  let proximity;
  try {
    proximity = calculatePriceProximity({
      candidateNightlyRate,
      proposalNightlyRate
    });
  } catch {
    return 0;
  }

  // Score based on proximity thresholds
  if (proximity <= PRICE_THRESHOLDS.WITHIN_10_PERCENT) {
    return MATCH_WEIGHTS.PRICE; // 20 points
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_20_PERCENT) {
    return 15;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_30_PERCENT) {
    return 10;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_50_PERCENT) {
    return 5;
  }

  return 0;
}
```

#### Refactored Code
```javascript
/**
 * Calculate price proximity score for a candidate listing.
 *
 * @intent Score how close candidate pricing is to proposal budget.
 * @rule Within 10% = 20 points (full score).
 * @rule Within 20% = 15 points.
 * @rule Within 30% = 10 points.
 * @rule Within 50% = 5 points.
 * @rule Over 50% = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object with pricing fields.
 * @param {object} params.proposal - Proposal object with nightly price and nights per week.
 * @returns {number} Score from 0-20.
 *
 * @example
 * calculatePriceScore({
 *   candidateListing: { 'ðŸ’°Nightly Host Rate for 4 nights': 105 },
 *   proposal: { nightlyPrice: 100, nightsPerWeek: 4 }
 * })
 * // => 20 (5% difference, within 10%)
 */
import { getNightlyRateByFrequency } from '../pricing/getNightlyRateByFrequency.js';
import { calculatePriceProximity } from './calculatePriceProximity.js';
import { getPriceScoreFromProximity } from './constants.js';

/**
 * Extract nights per week from proposal, with fallback to default.
 *
 * @param {object} proposal - Proposal object
 * @returns {number} Nights per week (2-7)
 */
function getNightsPerWeek(proposal) {
  return proposal.nightsPerWeek || proposal.daysSelected?.length || 4;
}

/**
 * Safely get candidate nightly rate, returning null on failure.
 *
 * @param {object} listing - Candidate listing
 * @param {number} nightsPerWeek - Number of nights
 * @returns {number|null} Nightly rate or null if unavailable
 */
function getCandidateRate(listing, nightsPerWeek) {
  try {
    const rate = getNightlyRateByFrequency({
      listing,
      nightsSelected: nightsPerWeek
    });
    return rate > 0 ? rate : null;
  } catch {
    return null;
  }
}

/**
 * Safely calculate price proximity, returning null on failure.
 *
 * @param {number} candidateRate - Candidate nightly rate
 * @param {number} proposalRate - Proposal nightly rate
 * @returns {number|null} Proximity ratio or null if calculation fails
 */
function getProximity(candidateRate, proposalRate) {
  try {
    return calculatePriceProximity({
      candidateNightlyRate: candidateRate,
      proposalNightlyRate: proposalRate
    });
  } catch {
    return null;
  }
}

export function calculatePriceScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  const proposalNightlyRate = proposal.nightlyPrice;
  if (!proposalNightlyRate || proposalNightlyRate <= 0) {
    return 0;
  }

  const nightsPerWeek = getNightsPerWeek(proposal);
  const candidateNightlyRate = getCandidateRate(candidateListing, nightsPerWeek);
  if (!candidateNightlyRate) {
    return 0;
  }

  const proximity = getProximity(candidateNightlyRate, proposalNightlyRate);
  if (proximity === null) {
    return 0;
  }

  return getPriceScoreFromProximity(proximity);
}
```

#### Changes Made
- Replaced manual threshold checking (4 if statements) with `getPriceScoreFromProximity()` from constants
- Extracted helper functions: `getNightsPerWeek()`, `getCandidateRate()`, `getProximity()`
- Each helper has a single responsibility and clear return type
- Reduced main function complexity while improving readability
- Eliminated magic numbers (15, 10, 5)

---

### 5. `src/logic/calculators/matching/calculateBoroughScore.js`

**Reason:** Use centralized borough extraction and adjacent borough score constant
**Dependents:** `calculateMatchScore.js`
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate borough match score for a candidate listing.
 *
 * @intent Score geographic proximity between candidate and proposal listings.
 * @rule Same borough = 25 points (full match).
 * @rule Adjacent borough = 15 points (partial match).
 * @rule Different/non-adjacent = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object.
 * @param {object} params.proposal - Proposal object with nested listing data.
 * @returns {number} Score from 0-25.
 *
 * @example
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Manhattan' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 25 (exact match)
 *
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Brooklyn' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 15 (adjacent)
 */
import { isBoroughAdjacent } from '../../rules/matching/isBoroughAdjacent.js';
import { MATCH_WEIGHTS } from './constants.js';

export function calculateBoroughScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Extract borough names from both objects, checking multiple possible field names
  const candidateBorough =
    candidateListing.boroughName ||
    candidateListing['Location - Borough'] ||
    null;

  const proposalBorough =
    proposal.listing?.boroughName ||
    proposal.listing?.borough ||
    proposal.listing?.['Location - Borough'] ||
    null;

  if (!candidateBorough || !proposalBorough) {
    return 0;
  }

  const normalizedCandidate = candidateBorough.toLowerCase().trim();
  const normalizedProposal = proposalBorough.toLowerCase().trim();

  // Exact match = full points
  if (normalizedCandidate === normalizedProposal) {
    return MATCH_WEIGHTS.BOROUGH;
  }

  // Adjacent match = partial points (60% of full)
  if (isBoroughAdjacent({ borough1: normalizedProposal, borough2: normalizedCandidate })) {
    return 15;
  }

  // No match
  return 0;
}
```

#### Refactored Code
```javascript
/**
 * Calculate borough match score for a candidate listing.
 *
 * @intent Score geographic proximity between candidate and proposal listings.
 * @rule Same borough = 25 points (full match).
 * @rule Adjacent borough = 15 points (partial match).
 * @rule Different/non-adjacent = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object.
 * @param {object} params.proposal - Proposal object with nested listing data.
 * @returns {number} Score from 0-25.
 *
 * @example
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Manhattan' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 25 (exact match)
 *
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Brooklyn' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 15 (adjacent)
 */
import { isBoroughAdjacent } from '../../rules/matching/isBoroughAdjacent.js';
import { MATCH_WEIGHTS, ADJACENT_BOROUGH_SCORE } from './constants.js';
import { extractCandidateBorough, extractProposalBorough } from '../../processors/matching/extractBorough.js';

export function calculateBoroughScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  const normalizedCandidate = extractCandidateBorough(candidateListing);
  const normalizedProposal = extractProposalBorough(proposal);

  if (!normalizedCandidate || !normalizedProposal) {
    return 0;
  }

  // Exact match = full points
  if (normalizedCandidate === normalizedProposal) {
    return MATCH_WEIGHTS.BOROUGH;
  }

  // Adjacent match = partial points
  if (isBoroughAdjacent({ borough1: normalizedProposal, borough2: normalizedCandidate })) {
    return ADJACENT_BOROUGH_SCORE;
  }

  // No match
  return 0;
}
```

#### Changes Made
- Replaced inline borough extraction (10 lines) with `extractCandidateBorough()` and `extractProposalBorough()`
- Replaced magic number 15 with `ADJACENT_BOROUGH_SCORE` constant
- Code reduced from 36 lines of logic to 18 lines
- Borough extraction logic now centralized and reusable

---

### 6. `src/logic/calculators/matching/calculateMatchHeuristics.js`

**Reason:** Use centralized borough extraction to reduce duplication
**Dependents:** `calculateMatchScore.js` (via index)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate detailed heuristics for a match (boolean flags).
 *
 * @intent Provide granular boolean indicators for each matching criterion.
 * @rule Returns true/false for each heuristic for UI display or filtering.
 * @rule Useful for displaying match reasoning to users.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing with all fields.
 * @param {object} params.proposal - Proposal object with nested listing/host data.
 * @param {object} params.hostData - Host/user data for candidate listing.
 * @returns {object} Boolean flags for each heuristic.
 *
 * @example
 * calculateMatchHeuristics({
 *   candidateListing: { boroughName: 'Manhattan', ... },
 *   proposal: { ... },
 *   hostData: { ... }
 * })
 * // => {
 * //   boroughMatch: true,
 * //   boroughAdjacent: false,
 * //   priceWithin10Percent: true,
 * //   priceWithin20Percent: true,
 * //   priceWithin30Percent: true,
 * //   hasScheduleOverlap: true,
 * //   hasFullScheduleOverlap: true,
 * //   supportsWeeklyStays: true,
 * //   durationMatch: true,
 * //   hostVerified: true,
 * //   priceDrop: false
 * // }
 */
import { isBoroughMatch } from '../../rules/matching/isBoroughMatch.js';
import { isBoroughAdjacent } from '../../rules/matching/isBoroughAdjacent.js';
import { hasScheduleCompatibility } from '../../rules/matching/hasScheduleCompatibility.js';
import { supportsWeeklyStays } from '../../rules/matching/supportsWeeklyStays.js';
import { isDurationMatch } from '../../rules/matching/isDurationMatch.js';
import { isVerifiedHost } from '../../rules/matching/isVerifiedHost.js';
import { calculatePriceProximity } from './calculatePriceProximity.js';
import { getNightlyRateByFrequency } from '../pricing/getNightlyRateByFrequency.js';
import { PRICE_THRESHOLDS } from './constants.js';

export function calculateMatchHeuristics({ candidateListing, proposal, hostData }) {
  // Extract boroughs
  const candidateBorough =
    candidateListing?.boroughName ||
    candidateListing?.['Location - Borough'] ||
    null;

  const proposalBorough =
    proposal?.listing?.boroughName ||
    proposal?.listing?.borough ||
    proposal?.listing?.['Location - Borough'] ||
    null;

  // Calculate price proximity
  let proximity = null;
  try {
    const nightsPerWeek =
      proposal?.nightsPerWeek ||
      proposal?.daysSelected?.length ||
      4;

    const proposalNightlyRate = proposal?.nightlyPrice;
    const candidateNightlyRate = getNightlyRateByFrequency({
      listing: candidateListing,
      nightsSelected: nightsPerWeek
    });

    if (proposalNightlyRate && candidateNightlyRate) {
      proximity = calculatePriceProximity({
        candidateNightlyRate,
        proposalNightlyRate
      });
    }
  } catch {
    // Price proximity calculation failed, leave as null
  }

  // Calculate schedule compatibility
  const scheduleResult = hasScheduleCompatibility({ candidateListing, proposal });

  // Borough checks
  const isExactBoroughMatch =
    candidateBorough &&
    proposalBorough &&
    candidateBorough.toLowerCase().trim() === proposalBorough.toLowerCase().trim();

  const isAdjacentBorough = isBoroughAdjacent({
    borough1: proposalBorough,
    borough2: candidateBorough
  });

  return {
    // Borough heuristics
    boroughMatch: isBoroughMatch({ candidateBorough, proposalBorough }),
    boroughExact: isExactBoroughMatch,
    boroughAdjacent: isAdjacentBorough,

    // Price heuristics
    priceWithin10Percent: proximity !== null && proximity <= PRICE_THRESHOLDS.WITHIN_10_PERCENT,
    priceWithin20Percent: proximity !== null && proximity <= PRICE_THRESHOLDS.WITHIN_20_PERCENT,
    priceWithin30Percent: proximity !== null && proximity <= PRICE_THRESHOLDS.WITHIN_30_PERCENT,
    priceWithin50Percent: proximity !== null && proximity <= PRICE_THRESHOLDS.WITHIN_50_PERCENT,

    // Schedule heuristics
    hasScheduleOverlap: scheduleResult.compatible,
    hasFullScheduleOverlap:
      scheduleResult.compatible &&
      scheduleResult.overlapDays === scheduleResult.requestedDays,
    scheduleOverlapPercent:
      scheduleResult.requestedDays > 0
        ? Math.round((scheduleResult.overlapDays / scheduleResult.requestedDays) * 100)
        : 0,

    // Weekly stay heuristic
    supportsWeeklyStays: supportsWeeklyStays({ listing: candidateListing }),

    // Duration heuristic
    durationMatch: isDurationMatch({ listing: candidateListing, proposal }),

    // Host heuristic
    hostVerified: isVerifiedHost({ host: hostData }),

    // Price drop (not implemented)
    priceDrop: false
  };
}
```

#### Refactored Code
```javascript
/**
 * Calculate detailed heuristics for a match (boolean flags).
 *
 * @intent Provide granular boolean indicators for each matching criterion.
 * @rule Returns true/false for each heuristic for UI display or filtering.
 * @rule Useful for displaying match reasoning to users.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing with all fields.
 * @param {object} params.proposal - Proposal object with nested listing/host data.
 * @param {object} params.hostData - Host/user data for candidate listing.
 * @returns {object} Boolean flags for each heuristic.
 *
 * @example
 * calculateMatchHeuristics({
 *   candidateListing: { boroughName: 'Manhattan', ... },
 *   proposal: { ... },
 *   hostData: { ... }
 * })
 * // => {
 * //   boroughMatch: true,
 * //   boroughAdjacent: false,
 * //   priceWithin10Percent: true,
 * //   priceWithin20Percent: true,
 * //   priceWithin30Percent: true,
 * //   hasScheduleOverlap: true,
 * //   hasFullScheduleOverlap: true,
 * //   supportsWeeklyStays: true,
 * //   durationMatch: true,
 * //   hostVerified: true,
 * //   priceDrop: false
 * // }
 */
import { isBoroughMatch } from '../../rules/matching/isBoroughMatch.js';
import { isBoroughAdjacent } from '../../rules/matching/isBoroughAdjacent.js';
import { hasScheduleCompatibility } from '../../rules/matching/hasScheduleCompatibility.js';
import { supportsWeeklyStays } from '../../rules/matching/supportsWeeklyStays.js';
import { isDurationMatch } from '../../rules/matching/isDurationMatch.js';
import { isVerifiedHost } from '../../rules/matching/isVerifiedHost.js';
import { calculatePriceProximity } from './calculatePriceProximity.js';
import { getNightlyRateByFrequency } from '../pricing/getNightlyRateByFrequency.js';
import { PRICE_THRESHOLDS } from './constants.js';
import { extractCandidateBorough, extractProposalBorough } from '../../processors/matching/extractBorough.js';

/**
 * Calculate price proximity with error handling.
 * Returns null if calculation cannot be performed.
 */
function calculateSafePriceProximity(candidateListing, proposal) {
  try {
    const nightsPerWeek = proposal?.nightsPerWeek || proposal?.daysSelected?.length || 4;
    const proposalNightlyRate = proposal?.nightlyPrice;
    const candidateNightlyRate = getNightlyRateByFrequency({
      listing: candidateListing,
      nightsSelected: nightsPerWeek
    });

    if (!proposalNightlyRate || !candidateNightlyRate) {
      return null;
    }

    return calculatePriceProximity({
      candidateNightlyRate,
      proposalNightlyRate
    });
  } catch {
    return null;
  }
}

/**
 * Calculate schedule overlap percentage.
 */
function calculateOverlapPercent(scheduleResult) {
  if (scheduleResult.requestedDays === 0) {
    return 0;
  }
  return Math.round((scheduleResult.overlapDays / scheduleResult.requestedDays) * 100);
}

export function calculateMatchHeuristics({ candidateListing, proposal, hostData }) {
  // Extract normalized boroughs using centralized processor
  const candidateBorough = extractCandidateBorough(candidateListing);
  const proposalBorough = extractProposalBorough(proposal);

  // Calculate derived values
  const proximity = calculateSafePriceProximity(candidateListing, proposal);
  const scheduleResult = hasScheduleCompatibility({ candidateListing, proposal });

  // Borough checks (using normalized values)
  const isExactBoroughMatch = candidateBorough && proposalBorough && candidateBorough === proposalBorough;
  const isAdjacentBorough = isBoroughAdjacent({
    borough1: proposalBorough,
    borough2: candidateBorough
  });

  return {
    // Borough heuristics
    boroughMatch: isBoroughMatch({ candidateBorough, proposalBorough }),
    boroughExact: isExactBoroughMatch,
    boroughAdjacent: isAdjacentBorough,

    // Price heuristics
    priceWithin10Percent: proximity !== null && proximity <= PRICE_THRESHOLDS.WITHIN_10_PERCENT,
    priceWithin20Percent: proximity !== null && proximity <= PRICE_THRESHOLDS.WITHIN_20_PERCENT,
    priceWithin30Percent: proximity !== null && proximity <= PRICE_THRESHOLDS.WITHIN_30_PERCENT,
    priceWithin50Percent: proximity !== null && proximity <= PRICE_THRESHOLDS.WITHIN_50_PERCENT,

    // Schedule heuristics
    hasScheduleOverlap: scheduleResult.compatible,
    hasFullScheduleOverlap: scheduleResult.compatible && scheduleResult.overlapDays === scheduleResult.requestedDays,
    scheduleOverlapPercent: calculateOverlapPercent(scheduleResult),

    // Weekly stay heuristic
    supportsWeeklyStays: supportsWeeklyStays({ listing: candidateListing }),

    // Duration heuristic
    durationMatch: isDurationMatch({ listing: candidateListing, proposal }),

    // Host heuristic
    hostVerified: isVerifiedHost({ host: hostData }),

    // Price drop (not implemented)
    priceDrop: false
  };
}
```

#### Changes Made
- Replaced inline borough extraction (10 lines) with `extractCandidateBorough()` and `extractProposalBorough()`
- Extracted `calculateSafePriceProximity()` helper for cleaner error handling
- Extracted `calculateOverlapPercent()` helper for readability
- Simplified exact match check (boroughs already normalized by extractors)
- Code reduced from 90 lines to 75 lines with improved clarity

---

### 7. `src/logic/processors/matching/formatMatchResult.js`

**Reason:** Use centralized price threshold scoring for description logic
**Dependents:** External callers (UI components)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Format match result with score breakdown for UI display.
 *
 * @intent Transform raw match scores into user-friendly display format.
 * @rule Includes score breakdown with labels and max values.
 * @rule Assigns tier label based on total score.
 * @rule Provides percentage for visual progress indicators.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.listing - The candidate listing (adapted).
 * @param {object} params.scores - Score object from calculateMatchScore.
 * @returns {object} Formatted match result for UI.
 *
 * @example
 * formatMatchResult({
 *   listing: { id: 'abc123', name: 'Nice Apartment', boroughName: 'Manhattan' },
 *   scores: {
 *     totalScore: 85,
 *     breakdown: {
 *       boroughMatch: 25,
 *       priceProximity: 20,
 *       scheduleOverlap: 20,
 *       weeklyStaySupport: 15,
 *       durationMatch: 10,
 *       hostVerified: 5,
 *       priceDrop: 0
 *     },
 *     maxPossibleScore: 95
 *   }
 * })
 * // => {
 * //   listing: { ... },
 * //   totalScore: 85,
 * //   scorePercent: 89,
 * //   tier: 'excellent',
 * //   breakdown: { ... with labels and max values }
 * // }
 */
import { SCORE_TIERS, TIER_LABELS, MATCH_WEIGHTS, MAX_POSSIBLE_SCORE } from '../../calculators/matching/constants.js';

/**
 * Get tier label based on total score.
 *
 * @param {number} score - Total match score.
 * @returns {string} Tier label (excellent, good, fair, poor).
 */
export function getTier(score) {
  if (score >= SCORE_TIERS.EXCELLENT) {
    return TIER_LABELS.EXCELLENT;
  }
  if (score >= SCORE_TIERS.GOOD) {
    return TIER_LABELS.GOOD;
  }
  if (score >= SCORE_TIERS.FAIR) {
    return TIER_LABELS.FAIR;
  }
  return TIER_LABELS.POOR;
}

/**
 * Format match result for UI display.
 */
export function formatMatchResult({ listing, scores }) {
  if (!listing) {
    throw new Error('formatMatchResult: listing is required');
  }

  if (!scores) {
    throw new Error('formatMatchResult: scores is required');
  }

  const { totalScore, breakdown, maxPossibleScore } = scores;

  // Calculate percentage
  const maxScore = maxPossibleScore || MAX_POSSIBLE_SCORE;
  const scorePercent = Math.round((totalScore / maxScore) * 100);

  // Assign tier
  const tier = getTier(totalScore);

  // Format breakdown with labels and max values
  const formattedBreakdown = {
    borough: {
      score: breakdown.boroughMatch,
      max: MATCH_WEIGHTS.BOROUGH,
      label: 'Location Match',
      description: breakdown.boroughMatch === MATCH_WEIGHTS.BOROUGH
        ? 'Same borough'
        : breakdown.boroughMatch > 0
          ? 'Adjacent borough'
          : 'Different area'
    },
    price: {
      score: breakdown.priceProximity,
      max: MATCH_WEIGHTS.PRICE,
      label: 'Price Match',
      description: breakdown.priceProximity === MATCH_WEIGHTS.PRICE
        ? 'Within 10% of budget'
        : breakdown.priceProximity >= 15
          ? 'Within 20% of budget'
          : breakdown.priceProximity >= 10
            ? 'Within 30% of budget'
            : breakdown.priceProximity > 0
              ? 'Within 50% of budget'
              : 'Over budget'
    },
    schedule: {
      score: breakdown.scheduleOverlap,
      max: MATCH_WEIGHTS.SCHEDULE,
      label: 'Schedule Compatibility',
      description: breakdown.scheduleOverlap === MATCH_WEIGHTS.SCHEDULE
        ? 'Full schedule match'
        : breakdown.scheduleOverlap > 0
          ? `${Math.round((breakdown.scheduleOverlap / MATCH_WEIGHTS.SCHEDULE) * 100)}% day overlap`
          : 'No schedule overlap'
    },
    weeklyStay: {
      score: breakdown.weeklyStaySupport,
      max: MATCH_WEIGHTS.WEEKLY_STAY,
      label: 'Weekly Stays',
      description: breakdown.weeklyStaySupport > 0
        ? 'Supports weekly stays'
        : 'Limited availability'
    },
    duration: {
      score: breakdown.durationMatch,
      max: MATCH_WEIGHTS.DURATION,
      label: 'Duration Match',
      description: breakdown.durationMatch > 0
        ? 'Matches stay length'
        : 'Different min nights'
    },
    host: {
      score: breakdown.hostVerified,
      max: MATCH_WEIGHTS.HOST,
      label: 'Host Trust',
      description: breakdown.hostVerified >= 5
        ? 'Fully verified host'
        : breakdown.hostVerified >= 3
          ? 'Verified host'
          : breakdown.hostVerified > 0
            ? 'Partially verified'
            : 'New host'
    }
  };

  return {
    listing,
    totalScore,
    scorePercent,
    tier,
    tierDisplay: tier.charAt(0).toUpperCase() + tier.slice(1),
    breakdown: formattedBreakdown,
    maxPossibleScore: maxScore
  };
}
```

#### Refactored Code
```javascript
/**
 * Format match result with score breakdown for UI display.
 *
 * @intent Transform raw match scores into user-friendly display format.
 * @rule Includes score breakdown with labels and max values.
 * @rule Assigns tier label based on total score.
 * @rule Provides percentage for visual progress indicators.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.listing - The candidate listing (adapted).
 * @param {object} params.scores - Score object from calculateMatchScore.
 * @returns {object} Formatted match result for UI.
 *
 * @example
 * formatMatchResult({
 *   listing: { id: 'abc123', name: 'Nice Apartment', boroughName: 'Manhattan' },
 *   scores: {
 *     totalScore: 85,
 *     breakdown: {
 *       boroughMatch: 25,
 *       priceProximity: 20,
 *       scheduleOverlap: 20,
 *       weeklyStaySupport: 15,
 *       durationMatch: 10,
 *       hostVerified: 5,
 *       priceDrop: 0
 *     },
 *     maxPossibleScore: 95
 *   }
 * })
 * // => {
 * //   listing: { ... },
 * //   totalScore: 85,
 * //   scorePercent: 89,
 * //   tier: 'excellent',
 * //   breakdown: { ... with labels and max values }
 * // }
 */
import {
  SCORE_TIERS,
  TIER_LABELS,
  MATCH_WEIGHTS,
  MAX_POSSIBLE_SCORE,
  ADJACENT_BOROUGH_SCORE,
  PRICE_THRESHOLD_SCORES
} from '../../calculators/matching/constants.js';

/**
 * Get tier label based on total score.
 *
 * @param {number} score - Total match score.
 * @returns {string} Tier label (excellent, good, fair, poor).
 */
export function getTier(score) {
  if (score >= SCORE_TIERS.EXCELLENT) {
    return TIER_LABELS.EXCELLENT;
  }
  if (score >= SCORE_TIERS.GOOD) {
    return TIER_LABELS.GOOD;
  }
  if (score >= SCORE_TIERS.FAIR) {
    return TIER_LABELS.FAIR;
  }
  return TIER_LABELS.POOR;
}

/**
 * Get price description based on score.
 * Maps score back to threshold description.
 */
function getPriceDescription(priceScore) {
  if (priceScore === MATCH_WEIGHTS.PRICE) {
    return 'Within 10% of budget';
  }

  // Find matching threshold score and return corresponding description
  const thresholdIndex = PRICE_THRESHOLD_SCORES.findIndex(t => t.score === priceScore);
  const descriptions = [
    'Within 10% of budget',
    'Within 20% of budget',
    'Within 30% of budget',
    'Within 50% of budget'
  ];

  return thresholdIndex >= 0 && thresholdIndex < descriptions.length
    ? descriptions[thresholdIndex]
    : priceScore > 0 ? 'Partial budget match' : 'Over budget';
}

/**
 * Get borough description based on score.
 */
function getBoroughDescription(boroughScore) {
  if (boroughScore === MATCH_WEIGHTS.BOROUGH) {
    return 'Same borough';
  }
  if (boroughScore === ADJACENT_BOROUGH_SCORE) {
    return 'Adjacent borough';
  }
  return 'Different area';
}

/**
 * Get host trust description based on score.
 */
function getHostDescription(hostScore) {
  if (hostScore >= MATCH_WEIGHTS.HOST) {
    return 'Fully verified host';
  }
  if (hostScore >= 3) {
    return 'Verified host';
  }
  if (hostScore > 0) {
    return 'Partially verified';
  }
  return 'New host';
}

/**
 * Get schedule description based on score and max.
 */
function getScheduleDescription(scheduleScore) {
  if (scheduleScore === MATCH_WEIGHTS.SCHEDULE) {
    return 'Full schedule match';
  }
  if (scheduleScore > 0) {
    const overlapPercent = Math.round((scheduleScore / MATCH_WEIGHTS.SCHEDULE) * 100);
    return `${overlapPercent}% day overlap`;
  }
  return 'No schedule overlap';
}

/**
 * Format match result for UI display.
 */
export function formatMatchResult({ listing, scores }) {
  if (!listing) {
    throw new Error('formatMatchResult: listing is required');
  }

  if (!scores) {
    throw new Error('formatMatchResult: scores is required');
  }

  const { totalScore, breakdown, maxPossibleScore } = scores;

  // Calculate percentage
  const maxScore = maxPossibleScore || MAX_POSSIBLE_SCORE;
  const scorePercent = Math.round((totalScore / maxScore) * 100);

  // Assign tier
  const tier = getTier(totalScore);

  // Format breakdown with labels and max values
  const formattedBreakdown = {
    borough: {
      score: breakdown.boroughMatch,
      max: MATCH_WEIGHTS.BOROUGH,
      label: 'Location Match',
      description: getBoroughDescription(breakdown.boroughMatch)
    },
    price: {
      score: breakdown.priceProximity,
      max: MATCH_WEIGHTS.PRICE,
      label: 'Price Match',
      description: getPriceDescription(breakdown.priceProximity)
    },
    schedule: {
      score: breakdown.scheduleOverlap,
      max: MATCH_WEIGHTS.SCHEDULE,
      label: 'Schedule Compatibility',
      description: getScheduleDescription(breakdown.scheduleOverlap)
    },
    weeklyStay: {
      score: breakdown.weeklyStaySupport,
      max: MATCH_WEIGHTS.WEEKLY_STAY,
      label: 'Weekly Stays',
      description: breakdown.weeklyStaySupport > 0 ? 'Supports weekly stays' : 'Limited availability'
    },
    duration: {
      score: breakdown.durationMatch,
      max: MATCH_WEIGHTS.DURATION,
      label: 'Duration Match',
      description: breakdown.durationMatch > 0 ? 'Matches stay length' : 'Different min nights'
    },
    host: {
      score: breakdown.hostVerified,
      max: MATCH_WEIGHTS.HOST,
      label: 'Host Trust',
      description: getHostDescription(breakdown.hostVerified)
    }
  };

  return {
    listing,
    totalScore,
    scorePercent,
    tier,
    tierDisplay: tier.charAt(0).toUpperCase() + tier.slice(1),
    breakdown: formattedBreakdown,
    maxPossibleScore: maxScore
  };
}
```

#### Changes Made
- Extracted description logic into dedicated helper functions: `getPriceDescription()`, `getBoroughDescription()`, `getHostDescription()`, `getScheduleDescription()`
- Uses `ADJACENT_BOROUGH_SCORE` and `PRICE_THRESHOLD_SCORES` constants instead of magic numbers
- Main function `formatMatchResult()` is now more readable with less inline nesting
- Each description function is independently testable
- Reduced deeply nested ternary expressions

---

## Verification Steps

After implementation, verify with:
1. `bun run lint` - Expect 0 errors
2. `bun run build` - Expect successful build
3. Manually test matching score calculation on Search page with various listings/proposals
4. Run existing tests if available in `src/logic/calculators/matching/__tests__/`

## Rollback Plan

If validation fails, reset these files:
- `src/logic/processors/matching/extractBorough.js` (DELETE - new file)
- `src/logic/rules/matching/isVerifiedHost.js`
- `src/logic/calculators/matching/constants.js`
- `src/logic/calculators/matching/calculatePriceScore.js`
- `src/logic/calculators/matching/calculateBoroughScore.js`
- `src/logic/calculators/matching/calculateMatchHeuristics.js`
- `src/logic/processors/matching/formatMatchResult.js`

## Files Summary

| File | Action | Lines Changed | Risk |
|------|--------|---------------|------|
| `src/logic/processors/matching/extractBorough.js` | CREATE | +45 | LOW |
| `src/logic/rules/matching/isVerifiedHost.js` | MODIFY | -8, +12 | LOW |
| `src/logic/calculators/matching/constants.js` | MODIFY | +28 | LOW |
| `src/logic/calculators/matching/calculatePriceScore.js` | MODIFY | -20, +25 | LOW |
| `src/logic/calculators/matching/calculateBoroughScore.js` | MODIFY | -15, +5 | LOW |
| `src/logic/calculators/matching/calculateMatchHeuristics.js` | MODIFY | -15, +20 | LOW |
| `src/logic/processors/matching/formatMatchResult.js` | MODIFY | -25, +45 | LOW |
