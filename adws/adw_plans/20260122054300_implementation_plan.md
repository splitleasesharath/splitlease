# Implementation Plan - ../app

**Date:** 2026-01-22
**Audit Type:** general
**Generated By:** Claude Opus (ADW Pipeline)

---

## Summary

| Metric | Value |
|--------|-------|
| Files to modify | 7 |
| Risk level | LOW |
| Estimated changes | Extract magic numbers to constants, consolidate duplicate code, remove deprecated file |

## Implementation Order

List files in dependency order (leaves first):
1. `src/logic/calculators/matching/constants.js` - No dependents affected by changes (adding constants)
2. `src/logic/rules/matching/isVerifiedHost.js` - Leaf file, consolidate duplicate verification logic
3. `src/logic/calculators/matching/calculateBoroughScore.js` - Uses constants, extract magic number
4. `src/logic/calculators/matching/calculatePriceScore.js` - Uses constants, extract magic numbers
5. `src/logic/calculators/matching/calculateHostScore.js` - Uses constants, extract magic numbers
6. `src/logic/processors/matching/formatMatchResult.js` - Uses constants, extract magic numbers
7. `src/logic/workflows/booking/cancelProposalWorkflow.js` - Deprecated file to remove

---

## File Changes

### 1. `src/logic/calculators/matching/constants.js`

**Reason:** Add missing score threshold constants that are currently hard-coded in multiple files. This centralizes magic numbers for easier maintenance.
**Dependents:** calculateBoroughScore.js, calculatePriceScore.js, calculateHostScore.js, formatMatchResult.js
**Risk:** LOW

#### Current Code
```javascript
/**
 * Quick Match Scoring Constants
 *
 * Defines weights, thresholds, and reference data for the matching algorithm.
 * Maximum possible score is 95 (price drop heuristic not implemented due to missing data).
 *
 * @module logic/calculators/matching/constants
 */

/**
 * Score weights for each matching criterion.
 * Total: 95 points (5 points unavailable due to missing price history data)
 */
export const MATCH_WEIGHTS = {
  BOROUGH: 25,        // Location proximity
  PRICE: 20,          // Price similarity
  SCHEDULE: 20,       // Schedule day overlap
  WEEKLY_STAY: 15,    // Support for 7-night stays
  DURATION: 10,       // Minimum nights compatibility
  HOST: 5             // Host verification proxy
  // PRICE_DROP: 5    // Not implemented (no price history tracking)
};

/**
 * NYC borough adjacency map for location scoring.
 * Adjacent boroughs receive partial score (15 points vs 25 for exact match).
 */
export const NYC_BOROUGH_ADJACENCY = {
  manhattan: ['brooklyn', 'queens', 'bronx'],
  brooklyn: ['manhattan', 'queens', 'staten island'],
  queens: ['manhattan', 'brooklyn', 'bronx'],
  bronx: ['manhattan', 'queens'],
  'staten island': ['brooklyn']
};

/**
 * Score tiers for categorizing match quality.
 * Used by formatMatchResult to assign tier labels.
 */
export const SCORE_TIERS = {
  EXCELLENT: 75,  // 75+ = excellent match
  GOOD: 50,       // 50-74 = good match
  FAIR: 25        // 25-49 = fair match, below = poor match
};

/**
 * Price proximity thresholds for scoring.
 * Each threshold maps to a score value.
 */
export const PRICE_THRESHOLDS = {
  WITHIN_10_PERCENT: 0.10,  // 20 points
  WITHIN_20_PERCENT: 0.20,  // 15 points
  WITHIN_30_PERCENT: 0.30,  // 10 points
  WITHIN_50_PERCENT: 0.50   // 5 points
};

/**
 * Minimum verification count for host to be considered "verified".
 */
export const MIN_HOST_VERIFICATIONS = 2;

/**
 * Maximum possible score with current data availability.
 */
export const MAX_POSSIBLE_SCORE = 95;

/**
 * Tier labels for display.
 */
export const TIER_LABELS = {
  EXCELLENT: 'excellent',
  GOOD: 'good',
  FAIR: 'fair',
  POOR: 'poor'
};
```

#### Refactored Code
```javascript
/**
 * Quick Match Scoring Constants
 *
 * Defines weights, thresholds, and reference data for the matching algorithm.
 * Maximum possible score is 95 (price drop heuristic not implemented due to missing data).
 *
 * @module logic/calculators/matching/constants
 */

/**
 * Score weights for each matching criterion.
 * Total: 95 points (5 points unavailable due to missing price history data)
 */
export const MATCH_WEIGHTS = {
  BOROUGH: 25,        // Location proximity
  PRICE: 20,          // Price similarity
  SCHEDULE: 20,       // Schedule day overlap
  WEEKLY_STAY: 15,    // Support for 7-night stays
  DURATION: 10,       // Minimum nights compatibility
  HOST: 5             // Host verification proxy
  // PRICE_DROP: 5    // Not implemented (no price history tracking)
};

/**
 * Partial scores for near-match conditions.
 * Used when criteria are partially met (e.g., adjacent borough, within budget tier).
 */
export const PARTIAL_SCORES = {
  BOROUGH_ADJACENT: 15,           // Adjacent borough (60% of full borough score)
  PRICE_WITHIN_20_PERCENT: 15,    // Within 20% of budget
  PRICE_WITHIN_30_PERCENT: 10,    // Within 30% of budget
  PRICE_WITHIN_50_PERCENT: 5,     // Within 50% of budget
  HOST_2_VERIFICATIONS: 3,        // Host has 2 verifications
  HOST_1_VERIFICATION: 1          // Host has 1 verification
};

/**
 * NYC borough adjacency map for location scoring.
 * Adjacent boroughs receive partial score (15 points vs 25 for exact match).
 */
export const NYC_BOROUGH_ADJACENCY = {
  manhattan: ['brooklyn', 'queens', 'bronx'],
  brooklyn: ['manhattan', 'queens', 'staten island'],
  queens: ['manhattan', 'brooklyn', 'bronx'],
  bronx: ['manhattan', 'queens'],
  'staten island': ['brooklyn']
};

/**
 * Score tiers for categorizing match quality.
 * Used by formatMatchResult to assign tier labels.
 */
export const SCORE_TIERS = {
  EXCELLENT: 75,  // 75+ = excellent match
  GOOD: 50,       // 50-74 = good match
  FAIR: 25        // 25-49 = fair match, below = poor match
};

/**
 * Price proximity thresholds for scoring.
 * Each threshold maps to a score value.
 */
export const PRICE_THRESHOLDS = {
  WITHIN_10_PERCENT: 0.10,  // 20 points
  WITHIN_20_PERCENT: 0.20,  // 15 points
  WITHIN_30_PERCENT: 0.30,  // 10 points
  WITHIN_50_PERCENT: 0.50   // 5 points
};

/**
 * Minimum verification count for host to be considered "verified".
 */
export const MIN_HOST_VERIFICATIONS = 2;

/**
 * Maximum possible score with current data availability.
 */
export const MAX_POSSIBLE_SCORE = 95;

/**
 * Tier labels for display.
 */
export const TIER_LABELS = {
  EXCELLENT: 'excellent',
  GOOD: 'good',
  FAIR: 'fair',
  POOR: 'poor'
};
```

#### Changes Made
- Added `PARTIAL_SCORES` object containing all partial score values that were previously hard-coded across multiple files
- Centralized magic numbers: 15 (adjacent borough), 15/10/5 (price tiers), 3/1 (host verification scores)

---

### 2. `src/logic/rules/matching/isVerifiedHost.js`

**Reason:** The verification field extraction logic is duplicated between `isVerifiedHost` and `countHostVerifications`. Extract to a pure helper function to eliminate duplication.
**Dependents:** calculateHostScore.js, adaptCandidateListing.js (uses countHostVerifications)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Check if host has sufficient verification status.
 *
 * @intent Determine host trustworthiness based on verification fields.
 * @rule Counts LinkedIn, Phone, and user verified fields.
 * @rule Host is "verified" if they have >= minimum verifications (default 2).
 * @rule Used as proxy for host responsiveness (no response rate data available).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @param {number} [params.minVerifications=2] - Minimum verifications required.
 * @returns {boolean} True if host meets verification threshold.
 *
 * @example
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => true (2 verifications meet default minimum of 2)
 *
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': false,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => false (only 1 verification)
 */
import { MIN_HOST_VERIFICATIONS } from '../../calculators/matching/constants.js';

export function isVerifiedHost({ host, minVerifications = MIN_HOST_VERIFICATIONS }) {
  if (!host) {
    return false;
  }

  // Count verification fields
  const verifications = [
    host['Verify - Linked In ID'] || host.linkedInVerified || false,
    host['Verify - Phone'] || host.phoneVerified || false,
    host['user verified?'] || host.userVerified || false
  ];

  const verificationCount = verifications.filter(Boolean).length;

  return verificationCount >= minVerifications;
}

/**
 * Count the number of verifications a host has.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @returns {number} Count of verifications (0-3).
 *
 * @example
 * countHostVerifications({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 3
 */
export function countHostVerifications({ host }) {
  if (!host) {
    return 0;
  }

  const verifications = [
    host['Verify - Linked In ID'] || host.linkedInVerified || false,
    host['Verify - Phone'] || host.phoneVerified || false,
    host['user verified?'] || host.userVerified || false
  ];

  return verifications.filter(Boolean).length;
}
```

#### Refactored Code
```javascript
/**
 * Check if host has sufficient verification status.
 *
 * @intent Determine host trustworthiness based on verification fields.
 * @rule Counts LinkedIn, Phone, and user verified fields.
 * @rule Host is "verified" if they have >= minimum verifications (default 2).
 * @rule Used as proxy for host responsiveness (no response rate data available).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @param {number} [params.minVerifications=2] - Minimum verifications required.
 * @returns {boolean} True if host meets verification threshold.
 *
 * @example
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => true (2 verifications meet default minimum of 2)
 *
 * isVerifiedHost({
 *   host: {
 *     'Verify - Linked In ID': false,
 *     'Verify - Phone': true,
 *     'user verified?': false
 *   }
 * })
 * // => false (only 1 verification)
 */
import { MIN_HOST_VERIFICATIONS } from '../../calculators/matching/constants.js';

/**
 * Extract verification statuses from host object.
 * Handles both Bubble field names and camelCase field names.
 *
 * @param {object} host - Host/user object with verification fields.
 * @returns {boolean[]} Array of verification statuses [linkedIn, phone, user].
 */
function extractVerificationStatuses(host) {
  return [
    host['Verify - Linked In ID'] || host.linkedInVerified || false,
    host['Verify - Phone'] || host.phoneVerified || false,
    host['user verified?'] || host.userVerified || false
  ];
}

export function isVerifiedHost({ host, minVerifications = MIN_HOST_VERIFICATIONS }) {
  if (!host) {
    return false;
  }

  const verificationCount = extractVerificationStatuses(host).filter(Boolean).length;

  return verificationCount >= minVerifications;
}

/**
 * Count the number of verifications a host has.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.host - Host/user object with verification fields.
 * @returns {number} Count of verifications (0-3).
 *
 * @example
 * countHostVerifications({
 *   host: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 3
 */
export function countHostVerifications({ host }) {
  if (!host) {
    return 0;
  }

  return extractVerificationStatuses(host).filter(Boolean).length;
}
```

#### Changes Made
- Extracted duplicate verification field extraction logic into private `extractVerificationStatuses` helper function
- Both `isVerifiedHost` and `countHostVerifications` now use the shared helper
- Reduces code duplication and ensures consistent field handling

---

### 3. `src/logic/calculators/matching/calculateBoroughScore.js`

**Reason:** Replace hard-coded magic number (15) with constant from centralized constants file.
**Dependents:** calculateMatchScore.js (imports this function)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate borough match score for a candidate listing.
 *
 * @intent Score geographic proximity between candidate and proposal listings.
 * @rule Same borough = 25 points (full match).
 * @rule Adjacent borough = 15 points (partial match).
 * @rule Different/non-adjacent = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object.
 * @param {object} params.proposal - Proposal object with nested listing data.
 * @returns {number} Score from 0-25.
 *
 * @example
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Manhattan' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 25 (exact match)
 *
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Brooklyn' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 15 (adjacent)
 */
import { isBoroughAdjacent } from '../../rules/matching/isBoroughAdjacent.js';
import { MATCH_WEIGHTS } from './constants.js';

export function calculateBoroughScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Extract borough names from both objects, checking multiple possible field names
  const candidateBorough =
    candidateListing.boroughName ||
    candidateListing['Location - Borough'] ||
    null;

  const proposalBorough =
    proposal.listing?.boroughName ||
    proposal.listing?.borough ||
    proposal.listing?.['Location - Borough'] ||
    null;

  if (!candidateBorough || !proposalBorough) {
    return 0;
  }

  const normalizedCandidate = candidateBorough.toLowerCase().trim();
  const normalizedProposal = proposalBorough.toLowerCase().trim();

  // Exact match = full points
  if (normalizedCandidate === normalizedProposal) {
    return MATCH_WEIGHTS.BOROUGH;
  }

  // Adjacent match = partial points (60% of full)
  if (isBoroughAdjacent({ borough1: normalizedProposal, borough2: normalizedCandidate })) {
    return 15;
  }

  // No match
  return 0;
}
```

#### Refactored Code
```javascript
/**
 * Calculate borough match score for a candidate listing.
 *
 * @intent Score geographic proximity between candidate and proposal listings.
 * @rule Same borough = 25 points (full match).
 * @rule Adjacent borough = 15 points (partial match).
 * @rule Different/non-adjacent = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object.
 * @param {object} params.proposal - Proposal object with nested listing data.
 * @returns {number} Score from 0-25.
 *
 * @example
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Manhattan' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 25 (exact match)
 *
 * calculateBoroughScore({
 *   candidateListing: { boroughName: 'Brooklyn' },
 *   proposal: { listing: { boroughName: 'Manhattan' } }
 * })
 * // => 15 (adjacent)
 */
import { isBoroughAdjacent } from '../../rules/matching/isBoroughAdjacent.js';
import { MATCH_WEIGHTS, PARTIAL_SCORES } from './constants.js';

export function calculateBoroughScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Extract borough names from both objects, checking multiple possible field names
  const candidateBorough =
    candidateListing.boroughName ||
    candidateListing['Location - Borough'] ||
    null;

  const proposalBorough =
    proposal.listing?.boroughName ||
    proposal.listing?.borough ||
    proposal.listing?.['Location - Borough'] ||
    null;

  if (!candidateBorough || !proposalBorough) {
    return 0;
  }

  const normalizedCandidate = candidateBorough.toLowerCase().trim();
  const normalizedProposal = proposalBorough.toLowerCase().trim();

  // Exact match = full points
  if (normalizedCandidate === normalizedProposal) {
    return MATCH_WEIGHTS.BOROUGH;
  }

  // Adjacent match = partial points (60% of full)
  if (isBoroughAdjacent({ borough1: normalizedProposal, borough2: normalizedCandidate })) {
    return PARTIAL_SCORES.BOROUGH_ADJACENT;
  }

  // No match
  return 0;
}
```

#### Changes Made
- Import `PARTIAL_SCORES` from constants
- Replace hard-coded `15` with `PARTIAL_SCORES.BOROUGH_ADJACENT`

---

### 4. `src/logic/calculators/matching/calculatePriceScore.js`

**Reason:** Replace hard-coded magic numbers (15, 10, 5) with constants from centralized constants file.
**Dependents:** calculateMatchScore.js (imports this function)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate price proximity score for a candidate listing.
 *
 * @intent Score how close candidate pricing is to proposal budget.
 * @rule Within 10% = 20 points (full score).
 * @rule Within 20% = 15 points.
 * @rule Within 30% = 10 points.
 * @rule Within 50% = 5 points.
 * @rule Over 50% = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object with pricing fields.
 * @param {object} params.proposal - Proposal object with nightly price and nights per week.
 * @returns {number} Score from 0-20.
 *
 * @example
 * calculatePriceScore({
 *   candidateListing: { 'ðŸ’°Nightly Host Rate for 4 nights': 105 },
 *   proposal: { nightlyPrice: 100, nightsPerWeek: 4 }
 * })
 * // => 20 (5% difference, within 10%)
 */
import { getNightlyRateByFrequency } from '../pricing/getNightlyRateByFrequency.js';
import { calculatePriceProximity } from './calculatePriceProximity.js';
import { MATCH_WEIGHTS, PRICE_THRESHOLDS } from './constants.js';

export function calculatePriceScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Determine nights per week from proposal
  const nightsPerWeek =
    proposal.nightsPerWeek ||
    proposal.daysSelected?.length ||
    4; // Default to 4 if not specified

  // Get proposal nightly price
  const proposalNightlyRate = proposal.nightlyPrice;

  if (!proposalNightlyRate || proposalNightlyRate <= 0) {
    return 0;
  }

  // Get candidate nightly rate for same frequency
  let candidateNightlyRate;
  try {
    candidateNightlyRate = getNightlyRateByFrequency({
      listing: candidateListing,
      nightsSelected: nightsPerWeek
    });
  } catch {
    // If we can't get a rate for this frequency, return 0
    return 0;
  }

  if (!candidateNightlyRate || candidateNightlyRate <= 0) {
    return 0;
  }

  // Calculate proximity ratio
  let proximity;
  try {
    proximity = calculatePriceProximity({
      candidateNightlyRate,
      proposalNightlyRate
    });
  } catch {
    return 0;
  }

  // Score based on proximity thresholds
  if (proximity <= PRICE_THRESHOLDS.WITHIN_10_PERCENT) {
    return MATCH_WEIGHTS.PRICE; // 20 points
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_20_PERCENT) {
    return 15;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_30_PERCENT) {
    return 10;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_50_PERCENT) {
    return 5;
  }

  return 0;
}
```

#### Refactored Code
```javascript
/**
 * Calculate price proximity score for a candidate listing.
 *
 * @intent Score how close candidate pricing is to proposal budget.
 * @rule Within 10% = 20 points (full score).
 * @rule Within 20% = 15 points.
 * @rule Within 30% = 10 points.
 * @rule Within 50% = 5 points.
 * @rule Over 50% = 0 points.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.candidateListing - Candidate listing object with pricing fields.
 * @param {object} params.proposal - Proposal object with nightly price and nights per week.
 * @returns {number} Score from 0-20.
 *
 * @example
 * calculatePriceScore({
 *   candidateListing: { 'ðŸ’°Nightly Host Rate for 4 nights': 105 },
 *   proposal: { nightlyPrice: 100, nightsPerWeek: 4 }
 * })
 * // => 20 (5% difference, within 10%)
 */
import { getNightlyRateByFrequency } from '../pricing/getNightlyRateByFrequency.js';
import { calculatePriceProximity } from './calculatePriceProximity.js';
import { MATCH_WEIGHTS, PRICE_THRESHOLDS, PARTIAL_SCORES } from './constants.js';

export function calculatePriceScore({ candidateListing, proposal }) {
  if (!candidateListing || !proposal) {
    return 0;
  }

  // Determine nights per week from proposal
  const nightsPerWeek =
    proposal.nightsPerWeek ||
    proposal.daysSelected?.length ||
    4; // Default to 4 if not specified

  // Get proposal nightly price
  const proposalNightlyRate = proposal.nightlyPrice;

  if (!proposalNightlyRate || proposalNightlyRate <= 0) {
    return 0;
  }

  // Get candidate nightly rate for same frequency
  let candidateNightlyRate;
  try {
    candidateNightlyRate = getNightlyRateByFrequency({
      listing: candidateListing,
      nightsSelected: nightsPerWeek
    });
  } catch {
    // If we can't get a rate for this frequency, return 0
    return 0;
  }

  if (!candidateNightlyRate || candidateNightlyRate <= 0) {
    return 0;
  }

  // Calculate proximity ratio
  let proximity;
  try {
    proximity = calculatePriceProximity({
      candidateNightlyRate,
      proposalNightlyRate
    });
  } catch {
    return 0;
  }

  // Score based on proximity thresholds
  if (proximity <= PRICE_THRESHOLDS.WITHIN_10_PERCENT) {
    return MATCH_WEIGHTS.PRICE; // 20 points
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_20_PERCENT) {
    return PARTIAL_SCORES.PRICE_WITHIN_20_PERCENT;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_30_PERCENT) {
    return PARTIAL_SCORES.PRICE_WITHIN_30_PERCENT;
  }

  if (proximity <= PRICE_THRESHOLDS.WITHIN_50_PERCENT) {
    return PARTIAL_SCORES.PRICE_WITHIN_50_PERCENT;
  }

  return 0;
}
```

#### Changes Made
- Import `PARTIAL_SCORES` from constants
- Replace hard-coded `15` with `PARTIAL_SCORES.PRICE_WITHIN_20_PERCENT`
- Replace hard-coded `10` with `PARTIAL_SCORES.PRICE_WITHIN_30_PERCENT`
- Replace hard-coded `5` with `PARTIAL_SCORES.PRICE_WITHIN_50_PERCENT`

---

### 5. `src/logic/calculators/matching/calculateHostScore.js`

**Reason:** Replace hard-coded magic numbers (3, 1) with constants from centralized constants file.
**Dependents:** calculateMatchScore.js (imports this function)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Calculate host verification score for a candidate listing.
 *
 * @intent Score host trustworthiness based on verification status.
 * @rule 3 verifications = 5 points (full score).
 * @rule 2 verifications = 3 points.
 * @rule 1 verification = 1 point.
 * @rule 0 verifications = 0 points.
 * @rule Used as proxy for host responsiveness (no response rate data).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.hostData - Host/user object with verification fields.
 * @returns {number} Score from 0-5.
 *
 * @example
 * calculateHostScore({
 *   hostData: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 5 (3 verifications)
 *
 * calculateHostScore({
 *   hostData: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': false,
 *     'user verified?': false
 *   }
 * })
 * // => 1 (1 verification)
 */
import { countHostVerifications } from '../../rules/matching/isVerifiedHost.js';
import { MATCH_WEIGHTS } from './constants.js';

export function calculateHostScore({ hostData }) {
  if (!hostData) {
    return 0;
  }

  const verificationCount = countHostVerifications({ host: hostData });

  // Score mapping based on verification count
  switch (verificationCount) {
    case 3:
      return MATCH_WEIGHTS.HOST; // 5 points
    case 2:
      return 3;
    case 1:
      return 1;
    default:
      return 0;
  }
}
```

#### Refactored Code
```javascript
/**
 * Calculate host verification score for a candidate listing.
 *
 * @intent Score host trustworthiness based on verification status.
 * @rule 3 verifications = 5 points (full score).
 * @rule 2 verifications = 3 points.
 * @rule 1 verification = 1 point.
 * @rule 0 verifications = 0 points.
 * @rule Used as proxy for host responsiveness (no response rate data).
 *
 * @param {object} params - Named parameters.
 * @param {object} params.hostData - Host/user object with verification fields.
 * @returns {number} Score from 0-5.
 *
 * @example
 * calculateHostScore({
 *   hostData: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': true,
 *     'user verified?': true
 *   }
 * })
 * // => 5 (3 verifications)
 *
 * calculateHostScore({
 *   hostData: {
 *     'Verify - Linked In ID': true,
 *     'Verify - Phone': false,
 *     'user verified?': false
 *   }
 * })
 * // => 1 (1 verification)
 */
import { countHostVerifications } from '../../rules/matching/isVerifiedHost.js';
import { MATCH_WEIGHTS, PARTIAL_SCORES } from './constants.js';

export function calculateHostScore({ hostData }) {
  if (!hostData) {
    return 0;
  }

  const verificationCount = countHostVerifications({ host: hostData });

  // Score mapping based on verification count
  switch (verificationCount) {
    case 3:
      return MATCH_WEIGHTS.HOST; // 5 points
    case 2:
      return PARTIAL_SCORES.HOST_2_VERIFICATIONS;
    case 1:
      return PARTIAL_SCORES.HOST_1_VERIFICATION;
    default:
      return 0;
  }
}
```

#### Changes Made
- Import `PARTIAL_SCORES` from constants
- Replace hard-coded `3` with `PARTIAL_SCORES.HOST_2_VERIFICATIONS`
- Replace hard-coded `1` with `PARTIAL_SCORES.HOST_1_VERIFICATION`

---

### 6. `src/logic/processors/matching/formatMatchResult.js`

**Reason:** Replace hard-coded magic numbers in host score description logic with constants.
**Dependents:** None (leaf file, used by UI components)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Format match result with score breakdown for UI display.
 *
 * @intent Transform raw match scores into user-friendly display format.
 * @rule Includes score breakdown with labels and max values.
 * @rule Assigns tier label based on total score.
 * @rule Provides percentage for visual progress indicators.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.listing - The candidate listing (adapted).
 * @param {object} params.scores - Score object from calculateMatchScore.
 * @returns {object} Formatted match result for UI.
 *
 * @example
 * formatMatchResult({
 *   listing: { id: 'abc123', name: 'Nice Apartment', boroughName: 'Manhattan' },
 *   scores: {
 *     totalScore: 85,
 *     breakdown: {
 *       boroughMatch: 25,
 *       priceProximity: 20,
 *       scheduleOverlap: 20,
 *       weeklyStaySupport: 15,
 *       durationMatch: 10,
 *       hostVerified: 5,
 *       priceDrop: 0
 *     },
 *     maxPossibleScore: 95
 *   }
 * })
 * // => {
 * //   listing: { ... },
 * //   totalScore: 85,
 * //   scorePercent: 89,
 * //   tier: 'excellent',
 * //   breakdown: { ... with labels and max values }
 * // }
 */
import { SCORE_TIERS, TIER_LABELS, MATCH_WEIGHTS, MAX_POSSIBLE_SCORE } from '../../calculators/matching/constants.js';

/**
 * Get tier label based on total score.
 *
 * @param {number} score - Total match score.
 * @returns {string} Tier label (excellent, good, fair, poor).
 */
export function getTier(score) {
  if (score >= SCORE_TIERS.EXCELLENT) {
    return TIER_LABELS.EXCELLENT;
  }
  if (score >= SCORE_TIERS.GOOD) {
    return TIER_LABELS.GOOD;
  }
  if (score >= SCORE_TIERS.FAIR) {
    return TIER_LABELS.FAIR;
  }
  return TIER_LABELS.POOR;
}

/**
 * Format match result for UI display.
 */
export function formatMatchResult({ listing, scores }) {
  if (!listing) {
    throw new Error('formatMatchResult: listing is required');
  }

  if (!scores) {
    throw new Error('formatMatchResult: scores is required');
  }

  const { totalScore, breakdown, maxPossibleScore } = scores;

  // Calculate percentage
  const maxScore = maxPossibleScore || MAX_POSSIBLE_SCORE;
  const scorePercent = Math.round((totalScore / maxScore) * 100);

  // Assign tier
  const tier = getTier(totalScore);

  // Format breakdown with labels and max values
  const formattedBreakdown = {
    borough: {
      score: breakdown.boroughMatch,
      max: MATCH_WEIGHTS.BOROUGH,
      label: 'Location Match',
      description: breakdown.boroughMatch === MATCH_WEIGHTS.BOROUGH
        ? 'Same borough'
        : breakdown.boroughMatch > 0
          ? 'Adjacent borough'
          : 'Different area'
    },
    price: {
      score: breakdown.priceProximity,
      max: MATCH_WEIGHTS.PRICE,
      label: 'Price Match',
      description: breakdown.priceProximity === MATCH_WEIGHTS.PRICE
        ? 'Within 10% of budget'
        : breakdown.priceProximity >= 15
          ? 'Within 20% of budget'
          : breakdown.priceProximity >= 10
            ? 'Within 30% of budget'
            : breakdown.priceProximity > 0
              ? 'Within 50% of budget'
              : 'Over budget'
    },
    schedule: {
      score: breakdown.scheduleOverlap,
      max: MATCH_WEIGHTS.SCHEDULE,
      label: 'Schedule Compatibility',
      description: breakdown.scheduleOverlap === MATCH_WEIGHTS.SCHEDULE
        ? 'Full schedule match'
        : breakdown.scheduleOverlap > 0
          ? `${Math.round((breakdown.scheduleOverlap / MATCH_WEIGHTS.SCHEDULE) * 100)}% day overlap`
          : 'No schedule overlap'
    },
    weeklyStay: {
      score: breakdown.weeklyStaySupport,
      max: MATCH_WEIGHTS.WEEKLY_STAY,
      label: 'Weekly Stays',
      description: breakdown.weeklyStaySupport > 0
        ? 'Supports weekly stays'
        : 'Limited availability'
    },
    duration: {
      score: breakdown.durationMatch,
      max: MATCH_WEIGHTS.DURATION,
      label: 'Duration Match',
      description: breakdown.durationMatch > 0
        ? 'Matches stay length'
        : 'Different min nights'
    },
    host: {
      score: breakdown.hostVerified,
      max: MATCH_WEIGHTS.HOST,
      label: 'Host Trust',
      description: breakdown.hostVerified >= 5
        ? 'Fully verified host'
        : breakdown.hostVerified >= 3
          ? 'Verified host'
          : breakdown.hostVerified > 0
            ? 'Partially verified'
            : 'New host'
    }
  };

  return {
    listing,
    totalScore,
    scorePercent,
    tier,
    tierDisplay: tier.charAt(0).toUpperCase() + tier.slice(1),
    breakdown: formattedBreakdown,
    maxPossibleScore: maxScore
  };
}
```

#### Refactored Code
```javascript
/**
 * Format match result with score breakdown for UI display.
 *
 * @intent Transform raw match scores into user-friendly display format.
 * @rule Includes score breakdown with labels and max values.
 * @rule Assigns tier label based on total score.
 * @rule Provides percentage for visual progress indicators.
 *
 * @param {object} params - Named parameters.
 * @param {object} params.listing - The candidate listing (adapted).
 * @param {object} params.scores - Score object from calculateMatchScore.
 * @returns {object} Formatted match result for UI.
 *
 * @example
 * formatMatchResult({
 *   listing: { id: 'abc123', name: 'Nice Apartment', boroughName: 'Manhattan' },
 *   scores: {
 *     totalScore: 85,
 *     breakdown: {
 *       boroughMatch: 25,
 *       priceProximity: 20,
 *       scheduleOverlap: 20,
 *       weeklyStaySupport: 15,
 *       durationMatch: 10,
 *       hostVerified: 5,
 *       priceDrop: 0
 *     },
 *     maxPossibleScore: 95
 *   }
 * })
 * // => {
 * //   listing: { ... },
 * //   totalScore: 85,
 * //   scorePercent: 89,
 * //   tier: 'excellent',
 * //   breakdown: { ... with labels and max values }
 * // }
 */
import { SCORE_TIERS, TIER_LABELS, MATCH_WEIGHTS, PARTIAL_SCORES, MAX_POSSIBLE_SCORE } from '../../calculators/matching/constants.js';

/**
 * Get tier label based on total score.
 *
 * @param {number} score - Total match score.
 * @returns {string} Tier label (excellent, good, fair, poor).
 */
export function getTier(score) {
  if (score >= SCORE_TIERS.EXCELLENT) {
    return TIER_LABELS.EXCELLENT;
  }
  if (score >= SCORE_TIERS.GOOD) {
    return TIER_LABELS.GOOD;
  }
  if (score >= SCORE_TIERS.FAIR) {
    return TIER_LABELS.FAIR;
  }
  return TIER_LABELS.POOR;
}

/**
 * Format match result for UI display.
 */
export function formatMatchResult({ listing, scores }) {
  if (!listing) {
    throw new Error('formatMatchResult: listing is required');
  }

  if (!scores) {
    throw new Error('formatMatchResult: scores is required');
  }

  const { totalScore, breakdown, maxPossibleScore } = scores;

  // Calculate percentage
  const maxScore = maxPossibleScore || MAX_POSSIBLE_SCORE;
  const scorePercent = Math.round((totalScore / maxScore) * 100);

  // Assign tier
  const tier = getTier(totalScore);

  // Format breakdown with labels and max values
  const formattedBreakdown = {
    borough: {
      score: breakdown.boroughMatch,
      max: MATCH_WEIGHTS.BOROUGH,
      label: 'Location Match',
      description: breakdown.boroughMatch === MATCH_WEIGHTS.BOROUGH
        ? 'Same borough'
        : breakdown.boroughMatch > 0
          ? 'Adjacent borough'
          : 'Different area'
    },
    price: {
      score: breakdown.priceProximity,
      max: MATCH_WEIGHTS.PRICE,
      label: 'Price Match',
      description: breakdown.priceProximity === MATCH_WEIGHTS.PRICE
        ? 'Within 10% of budget'
        : breakdown.priceProximity >= PARTIAL_SCORES.PRICE_WITHIN_20_PERCENT
          ? 'Within 20% of budget'
          : breakdown.priceProximity >= PARTIAL_SCORES.PRICE_WITHIN_30_PERCENT
            ? 'Within 30% of budget'
            : breakdown.priceProximity > 0
              ? 'Within 50% of budget'
              : 'Over budget'
    },
    schedule: {
      score: breakdown.scheduleOverlap,
      max: MATCH_WEIGHTS.SCHEDULE,
      label: 'Schedule Compatibility',
      description: breakdown.scheduleOverlap === MATCH_WEIGHTS.SCHEDULE
        ? 'Full schedule match'
        : breakdown.scheduleOverlap > 0
          ? `${Math.round((breakdown.scheduleOverlap / MATCH_WEIGHTS.SCHEDULE) * 100)}% day overlap`
          : 'No schedule overlap'
    },
    weeklyStay: {
      score: breakdown.weeklyStaySupport,
      max: MATCH_WEIGHTS.WEEKLY_STAY,
      label: 'Weekly Stays',
      description: breakdown.weeklyStaySupport > 0
        ? 'Supports weekly stays'
        : 'Limited availability'
    },
    duration: {
      score: breakdown.durationMatch,
      max: MATCH_WEIGHTS.DURATION,
      label: 'Duration Match',
      description: breakdown.durationMatch > 0
        ? 'Matches stay length'
        : 'Different min nights'
    },
    host: {
      score: breakdown.hostVerified,
      max: MATCH_WEIGHTS.HOST,
      label: 'Host Trust',
      description: breakdown.hostVerified >= MATCH_WEIGHTS.HOST
        ? 'Fully verified host'
        : breakdown.hostVerified >= PARTIAL_SCORES.HOST_2_VERIFICATIONS
          ? 'Verified host'
          : breakdown.hostVerified > 0
            ? 'Partially verified'
            : 'New host'
    }
  };

  return {
    listing,
    totalScore,
    scorePercent,
    tier,
    tierDisplay: tier.charAt(0).toUpperCase() + tier.slice(1),
    breakdown: formattedBreakdown,
    maxPossibleScore: maxScore
  };
}
```

#### Changes Made
- Import `PARTIAL_SCORES` from constants
- Replace hard-coded `15` with `PARTIAL_SCORES.PRICE_WITHIN_20_PERCENT` in price description logic
- Replace hard-coded `10` with `PARTIAL_SCORES.PRICE_WITHIN_30_PERCENT` in price description logic
- Replace hard-coded `5` with `MATCH_WEIGHTS.HOST` in host description logic
- Replace hard-coded `3` with `PARTIAL_SCORES.HOST_2_VERIFICATIONS` in host description logic

---

### 7. `src/logic/workflows/booking/cancelProposalWorkflow.js`

**Reason:** This file is deprecated (marked with @deprecated JSDoc) and only re-exports from the canonical location. It should be deleted and any imports updated.
**Dependents:** None (check with grep before deletion)
**Risk:** LOW (file is already a re-export shim)

#### Current Code
```javascript
/**
 * @deprecated Use workflows/proposals/cancelProposalWorkflow.js instead
 * This file is scheduled for removal. All imports should use:
 * import { executeCancelProposal } from '../proposals/cancelProposalWorkflow.js'
 */

// Re-export from canonical location for any remaining imports
export { executeCancelProposal as cancelProposalWorkflow } from '../proposals/cancelProposalWorkflow.js';
```

#### Refactored Code
```javascript
// FILE DELETED - was deprecated shim
```

#### Changes Made
- Delete the file entirely (it is a deprecated re-export shim)
- Before deletion, verify no remaining imports with: `grep -r "workflows/booking/cancelProposalWorkflow" ../app/src`

---

## Verification Steps

After implementation, verify with:
1. `bun run lint` - Expect 0 errors
2. `bun run build` - Expect successful build
3. Run existing tests: `bun test` (if configured)
4. Visual check pages: No UI changes expected (logic-only refactoring)

## Rollback Plan

If validation fails, reset these files:
- `src/logic/calculators/matching/constants.js`
- `src/logic/rules/matching/isVerifiedHost.js`
- `src/logic/calculators/matching/calculateBoroughScore.js`
- `src/logic/calculators/matching/calculatePriceScore.js`
- `src/logic/calculators/matching/calculateHostScore.js`
- `src/logic/processors/matching/formatMatchResult.js`
- Restore `src/logic/workflows/booking/cancelProposalWorkflow.js` if deleted

## Dependencies & Blockers

- None identified

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Constants import path incorrect | Low | Low | Build will fail immediately, easy to fix |
| Existing tests rely on hard-coded values | Low | Low | Tests should compare outputs, not implementation |
| Deprecated file has remaining imports | Low | Medium | Grep search before deletion |

---

## Files Referenced

| File Path | Action |
|-----------|--------|
| `app/src/logic/calculators/matching/constants.js` | Modify (add PARTIAL_SCORES) |
| `app/src/logic/rules/matching/isVerifiedHost.js` | Modify (extract helper function) |
| `app/src/logic/calculators/matching/calculateBoroughScore.js` | Modify (use constants) |
| `app/src/logic/calculators/matching/calculatePriceScore.js` | Modify (use constants) |
| `app/src/logic/calculators/matching/calculateHostScore.js` | Modify (use constants) |
| `app/src/logic/processors/matching/formatMatchResult.js` | Modify (use constants) |
| `app/src/logic/workflows/booking/cancelProposalWorkflow.js` | Delete (deprecated shim) |
