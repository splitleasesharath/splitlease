# Implementation Plan - ../app

**Date:** 2026-01-21
**Audit Type:** general
**Generated By:** Claude Opus (ADW Pipeline)

---

## Summary

| Metric | Value |
|--------|-------|
| Files to modify | 8 |
| Risk level | LOW |
| Estimated changes | Consolidate duplicate constants, remove dead code, eliminate console.logs |

---

## Key Findings

### Code Duplication Identified

1. **DAY_NAMES constant** - Defined in 3 locations:
   - `lib/constants.js` (primary - 52 dependents)
   - `lib/dayUtils.js` (18 dependents)
   - `lib/scheduleSelector/dayHelpers.js` (18 dependents)

2. **formatDate/formatPrice functions** - Duplicated across:
   - `lib/dateFormatters.js` (centralized)
   - `islands/pages/FavoriteListingsPage/formatters.js` (local)
   - `islands/pages/HostProposalsPage/formatters.js` (local)

3. **Price calculation logic** - Multiple implementations:
   - `lib/priceCalculations.js` (legacy)
   - `logic/calculators/pricing/` (new FP pattern)
   - `lib/scheduleSelector/priceCalculations.js` (complex)

### Anti-patterns Found

1. **Console.logs in production** - `lib/scheduleSelector/priceCalculations.js` has 20+ debug logs
2. **Dead code** - `lib/navigation.js:goToRentalApplication()` has unreachable code
3. **Global mutable state** - `lib/sanitize.js:rateLimitMap` uses module-level mutable Map

---

## Implementation Order

Following dependency analysis (leaves first, respecting CRITICAL IMPACT files):

1. `src/lib/navigation.js` - 14 dependents (fix dead code)
2. `src/lib/scheduleSelector/priceCalculations.js` - 1 dependent (remove console.logs)
3. `src/islands/pages/FavoriteListingsPage/formatters.js` - 0 dependents (leaf file)
4. `src/islands/pages/HostProposalsPage/formatters.js` - 0 dependents (leaf file)
5. `src/lib/dayUtils.js` - 18 dependents (remove duplicate DAY_NAMES)
6. `src/lib/scheduleSelector/dayHelpers.js` - 18 dependents (import from constants.js)
7. `src/lib/priceCalculations.js` - 3 dependents (deprecation comment)
8. `src/lib/sanitize.js` - 5 dependents (add comment about mutable state)

---

## File Changes

### 1. `src/lib/navigation.js`

**Reason:** Dead code in `goToRentalApplication` - unreachable code after `window.location.href` assignment
**Dependents:** 14 files import this module
**Risk:** LOW

#### Current Code
```javascript
/**
 * Navigate to rental application
 * Now redirects to account profile with rental application section focus and modal auto-open
 *
 * @param {string} proposalId - Optional proposal ID for context
 * @param {Object} options - Navigation options
 * @param {boolean} options.openModal - Whether to auto-open the rental application modal (default: true)
 * @param {boolean} options.scrollToSection - Whether to scroll to section (default: true)
 */
export function goToRentalApplication(proposalId, options = {}) {
  const { openModal = true, scrollToSection = true } = options;

  const params = new URLSearchParams();

  if (scrollToSection) {
    params.set('section', 'rental-application');
  }

  if (openModal) {
    params.set('openRentalApp', 'true');
  }

  if (proposalId) {
    window.location.href = `/rental-application?proposal=${proposalId}`;
  } else {
    window.location.href = '/rental-application';
  }

  const queryString = params.toString();
  window.location.href = `/account-profile${queryString ? '?' + queryString : ''}`;
}
```

#### Refactored Code
```javascript
/**
 * Navigate to rental application
 * Redirects to account profile with rental application section focus and modal auto-open
 *
 * @param {string} proposalId - Optional proposal ID for context
 * @param {Object} options - Navigation options
 * @param {boolean} options.openModal - Whether to auto-open the rental application modal (default: true)
 * @param {boolean} options.scrollToSection - Whether to scroll to section (default: true)
 */
export function goToRentalApplication(proposalId, options = {}) {
  const { openModal = true, scrollToSection = true } = options;

  const params = new URLSearchParams();

  if (scrollToSection) {
    params.set('section', 'rental-application');
  }

  if (openModal) {
    params.set('openRentalApp', 'true');
  }

  if (proposalId) {
    params.set('proposal', proposalId);
  }

  const queryString = params.toString();
  window.location.href = `/account-profile${queryString ? '?' + queryString : ''}`;
}
```

#### Changes Made
- Removed dead code that was unreachable after early `window.location.href` assignments
- Consolidated logic to always redirect to `/account-profile` with appropriate params
- Preserved all options (openModal, scrollToSection, proposalId) as URL params

---

### 2. `src/lib/scheduleSelector/priceCalculations.js`

**Reason:** Excessive console.log statements in production code (20+ debug logs)
**Dependents:** 1 file imports this module
**Risk:** LOW

#### Current Code
```javascript
/**
 * Main price calculation function
 * @param {Array} selectedNights - Array of selected night objects
 * @param {Object} listing - Listing object with all pricing fields
 * @param {number} reservationSpan - Number of weeks for the reservation
 * @param {Object} zatConfig - ZAT price configuration object
 * @returns {Object} Price breakdown
 */
export const calculatePrice = (selectedNights, listing, reservationSpan = 13, zatConfig = null) => {
  const nightsCount = selectedNights.length;

  console.log('=== CALCULATE PRICE ===');
  console.log('nightsCount:', nightsCount);
  console.log('listing rental type:', listing?.['rental type'] || listing?.rentalType);
  console.log('reservationSpan:', reservationSpan);

  if (nightsCount === 0) {
    return createEmptyPriceBreakdown();
  }

  // Use default ZAT config if not provided
  const config = zatConfig || {
    overallSiteMarkup: 0.17,
    weeklyMarkup: 0,
    fullTimeDiscount: 0.13,
    unusedNightsDiscountMultiplier: 0.03,
    avgDaysPerMonth: 31
  };

  const rentalType = listing.rentalType || listing['rental type'] || 'Nightly';
  const weeksOffered = listing.weeksOffered || listing['Weeks offered'] || 'Every week';
  const unitMarkup = parseFloat(listing.unitMarkup || listing['ðŸ’°Unit Markup'] || 0) / 100;
  const cleaningFee = parseFloat(listing.cleaningFee || listing['ðŸ’°Cleaning Cost / Maintenance Fee'] || 0);
  const damageDeposit = parseFloat(listing.damageDeposit || listing['ðŸ’°Damage Deposit'] || 0);

  let pricePerNight = 0;
  let fourWeekRent = 0;
  let reservationTotal = 0;

  if (rentalType === 'Monthly') {
    // === MONTHLY RENTAL CALCULATION ===
    const result = calculateMonthlyPrice(nightsCount, listing, reservationSpan, config, unitMarkup, weeksOffered);
    pricePerNight = result.pricePerNight;
    fourWeekRent = result.fourWeekRent;
    reservationTotal = result.reservationTotal;

  } else if (rentalType === 'Weekly') {
    // === WEEKLY RENTAL CALCULATION ===
    const result = calculateWeeklyPrice(nightsCount, listing, reservationSpan, config, unitMarkup, weeksOffered);
    pricePerNight = result.pricePerNight;
    fourWeekRent = result.fourWeekRent;
    reservationTotal = result.reservationTotal;

  } else {
    // === NIGHTLY RENTAL CALCULATION ===
    const result = calculateNightlyPrice(nightsCount, listing, reservationSpan, config, weeksOffered);
    pricePerNight = result.pricePerNight;
    fourWeekRent = result.fourWeekRent;
    reservationTotal = result.reservationTotal;
  }

  const initialPayment = fourWeekRent + cleaningFee + damageDeposit;

  console.log('=== PRICE CALCULATION RESULT ===');
  console.log('pricePerNight:', pricePerNight);
  console.log('fourWeekRent:', fourWeekRent);
  console.log('reservationTotal:', reservationTotal);
  console.log('initialPayment:', initialPayment);

  return {
    basePrice: fourWeekRent,
    nightlyRate: Math.round(pricePerNight * 100) / 100,
    discountAmount: 0,
    markupAmount: 0,
    totalPrice: reservationTotal,
    pricePerNight: Math.round(pricePerNight * 100) / 100,
    numberOfNights: nightsCount,
    fourWeekRent: Math.round(fourWeekRent),
    reservationTotal: Math.round(reservationTotal),
    initialPayment: Math.round(initialPayment),
    cleaningFee,
    damageDeposit,
    rentalType,
    weeksOffered,
    reservationSpan,
    valid: true
  };
};

/**
 * Calculate Monthly rental price
 */
function calculateMonthlyPrice(nightsCount, listing, reservationSpan, config, unitMarkup, weeksOffered) {
  const monthlyHostRate = parseFloat(listing.monthlyHostRate || listing['ðŸ’°Monthly Host Rate'] || 0);
  if (!monthlyHostRate) return { pricePerNight: 0, fourWeekRent: 0, reservationTotal: 0 };

  // Step 1: Calculate Monthly Average Nightly Price
  const monthlyAvgNightly = monthlyHostRate / config.avgDaysPerMonth;

  // Step 2: Calculate Average Weekly Price
  const averageWeeklyPrice = monthlyAvgNightly * 7;

  // Step 3: Calculate Prorated Nightly Host Rate
  const nightlyHostRate = averageWeeklyPrice / nightsCount;

  // Step 4: Calculate Unused Nights Discount
  const unusedNights = 7 - nightsCount;
  const unusedNightsDiscountValue = unusedNights * config.unusedNightsDiscountMultiplier;

  // Step 5: Calculate Markup & Discount Multiplier (NO Weekly Markup for Monthly)
  const multiplier = config.overallSiteMarkup + unitMarkup - unusedNightsDiscountValue + 1;

  // Step 6: Calculate Total Weekly Price
  const totalWeeklyPrice = nightlyHostRate * nightsCount * multiplier;

  // Step 7: Calculate Price Per Night
  const pricePerNight = totalWeeklyPrice / nightsCount;

  // Step 8: Get Weekly Schedule Period
  const weeklySchedulePeriod = getWeeklySchedulePeriod(weeksOffered);

  // Step 9: Calculate 4-Week Rent
  const fourWeekRent = (pricePerNight * nightsCount * 4) / weeklySchedulePeriod;

  // Step 11: Calculate Total Reservation Price
  const reservationTotal = calculateTotalReservationPrice(
    pricePerNight,
    nightsCount,
    reservationSpan,
    weeksOffered
  );

  console.log('Monthly calculation:', {
    monthlyAvgNightly,
    averageWeeklyPrice,
    nightlyHostRate,
    unusedNights,
    unusedNightsDiscountValue,
    multiplier,
    totalWeeklyPrice,
    pricePerNight,
    weeklySchedulePeriod,
    fourWeekRent,
    reservationTotal
  });

  return { pricePerNight, fourWeekRent, reservationTotal };
}
```

#### Refactored Code
```javascript
/**
 * Main price calculation function
 * @param {Array} selectedNights - Array of selected night objects
 * @param {Object} listing - Listing object with all pricing fields
 * @param {number} reservationSpan - Number of weeks for the reservation
 * @param {Object} zatConfig - ZAT price configuration object
 * @returns {Object} Price breakdown
 */
export const calculatePrice = (selectedNights, listing, reservationSpan = 13, zatConfig = null) => {
  const nightsCount = selectedNights.length;

  if (nightsCount === 0) {
    return createEmptyPriceBreakdown();
  }

  // Use default ZAT config if not provided
  const config = zatConfig || {
    overallSiteMarkup: 0.17,
    weeklyMarkup: 0,
    fullTimeDiscount: 0.13,
    unusedNightsDiscountMultiplier: 0.03,
    avgDaysPerMonth: 31
  };

  const rentalType = listing.rentalType || listing['rental type'] || 'Nightly';
  const weeksOffered = listing.weeksOffered || listing['Weeks offered'] || 'Every week';
  const unitMarkup = parseFloat(listing.unitMarkup || listing['ðŸ’°Unit Markup'] || 0) / 100;
  const cleaningFee = parseFloat(listing.cleaningFee || listing['ðŸ’°Cleaning Cost / Maintenance Fee'] || 0);
  const damageDeposit = parseFloat(listing.damageDeposit || listing['ðŸ’°Damage Deposit'] || 0);

  let pricePerNight = 0;
  let fourWeekRent = 0;
  let reservationTotal = 0;

  if (rentalType === 'Monthly') {
    const result = calculateMonthlyPrice(nightsCount, listing, reservationSpan, config, unitMarkup, weeksOffered);
    pricePerNight = result.pricePerNight;
    fourWeekRent = result.fourWeekRent;
    reservationTotal = result.reservationTotal;

  } else if (rentalType === 'Weekly') {
    const result = calculateWeeklyPrice(nightsCount, listing, reservationSpan, config, unitMarkup, weeksOffered);
    pricePerNight = result.pricePerNight;
    fourWeekRent = result.fourWeekRent;
    reservationTotal = result.reservationTotal;

  } else {
    const result = calculateNightlyPrice(nightsCount, listing, reservationSpan, config, weeksOffered);
    pricePerNight = result.pricePerNight;
    fourWeekRent = result.fourWeekRent;
    reservationTotal = result.reservationTotal;
  }

  const initialPayment = fourWeekRent + cleaningFee + damageDeposit;

  return {
    basePrice: fourWeekRent,
    nightlyRate: Math.round(pricePerNight * 100) / 100,
    discountAmount: 0,
    markupAmount: 0,
    totalPrice: reservationTotal,
    pricePerNight: Math.round(pricePerNight * 100) / 100,
    numberOfNights: nightsCount,
    fourWeekRent: Math.round(fourWeekRent),
    reservationTotal: Math.round(reservationTotal),
    initialPayment: Math.round(initialPayment),
    cleaningFee,
    damageDeposit,
    rentalType,
    weeksOffered,
    reservationSpan,
    valid: true
  };
};

/**
 * Calculate Monthly rental price
 */
function calculateMonthlyPrice(nightsCount, listing, reservationSpan, config, unitMarkup, weeksOffered) {
  const monthlyHostRate = parseFloat(listing.monthlyHostRate || listing['ðŸ’°Monthly Host Rate'] || 0);
  if (!monthlyHostRate) return { pricePerNight: 0, fourWeekRent: 0, reservationTotal: 0 };

  const monthlyAvgNightly = monthlyHostRate / config.avgDaysPerMonth;
  const averageWeeklyPrice = monthlyAvgNightly * 7;
  const nightlyHostRate = averageWeeklyPrice / nightsCount;
  const unusedNights = 7 - nightsCount;
  const unusedNightsDiscountValue = unusedNights * config.unusedNightsDiscountMultiplier;
  const multiplier = config.overallSiteMarkup + unitMarkup - unusedNightsDiscountValue + 1;
  const totalWeeklyPrice = nightlyHostRate * nightsCount * multiplier;
  const pricePerNight = totalWeeklyPrice / nightsCount;
  const weeklySchedulePeriod = getWeeklySchedulePeriod(weeksOffered);
  const fourWeekRent = (pricePerNight * nightsCount * 4) / weeklySchedulePeriod;
  const reservationTotal = calculateTotalReservationPrice(
    pricePerNight,
    nightsCount,
    reservationSpan,
    weeksOffered
  );

  return { pricePerNight, fourWeekRent, reservationTotal };
}
```

#### Changes Made
- Removed all `console.log` statements from the entire file
- Kept all calculation logic intact
- Maintained function signatures and return types

---

### 3. `src/islands/pages/FavoriteListingsPage/formatters.js`

**Reason:** Duplicate `formatDate` and `formatPrice` functions - should use centralized `lib/dateFormatters.js`
**Dependents:** 0 files (leaf file, used only by FavoriteListingsPage)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Utility functions for formatting listing data
 * Implements the 4 conditional logic rules from Bubble
 */

/**
 * Bathroom display mapping based on Bubble option set
 */
const bathroomDisplayMap = {
  1: '1 Bath',
  1.5: '1.5 Baths',
  2: '2 Baths',
  2.5: '2.5 Baths',
  3: '3 Baths',
  3.5: '3.5 Baths',
  4: '4 Baths',
  4.5: '4.5 Baths',
  5: '5 Baths',
  6: '6 Baths',
};

/**
 * Get bathroom display text from numeric value
 * @param {number} count - Number of bathrooms (can be decimal for half baths)
 * @returns {string} Formatted bathroom display text
 */
export const getBathroomDisplay = (count) => {
  return bathroomDisplayMap[count] || `${count} Baths`;
};

/**
 * Format bedroom and bathroom text according to Bubble's 4 conditional rules
 *
 * CONDITIONAL 1: When bedrooms = 1
 *   Display: "â€¢ 1 bedroom â€¢ [bathrooms] â€¢ [kitchen]"
 *
 * CONDITIONAL 2: When bathrooms = 0
 *   Display: "[bedrooms] bedrooms" (bedroom info only)
 *
 * CONDITIONAL 3: When bedrooms > 1
 *   Display: "â€¢ [bedrooms] bedrooms â€¢ [bathrooms] â€¢ [kitchen]"
 *
 * CONDITIONAL 4: When kitchen type is empty
 *   Display: "â€¢ [bedrooms] bedroom(s) â€¢ [bathrooms]" (no kitchen)
 *
 * @param {number} bedrooms - Number of bedrooms
 * @param {number} bathrooms - Number of bathrooms
 * @param {string} [kitchenType] - Optional kitchen type
 * @returns {string} Formatted display string
 */
export const formatBedroomBathroom = (bedrooms, bathrooms, kitchenType) => {
  const parts = [];

  // CONDITIONAL 2: When bathrooms = 0, show only bedroom info
  if (bathrooms === 0) {
    if (bedrooms === 1) {
      return '1 bedroom';
    } else if (bedrooms > 1) {
      return `${bedrooms} bedrooms`;
    }
    return '';
  }

  // CONDITIONAL 1: When bedrooms = 1
  if (bedrooms === 1) {
    parts.push('1 bedroom');
  }
  // CONDITIONAL 3: When bedrooms > 1
  else if (bedrooms > 1) {
    parts.push(`${bedrooms} bedrooms`);
  }

  // Add bathroom information (if > 0)
  if (bathrooms > 0) {
    const bathroomDisplay = getBathroomDisplay(bathrooms);
    parts.push(bathroomDisplay);
  }

  // CONDITIONAL 4: Add kitchen type only if provided
  if (kitchenType && kitchenType !== '') {
    parts.push(kitchenType);
  }

  // Join parts with bullet separator
  return parts.length > 0 ? 'â€¢ ' + parts.join(' â€¢ ') : '';
};

/**
 * Format price with currency symbol
 * @param {number} price - Price amount
 * @param {string} [currency='USD'] - Currency code
 * @returns {string} Formatted price string (e.g., "$1,029/night")
 */
export const formatPrice = (price, currency = 'USD') => {
  const formatter = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  });

  return `${formatter.format(price)}/night`;
};

/**
 * Format location display
 * @param {string} [borough] - Borough name
 * @param {string} [hood] - Neighborhood name
 * @param {string} [city] - City name
 * @returns {string} Formatted location string (e.g., "Brooklyn, Williamsburg, New York")
 */
export const formatLocation = (borough, hood, city) => {
  const parts = [];

  if (borough) parts.push(borough);
  if (hood) parts.push(hood);
  if (city) parts.push(city);

  return parts.join(', ');
};

/**
 * Format date for display
 * @param {string} dateString - ISO date string
 * @returns {string} Formatted date (e.g., "Jan 15, 2024")
 */
export const formatDate = (dateString) => {
  if (!dateString) return '';

  const date = new Date(dateString);
  return date.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
  });
};

/**
 * Get responsive image URL with imgix processing
 * @param {string} imageUrl - Original image URL
 * @param {number} [width] - Desired width
 * @param {number} [height] - Desired height
 * @returns {string} Processed image URL
 */
export const getProcessedImageUrl = (imageUrl, width, height) => {
  if (!imageUrl) return '';

  // If imgix is already in the URL, add parameters
  if (imageUrl.includes('imgix')) {
    const params = new URLSearchParams();
    if (width) params.append('w', width.toString());
    if (height) params.append('h', height.toString());
    params.append('fit', 'crop');
    params.append('auto', 'format,compress');

    const separator = imageUrl.includes('?') ? '&' : '?';
    return `${imageUrl}${separator}${params.toString()}`;
  }

  return imageUrl;
};
```

#### Refactored Code
```javascript
/**
 * Utility functions for formatting listing data
 * Implements the 4 conditional logic rules from Bubble
 */
import { formatDateDisplay } from '../../../lib/dateFormatters.js';

/**
 * Bathroom display mapping based on Bubble option set
 */
const bathroomDisplayMap = {
  1: '1 Bath',
  1.5: '1.5 Baths',
  2: '2 Baths',
  2.5: '2.5 Baths',
  3: '3 Baths',
  3.5: '3.5 Baths',
  4: '4 Baths',
  4.5: '4.5 Baths',
  5: '5 Baths',
  6: '6 Baths',
};

/**
 * Get bathroom display text from numeric value
 * @param {number} count - Number of bathrooms (can be decimal for half baths)
 * @returns {string} Formatted bathroom display text
 */
export const getBathroomDisplay = (count) => {
  return bathroomDisplayMap[count] || `${count} Baths`;
};

/**
 * Format bedroom and bathroom text according to Bubble's 4 conditional rules
 *
 * CONDITIONAL 1: When bedrooms = 1
 *   Display: "â€¢ 1 bedroom â€¢ [bathrooms] â€¢ [kitchen]"
 *
 * CONDITIONAL 2: When bathrooms = 0
 *   Display: "[bedrooms] bedrooms" (bedroom info only)
 *
 * CONDITIONAL 3: When bedrooms > 1
 *   Display: "â€¢ [bedrooms] bedrooms â€¢ [bathrooms] â€¢ [kitchen]"
 *
 * CONDITIONAL 4: When kitchen type is empty
 *   Display: "â€¢ [bedrooms] bedroom(s) â€¢ [bathrooms]" (no kitchen)
 *
 * @param {number} bedrooms - Number of bedrooms
 * @param {number} bathrooms - Number of bathrooms
 * @param {string} [kitchenType] - Optional kitchen type
 * @returns {string} Formatted display string
 */
export const formatBedroomBathroom = (bedrooms, bathrooms, kitchenType) => {
  const parts = [];

  if (bathrooms === 0) {
    if (bedrooms === 1) {
      return '1 bedroom';
    } else if (bedrooms > 1) {
      return `${bedrooms} bedrooms`;
    }
    return '';
  }

  if (bedrooms === 1) {
    parts.push('1 bedroom');
  } else if (bedrooms > 1) {
    parts.push(`${bedrooms} bedrooms`);
  }

  if (bathrooms > 0) {
    const bathroomDisplay = getBathroomDisplay(bathrooms);
    parts.push(bathroomDisplay);
  }

  if (kitchenType && kitchenType !== '') {
    parts.push(kitchenType);
  }

  return parts.length > 0 ? 'â€¢ ' + parts.join(' â€¢ ') : '';
};

/**
 * Format price with currency symbol
 * @param {number} price - Price amount
 * @param {string} [currency='USD'] - Currency code
 * @returns {string} Formatted price string (e.g., "$1,029/night")
 */
export const formatPrice = (price, currency = 'USD') => {
  const formatter = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: currency,
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  });

  return `${formatter.format(price)}/night`;
};

/**
 * Format location display
 * @param {string} [borough] - Borough name
 * @param {string} [hood] - Neighborhood name
 * @param {string} [city] - City name
 * @returns {string} Formatted location string (e.g., "Brooklyn, Williamsburg, New York")
 */
export const formatLocation = (borough, hood, city) => {
  const parts = [];

  if (borough) parts.push(borough);
  if (hood) parts.push(hood);
  if (city) parts.push(city);

  return parts.join(', ');
};

/**
 * Format date for display
 * Delegates to centralized dateFormatters for consistency
 * @param {string} dateString - ISO date string
 * @returns {string} Formatted date (e.g., "Jan 15, 2024")
 */
export const formatDate = (dateString) => {
  return formatDateDisplay(dateString, { format: 'medium', fallback: '' });
};

/**
 * Get responsive image URL with imgix processing
 * @param {string} imageUrl - Original image URL
 * @param {number} [width] - Desired width
 * @param {number} [height] - Desired height
 * @returns {string} Processed image URL
 */
export const getProcessedImageUrl = (imageUrl, width, height) => {
  if (!imageUrl) return '';

  if (imageUrl.includes('imgix')) {
    const params = new URLSearchParams();
    if (width) params.append('w', width.toString());
    if (height) params.append('h', height.toString());
    params.append('fit', 'crop');
    params.append('auto', 'format,compress');

    const separator = imageUrl.includes('?') ? '&' : '?';
    return `${imageUrl}${separator}${params.toString()}`;
  }

  return imageUrl;
};
```

#### Changes Made
- Added import from centralized `lib/dateFormatters.js`
- Delegated `formatDate` to `formatDateDisplay` for consistency
- Removed redundant inline comments
- Kept `formatPrice` as-is since it has domain-specific "/night" suffix

---

### 4. `src/islands/pages/HostProposalsPage/formatters.js`

**Reason:** Duplicate date formatting functions - should use centralized `lib/dateFormatters.js`
**Dependents:** 0 files (leaf file, used only by HostProposalsPage)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Formatting utilities for Host Proposals Page
 */

/**
 * Format a number as currency (USD)
 * @param {number} amount - The amount to format
 * @returns {string} Formatted currency string
 */
export function formatCurrency(amount) {
  if (amount == null || isNaN(amount)) return '0.00';
  return new Intl.NumberFormat('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(amount);
}

/**
 * Format a date as M/D/YY
 * @param {Date|string} date - The date to format
 * @returns {string} Formatted date string
 */
export function formatDate(date) {
  if (!date) return '';
  const d = new Date(date);
  if (isNaN(d.getTime())) return '';
  const month = d.getMonth() + 1;
  const day = d.getDate();
  const year = d.getFullYear().toString().slice(-2);
  return `${month}/${day}/${year}`;
}

/**
 * Format a date as full date (e.g., "Mar 28, 2025")
 * @param {Date|string} date - The date to format
 * @returns {string} Formatted date string
 */
export function formatFullDate(date) {
  if (!date) return '';
  const d = new Date(date);
  if (isNaN(d.getTime())) return '';
  return d.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric'
  });
}

/**
 * Format a date with time (e.g., "Mar 28, 2025 12:00 pm")
 * @param {Date|string} date - The date to format
 * @returns {string} Formatted date/time string
 */
export function formatDateTime(date) {
  if (!date) return '';
  const d = new Date(date);
  if (isNaN(d.getTime())) return '';
  return d.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    hour12: true
  }).replace(',', '');
}

/**
 * Format time only (e.g., "2:00 pm")
 * @param {string} time - The time string
 * @returns {string} Formatted time string
 */
export function formatTime(time) {
  if (!time) return '';
  return time.toLowerCase();
}

/**
 * Format a date range
 * @param {Date|string} start - Start date
 * @param {Date|string} end - End date
 * @returns {string} Formatted date range
 */
export function formatDateRange(start, end) {
  return `${formatDate(start)} - ${formatDate(end)}`;
}
```

#### Refactored Code
```javascript
/**
 * Formatting utilities for Host Proposals Page
 */
import { formatDateDisplay, formatDateRange as formatDateRangeCentral } from '../../../lib/dateFormatters.js';

/**
 * Format a number as currency (USD)
 * @param {number} amount - The amount to format
 * @returns {string} Formatted currency string
 */
export function formatCurrency(amount) {
  if (amount == null || isNaN(amount)) return '0.00';
  return new Intl.NumberFormat('en-US', {
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).format(amount);
}

/**
 * Format a date as M/D/YY
 * Delegates to centralized dateFormatters
 * @param {Date|string} date - The date to format
 * @returns {string} Formatted date string
 */
export function formatDate(date) {
  return formatDateDisplay(date, { format: 'short', fallback: '' });
}

/**
 * Format a date as full date (e.g., "Mar 28, 2025")
 * Delegates to centralized dateFormatters
 * @param {Date|string} date - The date to format
 * @returns {string} Formatted date string
 */
export function formatFullDate(date) {
  return formatDateDisplay(date, { format: 'medium', fallback: '' });
}

/**
 * Format a date with time (e.g., "Mar 28, 2025 12:00 pm")
 * @param {Date|string} date - The date to format
 * @returns {string} Formatted date/time string
 */
export function formatDateTime(date) {
  if (!date) return '';
  const d = new Date(date);
  if (isNaN(d.getTime())) return '';
  return d.toLocaleDateString('en-US', {
    month: 'short',
    day: 'numeric',
    year: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    hour12: true
  }).replace(',', '');
}

/**
 * Format time only (e.g., "2:00 pm")
 * @param {string} time - The time string
 * @returns {string} Formatted time string
 */
export function formatTime(time) {
  if (!time) return '';
  return time.toLowerCase();
}

/**
 * Format a date range
 * @param {Date|string} start - Start date
 * @param {Date|string} end - End date
 * @returns {string} Formatted date range
 */
export function formatDateRange(start, end) {
  return formatDateRangeCentral(start, end, { format: 'short' });
}
```

#### Changes Made
- Added import from centralized `lib/dateFormatters.js`
- Delegated `formatDate` to `formatDateDisplay` with 'short' format
- Delegated `formatFullDate` to `formatDateDisplay` with 'medium' format
- Delegated `formatDateRange` to centralized implementation
- Kept `formatDateTime` and `formatTime` as-is (not available in centralized module)
- Kept `formatCurrency` as-is (domain-specific function)

---

### 5. `src/lib/dayUtils.js`

**Reason:** Duplicate `DAY_NAMES` constant - already defined in `lib/constants.js` (52 dependents)
**Dependents:** 18 files import this module
**Risk:** LOW (re-export maintains API compatibility)

#### Current Code
```javascript
/**
 * Day Indexing Utilities
 *
 * All day indices use JavaScript's 0-based numbering (matching Date.getDay()):
 *   0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
 *
 * NOTE: Bubble API conversion functions were removed after migrating the database
 * to use 0-indexed days natively. The database now stores days in JS format.
 */

/**
 * Validate that days array contains only valid 0-based indices
 * @param {number[]} days - Array of day indices to validate
 * @returns {boolean} True if all days are valid 0-based indices (0-6)
 */
export function isValidDaysArray(days) {
  if (!Array.isArray(days)) return false;
  return days.every(day => typeof day === 'number' && day >= 0 && day <= 6);
}

/**
 * Day names indexed by 0-based day number
 */
export const DAY_NAMES = [
  'Sunday',   // 0
  'Monday',   // 1
  'Tuesday',  // 2
  'Wednesday',// 3
  'Thursday', // 4
  'Friday',   // 5
  'Saturday'  // 6
];

/**
 * Get day name from 0-based index
 * @param {number} dayIndex - 0-based day index (0-6)
 * @returns {string} Day name or 'Unknown' if invalid
 */
export function getDayName(dayIndex) {
  if (typeof dayIndex !== 'number' || dayIndex < 0 || dayIndex > 6) {
    return 'Unknown';
  }
  return DAY_NAMES[dayIndex];
}

/**
 * Get short day name from 0-based index
 * @param {number} dayIndex - 0-based day index (0-6)
 * @returns {string} Short day name (Sun, Mon, etc.) or '???' if invalid
 */
export function getShortDayName(dayIndex) {
  const name = getDayName(dayIndex);
  return name === 'Unknown' ? '???' : name.slice(0, 3);
}

/**
 * Calculate days until target day of week
 * @.claude\plans\Deprecated\Context\Option Sets\ZEP - Curation Parameters(OS).md {number} fromDay - Current day (0-6)
 * @.claude\plans\Deprecated\Context\Option Sets\ZEP - Curation Parameters(OS).md {number} toDay - Target day (0-6)
 * @returns {number} Days until target (0-6)
 */
export function daysUntilDayOfWeek(fromDay, toDay) {
  return (toDay - fromDay + 7) % 7
}
```

#### Refactored Code
```javascript
/**
 * Day Indexing Utilities
 *
 * All day indices use JavaScript's 0-based numbering (matching Date.getDay()):
 *   0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
 *
 * NOTE: Bubble API conversion functions were removed after migrating the database
 * to use 0-indexed days natively. The database now stores days in JS format.
 */

// Import and re-export DAY_NAMES from canonical source
import { DAY_NAMES as CANONICAL_DAY_NAMES } from './constants.js';

/**
 * Validate that days array contains only valid 0-based indices
 * @param {number[]} days - Array of day indices to validate
 * @returns {boolean} True if all days are valid 0-based indices (0-6)
 */
export function isValidDaysArray(days) {
  if (!Array.isArray(days)) return false;
  return days.every(day => typeof day === 'number' && day >= 0 && day <= 6);
}

/**
 * Day names indexed by 0-based day number
 * Re-exported from lib/constants.js for backward compatibility
 */
export const DAY_NAMES = CANONICAL_DAY_NAMES;

/**
 * Get day name from 0-based index
 * @param {number} dayIndex - 0-based day index (0-6)
 * @returns {string} Day name or 'Unknown' if invalid
 */
export function getDayName(dayIndex) {
  if (typeof dayIndex !== 'number' || dayIndex < 0 || dayIndex > 6) {
    return 'Unknown';
  }
  return CANONICAL_DAY_NAMES[dayIndex];
}

/**
 * Get short day name from 0-based index
 * @param {number} dayIndex - 0-based day index (0-6)
 * @returns {string} Short day name (Sun, Mon, etc.) or '???' if invalid
 */
export function getShortDayName(dayIndex) {
  const name = getDayName(dayIndex);
  return name === 'Unknown' ? '???' : name.slice(0, 3);
}

/**
 * Calculate days until target day of week
 * @param {number} fromDay - Current day (0-6)
 * @param {number} toDay - Target day (0-6)
 * @returns {number} Days until target (0-6)
 */
export function daysUntilDayOfWeek(fromDay, toDay) {
  return (toDay - fromDay + 7) % 7
}
```

#### Changes Made
- Import `DAY_NAMES` from canonical source `lib/constants.js`
- Re-export for backward compatibility with existing imports
- Fixed malformed JSDoc comments in `daysUntilDayOfWeek`
- Used imported constant in `getDayName` function

---

### 6. `src/lib/scheduleSelector/dayHelpers.js`

**Reason:** Duplicate `DAY_NAMES` constant - already defined in `lib/constants.js` (52 dependents)
**Dependents:** 18 files import this module
**Risk:** LOW (re-export maintains API compatibility)

#### Current Code
```javascript
/**
 * Day helper utilities for schedule selectors
 *
 * Day indices use JavaScript's 0-based standard (matching Date.getDay()):
 * 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
 */

// Day names and letters
export const DAY_NAMES = [
  'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
];

export const DAY_LETTERS = ['S', 'M', 'T', 'W', 'T', 'F', 'S'];

export const DAY_ABBREV = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
```

#### Refactored Code
```javascript
/**
 * Day helper utilities for schedule selectors
 *
 * Day indices use JavaScript's 0-based standard (matching Date.getDay()):
 * 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
 */

// Import and re-export from canonical source for consistency
import { DAY_NAMES as CANONICAL_DAY_NAMES, DAY_ABBREVIATIONS } from '../constants.js';

// Re-export for backward compatibility
export const DAY_NAMES = CANONICAL_DAY_NAMES;

export const DAY_LETTERS = DAY_ABBREVIATIONS;

export const DAY_ABBREV = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
```

#### Changes Made
- Import `DAY_NAMES` and `DAY_ABBREVIATIONS` from canonical source `lib/constants.js`
- Re-export as `DAY_NAMES` and `DAY_LETTERS` for backward compatibility
- Keep `DAY_ABBREV` as-is (not available in constants.js, different format)

---

### 7. `src/lib/priceCalculations.js`

**Reason:** Legacy pricing module - newer FP implementations exist in `logic/calculators/pricing/`
**Dependents:** 3 files import this module
**Risk:** LOW (adding deprecation notice only)

#### Current Code
```javascript
/**
 * Price Calculation Utilities
 * Handles all pricing logic for view-split-lease page
 *
 * Usage:
 *   import { calculate4WeekRent, calculateReservationTotal } from './priceCalculations.js';
 */
```

#### Refactored Code
```javascript
/**
 * Price Calculation Utilities
 * Handles all pricing logic for view-split-lease page
 *
 * @deprecated These functions are being consolidated into logic/calculators/pricing/.
 * New code should import from:
 *   - logic/calculators/pricing/calculateFourWeekRent.js
 *   - logic/calculators/pricing/calculateReservationTotal.js
 *   - logic/calculators/pricing/calculatePricingBreakdown.js
 *   - logic/calculators/pricing/getNightlyRateByFrequency.js
 *
 * This module is retained for backward compatibility with existing imports.
 *
 * Usage:
 *   import { calculate4WeekRent, calculateReservationTotal } from './priceCalculations.js';
 */
```

#### Changes Made
- Added `@deprecated` JSDoc tag with migration guidance
- Listed new FP-pattern module locations
- Added note about backward compatibility

---

### 8. `src/lib/sanitize.js`

**Reason:** Module-level mutable state (rateLimitMap) - needs documentation
**Dependents:** 5 files import this module
**Risk:** LOW (adding documentation only)

#### Current Code
```javascript
/**
 * Rate limit check for API calls (simple in-memory implementation)
 * In production, use Redis or similar for distributed rate limiting
 */
const rateLimitMap = new Map();

export function checkRateLimit(key, maxRequests = 10, windowMs = 60000) {
```

#### Refactored Code
```javascript
/**
 * Rate limit check for API calls (simple in-memory implementation)
 * In production, use Redis or similar for distributed rate limiting
 *
 * NOTE: This uses module-level mutable state (rateLimitMap) which persists
 * across the application lifecycle. This is intentional for rate limiting
 * but means state is not isolated between tests or SSR requests.
 *
 * For server-side rendering or testing, consider:
 * - Using a factory function that returns fresh state
 * - Implementing a reset function for tests
 * - Using Redis or similar for production distributed rate limiting
 */
const rateLimitMap = new Map();

export function checkRateLimit(key, maxRequests = 10, windowMs = 60000) {
```

#### Changes Made
- Added detailed documentation about module-level mutable state
- Documented implications for testing and SSR
- Suggested alternatives for production use

---

## Verification Steps

After implementation, verify with:
1. `bun run lint` - Expect 0 errors
2. `bun run build` - Expect successful build
3. Visual check pages:
   - `/favorite-listings` (FavoriteListingsPage)
   - `/host-proposals` (HostProposalsPage)
   - `/search` (uses schedule selector)
   - `/view-split-lease/:id` (uses price calculations)

---

## Rollback Plan

If validation fails, reset these files:
- `src/lib/navigation.js`
- `src/lib/scheduleSelector/priceCalculations.js`
- `src/islands/pages/FavoriteListingsPage/formatters.js`
- `src/islands/pages/HostProposalsPage/formatters.js`
- `src/lib/dayUtils.js`
- `src/lib/scheduleSelector/dayHelpers.js`
- `src/lib/priceCalculations.js`
- `src/lib/sanitize.js`

---

## Files Not Modified (Rationale)

### CRITICAL IMPACT Files (30+ dependents) - Not modified:
- `src/lib/supabase.js` (99 dependents)
- `src/lib/auth.js` (90 dependents)
- `src/lib/secureStorage.js` (89 dependents)
- `src/lib/constants.js` (52 dependents) - This is the canonical source, no changes needed
- `src/lib/dataLookups.js` (41 dependents)

### Why `lib/scheduleSelector/priceCalculations.js` was not fully refactored:
The file contains complex business logic for Monthly/Weekly/Nightly rental calculations with specific formulas ported from Bubble.io. A full refactor would require:
1. Complete test coverage of all calculation paths
2. Verification against Bubble.io expected outputs
3. Coordinated migration of all calling code

This is marked for future consolidation with `logic/calculators/pricing/`.

---

## References

### Dependency Analysis Source
- Files: 631
- Edge reduction: 18%
- Circular imports: None detected
- Leaf files (safe to refactor): 161 files

### Documentation Consulted
- `.claude/CLAUDE.md` - Project orchestration rules
- `app/CLAUDE.md` - Frontend architecture
- `app/src/CLAUDE.md` - Four-layer logic architecture
- `Documentation/miniCLAUDE.md` - Quick reference
