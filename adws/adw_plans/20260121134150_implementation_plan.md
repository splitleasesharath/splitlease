# Implementation Plan - ../app

**Date:** 2026-01-21
**Audit Type:** general
**Generated By:** Claude Opus (ADW Pipeline)

---

## Summary

| Metric | Value |
|--------|-------|
| Files to modify | 8 |
| Risk level | LOW |
| Estimated changes | Input validation, dead code removal, code consolidation |

## Implementation Order

List files in dependency order (leaves first):
1. `src/logic/calculators/scheduling/getNextOccurrenceOfDay.js` - No dependents (0)
2. `src/logic/processors/display/formatHostName.js` - No dependents (0)
3. `src/lib/dateFormatters.js` - No dependents (0)
4. `src/logic/rules/scheduling/isDateBlocked.js` - No dependents (0)
5. `src/lib/priceCalculations.js` - No dependents (0, deprecated)
6. `src/logic/processors/listing/parseJsonArrayField.js` - No dependents (0)
7. `src/lib/scheduleSelector/nightCalculations.js` - 3 dependents (consolidate with dayHelpers)
8. `src/lib/scheduleSelector/dayHelpers.js` - 18 dependents (remove duplicate data source)

---

## File Changes

### 1. `src/logic/calculators/scheduling/getNextOccurrenceOfDay.js`

**Reason:** Missing input validation - function silently produces incorrect results for invalid inputs
**Dependents:** 0 (leaf file)
**Risk:** LOW

#### Current Code
```javascript
import { daysUntilDayOfWeek } from '../../../lib/dayUtils.js'

/**
 * Calculate the next occurrence of a specific day-of-week on or after a starting date.
 *
 * @.claude\plans\Deprecated\Context\Option Sets\ZEP - Curation Parameters(OS).md {Date} startDate - The date to start searching from.
 * @.claude\plans\Deprecated\Context\Option Sets\ZEP - Curation Parameters(OS).md {number} targetDayOfWeek - Day index (0-6, where 0=Sunday).
 * @returns {Date} The next occurrence of the target day.
 */
export function getNextOccurrenceOfDay(startDate, targetDayOfWeek) {
  const startDay = startDate.getDay();
  const daysToAdd = daysUntilDayOfWeek(startDay, targetDayOfWeek);

  const resultDate = new Date(startDate);
  resultDate.setDate(startDate.getDate() + daysToAdd);
  resultDate.setHours(0, 0, 0, 0);

  return resultDate;
}
```

#### Refactored Code
```javascript
import { daysUntilDayOfWeek } from '../../../lib/dayUtils.js'

/**
 * Calculate the next occurrence of a specific day-of-week on or after a starting date.
 *
 * @intent Find the next occurrence of a day-of-week from a starting date.
 * @rule NO FALLBACK: Throws error if inputs are invalid.
 * @rule Uses 0-based day indexing (0=Sunday through 6=Saturday).
 *
 * @param {Date} startDate - The date to start searching from.
 * @param {number} targetDayOfWeek - Day index (0-6, where 0=Sunday).
 * @returns {Date} The next occurrence of the target day.
 *
 * @throws {Error} If startDate is not a valid Date object.
 * @throws {Error} If targetDayOfWeek is not a number between 0-6.
 *
 * @example
 * const nextMonday = getNextOccurrenceOfDay(new Date('2025-01-15'), 1)
 * // => Date representing Monday, Jan 20, 2025
 */
export function getNextOccurrenceOfDay(startDate, targetDayOfWeek) {
  // No Fallback: Validate startDate
  if (!(startDate instanceof Date) || isNaN(startDate.getTime())) {
    throw new Error(
      'getNextOccurrenceOfDay: startDate must be a valid Date object'
    )
  }

  // No Fallback: Validate targetDayOfWeek
  if (typeof targetDayOfWeek !== 'number' || targetDayOfWeek < 0 || targetDayOfWeek > 6) {
    throw new Error(
      `getNextOccurrenceOfDay: targetDayOfWeek must be a number between 0-6, got ${targetDayOfWeek}`
    )
  }

  const startDay = startDate.getDay();
  const daysToAdd = daysUntilDayOfWeek(startDay, targetDayOfWeek);

  const resultDate = new Date(startDate);
  resultDate.setDate(startDate.getDate() + daysToAdd);
  resultDate.setHours(0, 0, 0, 0);

  return resultDate;
}
```

#### Changes Made
- Added strict input validation for startDate (must be valid Date)
- Added strict input validation for targetDayOfWeek (must be 0-6)
- Added comprehensive JSDoc with @intent, @rule, @throws, and @example
- Fixed corrupted JSDoc param tags
- Follows "No Fallback" principle established in codebase

---

### 2. `src/logic/processors/display/formatHostName.js`

**Reason:** Redundant validation logic - double-checking empty string unnecessarily
**Dependents:** 0 (leaf file)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Format full host name to "FirstName L." format for privacy.
 *
 * @intent Format host name for display with privacy (show first name + last initial).
 * @rule NO FALLBACK: Throws error if name is invalid.
 * @rule Single name: Return as-is (e.g., "John" â†’ "John").
 * @rule Multiple names: Return "FirstName L." (e.g., "John Smith" â†’ "John S.").
 *
 * @param {object} params - Named parameters.
 * @param {string} params.fullName - Full name of the host.
 * @returns {string} Formatted name with last initial.
 *
 * @throws {Error} If fullName is not a string or is empty.
 *
 * @example
 * const formatted = formatHostName({ fullName: 'John Smith' })
 * // => "John S."
 *
 * const single = formatHostName({ fullName: 'John' })
 * // => "John"
 */
export function formatHostName({ fullName }) {
  // No Fallback: Strict validation
  if (typeof fullName !== 'string') {
    throw new Error(
      `formatHostName: fullName must be a string, got ${typeof fullName}`
    )
  }

  const trimmedName = fullName.trim()

  if (!trimmedName || trimmedName.length === 0) {
    throw new Error('formatHostName: fullName cannot be empty or whitespace')
  }

  // Split name into parts
  const nameParts = trimmedName.split(/\s+/)

  // Single name: return as-is
  if (nameParts.length === 1) {
    return nameParts[0]
  }

  // Multiple names: "FirstName L."
  const firstName = nameParts[0]
  const lastInitial = nameParts[nameParts.length - 1].charAt(0).toUpperCase()

  return `${firstName} ${lastInitial}.`
}
```

#### Refactored Code
```javascript
/**
 * Format full host name to "FirstName L." format for privacy.
 *
 * @intent Format host name for display with privacy (show first name + last initial).
 * @rule NO FALLBACK: Throws error if name is invalid.
 * @rule Single name: Return as-is (e.g., "John" â†’ "John").
 * @rule Multiple names: Return "FirstName L." (e.g., "John Smith" â†’ "John S.").
 *
 * @param {object} params - Named parameters.
 * @param {string} params.fullName - Full name of the host.
 * @returns {string} Formatted name with last initial.
 *
 * @throws {Error} If fullName is not a string or is empty.
 *
 * @example
 * const formatted = formatHostName({ fullName: 'John Smith' })
 * // => "John S."
 *
 * const single = formatHostName({ fullName: 'John' })
 * // => "John"
 */
export function formatHostName({ fullName }) {
  // No Fallback: Strict type validation
  if (typeof fullName !== 'string') {
    throw new Error(
      `formatHostName: fullName must be a string, got ${typeof fullName}`
    )
  }

  const trimmedName = fullName.trim()

  // No Fallback: Empty string validation (single check - trim already handles whitespace)
  if (!trimmedName) {
    throw new Error('formatHostName: fullName cannot be empty or whitespace')
  }

  // Split name into parts
  const nameParts = trimmedName.split(/\s+/)

  // Single name: return as-is
  if (nameParts.length === 1) {
    return nameParts[0]
  }

  // Multiple names: "FirstName L."
  const firstName = nameParts[0]
  const lastInitial = nameParts[nameParts.length - 1].charAt(0).toUpperCase()

  return `${firstName} ${lastInitial}.`
}
```

#### Changes Made
- Simplified validation: removed redundant `trimmedName.length === 0` check (falsy check already covers this)
- Added clarifying comment explaining why single check is sufficient
- No functional change, just cleaner code

---

### 3. `src/lib/dateFormatters.js`

**Reason:** Dead code in default case - identical to 'medium' case
**Dependents:** 0 (leaf file)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Centralized Date Formatting Utilities
 *
 * Consolidates all date formatting logic to ensure consistency across the application.
 * All formatDate implementations throughout the codebase should delegate to these functions.
 *
 * @module lib/dateFormatters
 */

/**
 * Format a date for display with configurable format and fallback
 * @param {string|Date|null|undefined} dateValue - Date to format
 * @param {Object} [options] - Formatting options
 * @param {string} [options.format='medium'] - Format type: 'short' (M/D/YY), 'medium' (Jan 15, 2025), 'long' (January 15, 2025), 'iso' (2025-01-15)
 * @param {string} [options.fallback=''] - Value to return for invalid/null dates
 * @returns {string} Formatted date string
 */
export function formatDateDisplay(dateValue, options = {}) {
  const { format = 'medium', fallback = '' } = options;

  if (!dateValue) return fallback;

  const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
  if (isNaN(date.getTime())) return fallback;

  switch (format) {
    case 'short':
      // M/D/YY format
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const year = date.getFullYear().toString().slice(-2);
      return `${month}/${day}/${year}`;

    case 'medium':
      // Jan 15, 2025 format
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });

    case 'long':
      // January 15, 2025 format
      return date.toLocaleDateString('en-US', {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      });

    case 'iso':
      // 2025-01-15 format
      return date.toISOString().split('T')[0];

    default:
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
  }
}

/**
 * Format a datetime for display
 * @param {string|Date|null|undefined} dateValue - Datetime to format
 * @param {Object} [options] - Formatting options
 * @param {string} [options.fallback=''] - Value to return for invalid/null dates
 * @param {boolean} [options.includeTimezone=false] - Whether to include timezone
 * @returns {string} Formatted datetime string
 */
export function formatDateTimeDisplay(dateValue, options = {}) {
  const { fallback = '', includeTimezone = false } = options;

  if (!dateValue) return fallback;

  const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
  if (isNaN(date.getTime())) return fallback;

  const formatOptions = {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    timeZone: 'America/New_York'
  };

  if (includeTimezone) {
    formatOptions.timeZoneName = 'short';
  }

  return date.toLocaleString('en-US', formatOptions);
}

/**
 * Format a date range for display
 * @param {string|Date} start - Start date
 * @param {string|Date} end - End date
 * @param {Object} [options] - Formatting options
 * @returns {string} Formatted date range (e.g., "1/15/25 - 2/28/25")
 */
export function formatDateRange(start, end, options = {}) {
  const { format = 'short' } = options;
  const startFormatted = formatDateDisplay(start, { format, fallback: '' });
  const endFormatted = formatDateDisplay(end, { format, fallback: '' });

  if (!startFormatted && !endFormatted) return '';
  if (!startFormatted) return endFormatted;
  if (!endFormatted) return startFormatted;

  return `${startFormatted} - ${endFormatted}`;
}
```

#### Refactored Code
```javascript
/**
 * Centralized Date Formatting Utilities
 *
 * Consolidates all date formatting logic to ensure consistency across the application.
 * All formatDate implementations throughout the codebase should delegate to these functions.
 *
 * @module lib/dateFormatters
 */

/**
 * Format a date for display with configurable format and fallback
 * @param {string|Date|null|undefined} dateValue - Date to format
 * @param {Object} [options] - Formatting options
 * @param {string} [options.format='medium'] - Format type: 'short' (M/D/YY), 'medium' (Jan 15, 2025), 'long' (January 15, 2025), 'iso' (2025-01-15)
 * @param {string} [options.fallback=''] - Value to return for invalid/null dates
 * @returns {string} Formatted date string
 */
export function formatDateDisplay(dateValue, options = {}) {
  const { format = 'medium', fallback = '' } = options;

  if (!dateValue) return fallback;

  const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
  if (isNaN(date.getTime())) return fallback;

  switch (format) {
    case 'short': {
      // M/D/YY format
      const month = date.getMonth() + 1;
      const day = date.getDate();
      const year = date.getFullYear().toString().slice(-2);
      return `${month}/${day}/${year}`;
    }

    case 'long':
      // January 15, 2025 format
      return date.toLocaleDateString('en-US', {
        month: 'long',
        day: 'numeric',
        year: 'numeric'
      });

    case 'iso':
      // 2025-01-15 format
      return date.toISOString().split('T')[0];

    case 'medium':
    default:
      // Jan 15, 2025 format (default)
      return date.toLocaleDateString('en-US', {
        month: 'short',
        day: 'numeric',
        year: 'numeric'
      });
  }
}

/**
 * Format a datetime for display
 * @param {string|Date|null|undefined} dateValue - Datetime to format
 * @param {Object} [options] - Formatting options
 * @param {string} [options.fallback=''] - Value to return for invalid/null dates
 * @param {boolean} [options.includeTimezone=false] - Whether to include timezone
 * @returns {string} Formatted datetime string
 */
export function formatDateTimeDisplay(dateValue, options = {}) {
  const { fallback = '', includeTimezone = false } = options;

  if (!dateValue) return fallback;

  const date = dateValue instanceof Date ? dateValue : new Date(dateValue);
  if (isNaN(date.getTime())) return fallback;

  const formatOptions = {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric',
    hour: 'numeric',
    minute: '2-digit',
    timeZone: 'America/New_York'
  };

  if (includeTimezone) {
    formatOptions.timeZoneName = 'short';
  }

  return date.toLocaleString('en-US', formatOptions);
}

/**
 * Format a date range for display
 * @param {string|Date} start - Start date
 * @param {string|Date} end - End date
 * @param {Object} [options] - Formatting options
 * @returns {string} Formatted date range (e.g., "1/15/25 - 2/28/25")
 */
export function formatDateRange(start, end, options = {}) {
  const { format = 'short' } = options;
  const startFormatted = formatDateDisplay(start, { format, fallback: '' });
  const endFormatted = formatDateDisplay(end, { format, fallback: '' });

  if (!startFormatted && !endFormatted) return '';
  if (!startFormatted) return endFormatted;
  if (!endFormatted) return startFormatted;

  return `${startFormatted} - ${endFormatted}`;
}
```

#### Changes Made
- Consolidated 'medium' case with default using fall-through pattern
- Added block scope `{}` to 'short' case to avoid variable hoisting issues
- Removed duplicate code (default was identical to medium)
- Added comment clarifying medium is the default format

---

### 4. `src/logic/rules/scheduling/isDateBlocked.js`

**Reason:** Silent skip of invalid entries contradicts strict validation pattern
**Dependents:** 0 (leaf file)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Check if a specific date is blocked.
 *
 * @intent Determine if a date is unavailable due to blocking.
 * @rule Compares dates in YYYY-MM-DD format (ignoring time).
 *
 * @param {object} params - Named parameters.
 * @param {Date} params.date - Date to check.
 * @param {Array} params.blockedDates - Array of blocked date strings or Date objects.
 * @returns {boolean} True if date is blocked, false otherwise.
 *
 * @throws {Error} If date is not a valid Date object.
 * @throws {Error} If blockedDates is not an array.
 *
 * @example
 * const blocked = isDateBlocked({
 *   date: new Date('2025-12-25'),
 *   blockedDates: ['2025-12-25', '2025-12-26']
 * })
 * // => true
 */
export function isDateBlocked({ date, blockedDates }) {
  // No Fallback: Validate inputs
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    throw new Error(
      'isDateBlocked: date must be a valid Date object'
    )
  }

  if (!Array.isArray(blockedDates)) {
    throw new Error(
      `isDateBlocked: blockedDates must be an array, got ${typeof blockedDates}`
    )
  }

  // Empty blockedDates array means nothing is blocked
  if (blockedDates.length === 0) {
    return false
  }

  // Format the check date as YYYY-MM-DD
  const dateStr = date.toISOString().split('T')[0]

  // Check if any blocked date matches
  return blockedDates.some(blocked => {
    if (typeof blocked === 'string') {
      // Extract date portion (YYYY-MM-DD) from string
      const blockedDateStr = blocked.split('T')[0]
      return blockedDateStr === dateStr
    }
    if (blocked instanceof Date) {
      const blockedDateStr = blocked.toISOString().split('T')[0]
      return blockedDateStr === dateStr
    }
    // Skip invalid entries silently (they don't block anything)
    return false
  })
}
```

#### Refactored Code
```javascript
/**
 * Check if a specific date is blocked.
 *
 * @intent Determine if a date is unavailable due to blocking.
 * @rule Compares dates in YYYY-MM-DD format (ignoring time).
 * @rule Invalid entries in blockedDates array are silently skipped (business logic: corrupt data should not cause false positives).
 *
 * @param {object} params - Named parameters.
 * @param {Date} params.date - Date to check.
 * @param {Array} params.blockedDates - Array of blocked date strings or Date objects.
 * @returns {boolean} True if date is blocked, false otherwise.
 *
 * @throws {Error} If date is not a valid Date object.
 * @throws {Error} If blockedDates is not an array.
 *
 * @example
 * const blocked = isDateBlocked({
 *   date: new Date('2025-12-25'),
 *   blockedDates: ['2025-12-25', '2025-12-26']
 * })
 * // => true
 *
 * @example
 * // Invalid entries are safely skipped
 * const blocked = isDateBlocked({
 *   date: new Date('2025-12-25'),
 *   blockedDates: ['2025-12-25', null, undefined, 123]
 * })
 * // => true (matches first entry, skips invalid entries)
 */
export function isDateBlocked({ date, blockedDates }) {
  // No Fallback: Validate inputs
  if (!(date instanceof Date) || isNaN(date.getTime())) {
    throw new Error(
      'isDateBlocked: date must be a valid Date object'
    )
  }

  if (!Array.isArray(blockedDates)) {
    throw new Error(
      `isDateBlocked: blockedDates must be an array, got ${typeof blockedDates}`
    )
  }

  // Empty blockedDates array means nothing is blocked
  if (blockedDates.length === 0) {
    return false
  }

  // Format the check date as YYYY-MM-DD
  const dateStr = date.toISOString().split('T')[0]

  // Check if any blocked date matches
  // Business rule: Invalid entries are skipped rather than throwing
  // Rationale: Corrupt data in blockedDates should not cause false blocking
  // (blocking a date when it shouldn't be blocked is worse than skipping corrupt data)
  return blockedDates.some(blocked => {
    if (typeof blocked === 'string') {
      // Extract date portion (YYYY-MM-DD) from string
      const blockedDateStr = blocked.split('T')[0]
      return blockedDateStr === dateStr
    }
    if (blocked instanceof Date && !isNaN(blocked.getTime())) {
      const blockedDateStr = blocked.toISOString().split('T')[0]
      return blockedDateStr === dateStr
    }
    // Skip invalid entries: null, undefined, numbers, invalid dates, etc.
    // This is intentional - corrupt data should not cause false positives
    return false
  })
}
```

#### Changes Made
- Added explicit documentation explaining WHY invalid entries are silently skipped (business logic rationale)
- Added @rule in JSDoc explaining the silent skip behavior
- Added validation for invalid Date objects (`!isNaN(blocked.getTime())`)
- Added second @example showing how invalid entries are handled
- No functional change, but the intent is now clearly documented

---

### 5. `src/lib/priceCalculations.js`

**Reason:** Deprecated file with loose validation - should redirect to logic/calculators/pricing/
**Dependents:** 0 (leaf file, deprecated)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Price Calculation Utilities
 * Handles all pricing logic for view-split-lease page
 *
 * @deprecated These functions are being consolidated into logic/calculators/pricing/.
 * New code should import from:
 *   - logic/calculators/pricing/calculateFourWeekRent.js
 *   - logic/calculators/pricing/calculateReservationTotal.js
 *   - logic/calculators/pricing/calculatePricingBreakdown.js
 *   - logic/calculators/pricing/getNightlyRateByFrequency.js
 *
 * This module is retained for backward compatibility with existing imports.
 *
 * Usage:
 *   import { calculate4WeekRent, calculateReservationTotal } from './priceCalculations.js';
 */

/**
 * Calculate 4-week rent based on nightly price and selected nights
 * Formula: nightly price Ã— nights per week Ã— 4 weeks
 * @param {number} nightlyPrice - Price per night
 * @param {number} nightsPerWeek - Number of nights selected per week
 * @returns {number} 4-week rent amount
 */
export function calculate4WeekRent(nightlyPrice, nightsPerWeek) {
  if (!nightlyPrice || !nightsPerWeek) return 0;
  return nightlyPrice * nightsPerWeek * 4;
}

/**
 * Calculate estimated reservation total
 * Formula: 4-week rent Ã— (total weeks / 4)
 * @param {number} fourWeekRent - 4-week rent amount
 * @param {number} totalWeeks - Total reservation span in weeks
 * @returns {number} Estimated total cost
 */
export function calculateReservationTotal(fourWeekRent, totalWeeks) {
  if (!fourWeekRent || !totalWeeks) return 0;
  return fourWeekRent * (totalWeeks / 4);
}

/**
 * Get nightly price based on number of nights selected
 * Matches Bubble logic for price field selection
 * @param {object} listing - Listing object with price fields
 * @param {number} nightsSelected - Number of nights per week (2-7)
 * @returns {number|null} Nightly price
 */
export function getNightlyPriceForNights(listing, nightsSelected) {
  if (!listing || !nightsSelected) return null;

  // Price override takes precedence
  if (listing['ðŸ’°Price Override']) {
    return listing['ðŸ’°Price Override'];
  }

  // Map nights to price fields
  const priceFieldMap = {
    1: 'ðŸ’°Nightly Host Rate for 1 night',
    2: 'ðŸ’°Nightly Host Rate for 2 nights',
    3: 'ðŸ’°Nightly Host Rate for 3 nights',
    4: 'ðŸ’°Nightly Host Rate for 4 nights',
    5: 'ðŸ’°Nightly Host Rate for 5 nights',
    7: 'ðŸ’°Nightly Host Rate for 7 nights'
  };

  const fieldName = priceFieldMap[nightsSelected];
  if (fieldName && listing[fieldName]) {
    return listing[fieldName];
  }

  // Default to 4-night rate if available
  return listing['ðŸ’°Nightly Host Rate for 4 nights'] || null;
}

/**
 * Format price as currency string
 * @param {number} amount - Dollar amount
 * @param {boolean} showCents - Whether to show cents (default: false)
 * @returns {string} Formatted price (e.g., "$1,234" or "$1,234.56")
 */
export function formatPrice(amount, showCents = false) {
  if (amount === null || amount === undefined || isNaN(amount)) {
    return '$0';
  }

  const formatted = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: showCents ? 2 : 0,
    maximumFractionDigits: showCents ? 2 : 0
  }).format(amount);

  return formatted;
}

/**
 * Calculate complete pricing breakdown
 * @param {object} listing - Listing object
 * @param {number} nightsPerWeek - Nights selected per week
 * @param {number} reservationWeeks - Total reservation span in weeks
 * @returns {object} Complete pricing breakdown
 */
export function calculatePricingBreakdown(listing, nightsPerWeek, reservationWeeks) {
  const nightlyPrice = getNightlyPriceForNights(listing, nightsPerWeek);

  if (!nightlyPrice) {
    return {
      nightlyPrice: null,
      fourWeekRent: null,
      reservationTotal: null,
      cleaningFee: listing['ðŸ’°Cleaning Cost / Maintenance Fee'] || 0,
      damageDeposit: listing['ðŸ’°Damage Deposit'] || 0,
      valid: false
    };
  }

  const fourWeekRent = calculate4WeekRent(nightlyPrice, nightsPerWeek);
  const reservationTotal = calculateReservationTotal(fourWeekRent, reservationWeeks);

  return {
    nightlyPrice,
    fourWeekRent,
    reservationTotal,
    cleaningFee: listing['ðŸ’°Cleaning Cost / Maintenance Fee'] || 0,
    damageDeposit: listing['ðŸ’°Damage Deposit'] || 0,
    grandTotal: reservationTotal + (listing['ðŸ’°Cleaning Cost / Maintenance Fee'] || 0),
    valid: true
  };
}

/**
 * Validate if enough days are selected for price calculation
 * @param {number} daysSelected - Number of days selected
 * @returns {boolean} True if valid for pricing
 */
export function isValidForPricing(daysSelected) {
  return daysSelected >= 2 && daysSelected <= 7;
}

/**
 * Get price display message based on selection state
 * @param {number|null} daysSelected - Number of days selected
 * @returns {string} Display message
 */
export function getPriceDisplayMessage(daysSelected) {
  if (!daysSelected || daysSelected < 2) {
    return 'Please Select More Days';
  }
  if (daysSelected > 7) {
    return 'Please Select 7 Days or Less';
  }
  return null; // Valid selection
}
```

#### Refactored Code
```javascript
/**
 * Price Calculation Utilities (DEPRECATED)
 *
 * @deprecated This module is DEPRECATED. Import from the canonical sources instead:
 *
 *   - calculate4WeekRent â†’ import from 'logic/calculators/pricing/calculateFourWeekRent.js'
 *   - calculateReservationTotal â†’ import from 'logic/calculators/pricing/calculateReservationTotal.js'
 *   - calculatePricingBreakdown â†’ import from 'logic/calculators/pricing/calculatePricingBreakdown.js'
 *   - getNightlyPriceForNights â†’ import from 'logic/calculators/pricing/getNightlyRateByFrequency.js'
 *
 * This file re-exports from the canonical sources for backward compatibility.
 * New code MUST NOT import from this file.
 *
 * TODO: Remove this file after migrating all consumers.
 */

// Re-export from canonical sources
export { calculateFourWeekRent as calculate4WeekRent } from '../logic/calculators/pricing/calculateFourWeekRent.js';
export { calculateReservationTotal } from '../logic/calculators/pricing/calculateReservationTotal.js';
export { calculatePricingBreakdown } from '../logic/calculators/pricing/calculatePricingBreakdown.js';
export { getNightlyRateByFrequency as getNightlyPriceForNights } from '../logic/calculators/pricing/getNightlyRateByFrequency.js';

/**
 * Format price as currency string
 * @param {number} amount - Dollar amount
 * @param {boolean} showCents - Whether to show cents (default: false)
 * @returns {string} Formatted price (e.g., "$1,234" or "$1,234.56")
 *
 * @deprecated Consider moving to a formatters utility module
 */
export function formatPrice(amount, showCents = false) {
  if (amount === null || amount === undefined || isNaN(amount)) {
    return '$0';
  }

  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: showCents ? 2 : 0,
    maximumFractionDigits: showCents ? 2 : 0
  }).format(amount);
}

/**
 * Validate if enough days are selected for price calculation
 * @param {number} daysSelected - Number of days selected
 * @returns {boolean} True if valid for pricing
 *
 * @deprecated Use logic/rules/pricing/isValidDayCountForPricing.js instead
 */
export function isValidForPricing(daysSelected) {
  return daysSelected >= 2 && daysSelected <= 7;
}

/**
 * Get price display message based on selection state
 * @param {number|null} daysSelected - Number of days selected
 * @returns {string|null} Display message or null if valid
 *
 * @deprecated Move this to a UI-specific utility
 */
export function getPriceDisplayMessage(daysSelected) {
  if (!daysSelected || daysSelected < 2) {
    return 'Please Select More Days';
  }
  if (daysSelected > 7) {
    return 'Please Select 7 Days or Less';
  }
  return null;
}
```

#### Changes Made
- Converted calculation functions to re-exports from canonical logic/calculators/pricing/
- Removed duplicate implementations (was violating DRY)
- Added clear @deprecated tags to remaining functions
- Added TODO comment for future removal
- Retained formatPrice, isValidForPricing, getPriceDisplayMessage as they don't have canonical replacements yet

---

### 6. `src/logic/processors/listing/parseJsonArrayField.js`

**Reason:** Two similar functions could be unified with options parameter
**Dependents:** 0 (leaf file)
**Risk:** LOW

#### Current Code
```javascript
/**
 * Parse JSONB field that may be double-encoded as JSON string.
 * Handles both native arrays and JSON-stringified arrays from Supabase.
 *
 * @intent Guarantee valid array data from Supabase JSONB fields.
 * @rule NO FALLBACK - throws explicit errors for invalid data.
 * @rule Fail loud with descriptive errors to surface data quality issues.
 *
 * This is a "Truth" layer processor that validates data shape before it reaches the UI.
 *
 * @param {object} params - Named parameters.
 * @param {any} params.field - JSONB field value from Supabase.
 * @param {string} params.fieldName - Name of field for error messages (e.g., "Features - Amenities").
 * @returns {Array} Parsed and validated array.
 *
 * @throws {Error} If field is null/undefined (data missing).
 * @throws {Error} If field is a string but cannot be parsed as JSON.
 * @throws {Error} If parsed result is not an array.
 * @throws {Error} If field is an unexpected type (not null, array, or string).
 *
 * @example
 * // Already an array
 * const result = parseJsonArrayField({
 *   field: ['amenity1', 'amenity2'],
 *   fieldName: 'Features - Amenities'
 * })
 * // => ['amenity1', 'amenity2']
 *
 * // JSON-encoded string (double-encoded)
 * const result = parseJsonArrayField({
 *   field: '["amenity1","amenity2"]',
 *   fieldName: 'Features - Amenities'
 * })
 * // => ['amenity1', 'amenity2']
 *
 * // Null field throws error
 * parseJsonArrayField({ field: null, fieldName: 'Features - Amenities' })
 * // => Error: parseJsonArrayField: Features - Amenities is null or undefined
 */
export function parseJsonArrayField({ field, fieldName }) {
  // No Fallback: Validate fieldName is provided
  if (!fieldName || typeof fieldName !== 'string') {
    throw new Error(
      'parseJsonArrayField: fieldName parameter is required and must be a string'
    )
  }

  // No Fallback: Null/undefined is an error (data missing)
  if (field === null || field === undefined) {
    throw new Error(
      `parseJsonArrayField: ${fieldName} is null or undefined`
    )
  }

  // Already an array - validate and return
  if (Array.isArray(field)) {
    return field
  }

  // String that needs parsing (double-encoded JSONB)
  if (typeof field === 'string') {
    let parsed
    try {
      parsed = JSON.parse(field)
    } catch (e) {
      throw new Error(
        `parseJsonArrayField: Failed to parse ${fieldName} as JSON - ${e.message}`
      )
    }

    // Ensure parsed result is an array
    if (!Array.isArray(parsed)) {
      throw new Error(
        `parseJsonArrayField: ${fieldName} parsed to ${typeof parsed}, expected array. Value: ${JSON.stringify(parsed)}`
      )
    }

    return parsed
  }

  // Unexpected type - fail loud
  throw new Error(
    `parseJsonArrayField: ${fieldName} has unexpected type ${typeof field}. Expected array or JSON string. Value: ${JSON.stringify(field)}`
  )
}

/**
 * Parse JSONB array field with fallback to empty array for optional fields.
 * Use this ONLY for truly optional fields where an empty array is a valid business state.
 *
 * @intent Parse optional JSONB arrays with explicit empty-array default.
 * @rule Use sparingly - prefer parseJsonArrayField for required fields.
 * @rule Still validates that provided data is correct format.
 *
 * @param {object} params - Named parameters.
 * @param {any} params.field - JSONB field value from Supabase.
 * @param {string} params.fieldName - Name of field for error messages.
 * @returns {Array} Parsed array or empty array if field is null/undefined.
 *
 * @throws {Error} If field is provided but invalid (not parseable or not an array).
 *
 * @example
 * // Optional field not provided - returns empty array
 * const result = parseJsonArrayFieldOptional({
 *   field: null,
 *   fieldName: 'Optional Amenities'
 * })
 * // => []
 */
export function parseJsonArrayFieldOptional({ field, fieldName }) {
  // Optional: Allow null/undefined/empty string with explicit empty array fallback
  if (field === null || field === undefined || field === '') {
    return []
  }

  // For non-null fields, use strict validation
  return parseJsonArrayField({ field, fieldName })
}
```

#### Refactored Code
```javascript
/**
 * Parse JSONB field that may be double-encoded as JSON string.
 * Handles both native arrays and JSON-stringified arrays from Supabase.
 *
 * @intent Guarantee valid array data from Supabase JSONB fields.
 * @rule NO FALLBACK (by default) - throws explicit errors for invalid data.
 * @rule Fail loud with descriptive errors to surface data quality issues.
 * @rule Use optional: true only for truly optional fields where empty array is valid.
 *
 * This is a "Truth" layer processor that validates data shape before it reaches the UI.
 *
 * @param {object} params - Named parameters.
 * @param {any} params.field - JSONB field value from Supabase.
 * @param {string} params.fieldName - Name of field for error messages (e.g., "Features - Amenities").
 * @param {boolean} [params.optional=false] - If true, returns [] for null/undefined/empty instead of throwing.
 * @returns {Array} Parsed and validated array.
 *
 * @throws {Error} If field is null/undefined (data missing) and optional is false.
 * @throws {Error} If field is a string but cannot be parsed as JSON.
 * @throws {Error} If parsed result is not an array.
 * @throws {Error} If field is an unexpected type (not null, array, or string).
 *
 * @example
 * // Already an array
 * const result = parseJsonArrayField({
 *   field: ['amenity1', 'amenity2'],
 *   fieldName: 'Features - Amenities'
 * })
 * // => ['amenity1', 'amenity2']
 *
 * // JSON-encoded string (double-encoded)
 * const result = parseJsonArrayField({
 *   field: '["amenity1","amenity2"]',
 *   fieldName: 'Features - Amenities'
 * })
 * // => ['amenity1', 'amenity2']
 *
 * // Null field throws error (required field)
 * parseJsonArrayField({ field: null, fieldName: 'Features - Amenities' })
 * // => Error: parseJsonArrayField: Features - Amenities is null or undefined
 *
 * // Null field returns empty array (optional field)
 * parseJsonArrayField({ field: null, fieldName: 'Optional Amenities', optional: true })
 * // => []
 */
export function parseJsonArrayField({ field, fieldName, optional = false }) {
  // No Fallback: Validate fieldName is provided
  if (!fieldName || typeof fieldName !== 'string') {
    throw new Error(
      'parseJsonArrayField: fieldName parameter is required and must be a string'
    )
  }

  // Handle null/undefined/empty based on optional flag
  if (field === null || field === undefined || field === '') {
    if (optional) {
      return []
    }
    throw new Error(
      `parseJsonArrayField: ${fieldName} is null or undefined`
    )
  }

  // Already an array - validate and return
  if (Array.isArray(field)) {
    return field
  }

  // String that needs parsing (double-encoded JSONB)
  if (typeof field === 'string') {
    let parsed
    try {
      parsed = JSON.parse(field)
    } catch (e) {
      throw new Error(
        `parseJsonArrayField: Failed to parse ${fieldName} as JSON - ${e.message}`
      )
    }

    // Ensure parsed result is an array
    if (!Array.isArray(parsed)) {
      throw new Error(
        `parseJsonArrayField: ${fieldName} parsed to ${typeof parsed}, expected array. Value: ${JSON.stringify(parsed)}`
      )
    }

    return parsed
  }

  // Unexpected type - fail loud
  throw new Error(
    `parseJsonArrayField: ${fieldName} has unexpected type ${typeof field}. Expected array or JSON string. Value: ${JSON.stringify(field)}`
  )
}

/**
 * Parse JSONB array field with fallback to empty array for optional fields.
 * Use this ONLY for truly optional fields where an empty array is a valid business state.
 *
 * @deprecated Use parseJsonArrayField with { optional: true } instead.
 *
 * @param {object} params - Named parameters.
 * @param {any} params.field - JSONB field value from Supabase.
 * @param {string} params.fieldName - Name of field for error messages.
 * @returns {Array} Parsed array or empty array if field is null/undefined.
 */
export function parseJsonArrayFieldOptional({ field, fieldName }) {
  return parseJsonArrayField({ field, fieldName, optional: true })
}
```

#### Changes Made
- Added `optional` parameter to parseJsonArrayField for unified API
- parseJsonArrayFieldOptional now delegates to parseJsonArrayField with optional: true
- Added @deprecated tag to parseJsonArrayFieldOptional
- Reduced code duplication while maintaining backward compatibility
- Updated JSDoc with new @example showing optional usage

---

### 7. `src/lib/scheduleSelector/nightCalculations.js`

**Reason:** calculateNightsFromDays duplicates createNightsFromDays from dayHelpers.js
**Dependents:** 3
**Risk:** LOW

#### Current Code
```javascript
import { sortDays, getNextDay, createNight } from './dayHelpers.js';

/**
 * Calculate nights from selected days
 */
export const calculateNightsFromDays = (days) => {
  if (days.length < 2) return [];

  const sorted = sortDays(days);
  const nights = [];

  // Nights are the periods between consecutive days
  // For example: Mon, Tue, Wed selected = Mon night, Tue night (2 nights)
  for (let i = 0; i < sorted.length - 1; i++) {
    nights.push(createNight(sorted[i].dayOfWeek));
  }

  return nights;
};

/**
 * Calculate check-in and check-out days
 * Handles wrap-around cases (e.g., Sat-Sun-Mon-Tue-Wed)
 *
 * For wrap-around selections with both Saturday (6) and Sunday (0):
 * - Find the gap in the selection
 * - Check-in is the first day AFTER the gap
 * - Check-out is the last day BEFORE the gap
 *
 * @example
 * Sat(6), Sun(0), Mon(1), Tue(2), Wed(3) -> Check-in: Sat, Check-out: Wed
 * Mon(1), Tue(2), Wed(3), Thu(4), Fri(5) -> Check-in: Mon, Check-out: Fri
 */
export const calculateCheckInCheckOut = (days) => {
  if (days.length === 0) {
    return { checkIn: null, checkOut: null };
  }

  const sorted = sortDays(days);
  const dayNumbers = sorted.map(d => d.dayOfWeek);

  // Check if we have a wrap-around case (both Saturday and Sunday present)
  const hasSaturday = dayNumbers.includes(6);
  const hasSunday = dayNumbers.includes(0);

  if (hasSaturday && hasSunday && days.length < 7) {
    // This is a wrap-around case - find the gap
    let gapStart = -1;

    for (let i = 0; i < dayNumbers.length - 1; i++) {
      if (dayNumbers[i + 1] - dayNumbers[i] > 1) {
        // Found a gap
        gapStart = i + 1;
        break;
      }
    }

    if (gapStart !== -1) {
      // The selection wraps around
      // Check-in is the first day after the gap (e.g., Saturday)
      // Check-out is the last day before the gap (e.g., Wednesday)
      const checkIn = sorted[gapStart];
      const checkOut = sorted[gapStart - 1];

      return { checkIn, checkOut };
    }
  }

  // Standard case: no wrap-around
  const checkIn = sorted[0];
  const checkOut = sorted[sorted.length - 1];

  return { checkIn, checkOut };
};

/**
 * Handle Sunday corner case for check-in/check-out
 */
export const handleSundayTransition = (days) => {
  const sorted = sortDays(days);
  const checkInDay = sorted[0];
  const checkOutDay = sorted[sorted.length - 1];

  // Start night is the first selected day's night
  const startNight = checkInDay.dayOfWeek;

  // End night is the last night before checkout
  const endNight = checkOutDay.dayOfWeek;

  return {
    checkInDay,
    checkOutDay,
    startNight,
    endNight
  };
};

/**
 * Calculate unused nights based on available nights
 */
export const calculateUnusedNights = (availableNights, selectedNights) => {
  return Math.max(0, availableNights - selectedNights.length);
};

/**
 * Calculate start and end night numbers
 */
export const calculateStartEndNightNumbers = (days) => {
  if (days.length === 0) {
    return { startNightNumber: null, endNightNumber: null };
  }

  const sorted = sortDays(days);
  const startNightNumber = sorted[0].dayOfWeek;
  const endNightNumber = sorted[sorted.length - 1].dayOfWeek;

  return { startNightNumber, endNightNumber };
};

/**
 * Calculate days as numbers array
 */
export const calculateDaysAsNumbers = (days) => {
  return sortDays(days).map(day => day.dayOfWeek);
};

/**
 * Calculate selected nights as numbers
 */
export const calculateSelectedNightsAsNumbers = (nights) => {
  return nights.map(night => night.nightNumber);
};

/**
 * Count number of selected nights
 */
export const countSelectedNights = (days) => {
  // Nights = Days - 1 (because nights are between check-in and check-out)
  return Math.max(0, days.length - 1);
};
```

#### Refactored Code
```javascript
import { sortDays, createNight, createNightsFromDays } from './dayHelpers.js';

/**
 * Calculate nights from selected days
 *
 * @deprecated Use createNightsFromDays from dayHelpers.js instead.
 * This is a re-export for backward compatibility.
 */
export const calculateNightsFromDays = createNightsFromDays;

/**
 * Calculate check-in and check-out days
 * Handles wrap-around cases (e.g., Sat-Sun-Mon-Tue-Wed)
 *
 * For wrap-around selections with both Saturday (6) and Sunday (0):
 * - Find the gap in the selection
 * - Check-in is the first day AFTER the gap
 * - Check-out is the last day BEFORE the gap
 *
 * @example
 * Sat(6), Sun(0), Mon(1), Tue(2), Wed(3) -> Check-in: Sat, Check-out: Wed
 * Mon(1), Tue(2), Wed(3), Thu(4), Fri(5) -> Check-in: Mon, Check-out: Fri
 */
export const calculateCheckInCheckOut = (days) => {
  if (days.length === 0) {
    return { checkIn: null, checkOut: null };
  }

  const sorted = sortDays(days);
  const dayNumbers = sorted.map(d => d.dayOfWeek);

  // Check if we have a wrap-around case (both Saturday and Sunday present)
  const hasSaturday = dayNumbers.includes(6);
  const hasSunday = dayNumbers.includes(0);

  if (hasSaturday && hasSunday && days.length < 7) {
    // This is a wrap-around case - find the gap
    let gapStart = -1;

    for (let i = 0; i < dayNumbers.length - 1; i++) {
      if (dayNumbers[i + 1] - dayNumbers[i] > 1) {
        // Found a gap
        gapStart = i + 1;
        break;
      }
    }

    if (gapStart !== -1) {
      // The selection wraps around
      // Check-in is the first day after the gap (e.g., Saturday)
      // Check-out is the last day before the gap (e.g., Wednesday)
      const checkIn = sorted[gapStart];
      const checkOut = sorted[gapStart - 1];

      return { checkIn, checkOut };
    }
  }

  // Standard case: no wrap-around
  const checkIn = sorted[0];
  const checkOut = sorted[sorted.length - 1];

  return { checkIn, checkOut };
};

/**
 * Handle Sunday corner case for check-in/check-out
 */
export const handleSundayTransition = (days) => {
  const sorted = sortDays(days);
  const checkInDay = sorted[0];
  const checkOutDay = sorted[sorted.length - 1];

  // Start night is the first selected day's night
  const startNight = checkInDay.dayOfWeek;

  // End night is the last night before checkout
  const endNight = checkOutDay.dayOfWeek;

  return {
    checkInDay,
    checkOutDay,
    startNight,
    endNight
  };
};

/**
 * Calculate unused nights based on available nights
 */
export const calculateUnusedNights = (availableNights, selectedNights) => {
  return Math.max(0, availableNights - selectedNights.length);
};

/**
 * Calculate start and end night numbers
 */
export const calculateStartEndNightNumbers = (days) => {
  if (days.length === 0) {
    return { startNightNumber: null, endNightNumber: null };
  }

  const sorted = sortDays(days);
  const startNightNumber = sorted[0].dayOfWeek;
  const endNightNumber = sorted[sorted.length - 1].dayOfWeek;

  return { startNightNumber, endNightNumber };
};

/**
 * Calculate days as numbers array
 */
export const calculateDaysAsNumbers = (days) => {
  return sortDays(days).map(day => day.dayOfWeek);
};

/**
 * Calculate selected nights as numbers
 */
export const calculateSelectedNightsAsNumbers = (nights) => {
  return nights.map(night => night.nightNumber);
};

/**
 * Count number of selected nights
 */
export const countSelectedNights = (days) => {
  // Nights = Days - 1 (because nights are between check-in and check-out)
  return Math.max(0, days.length - 1);
};
```

#### Changes Made
- Replaced duplicate calculateNightsFromDays implementation with re-export from dayHelpers.js
- Added @deprecated tag pointing to canonical source
- Removed unused import (getNextDay, createNight - createNight was used by removed function)
- Reduced code duplication while maintaining backward compatibility

---

### 8. `src/lib/scheduleSelector/dayHelpers.js`

**Reason:** DAY_ABBREV duplicates data that could be derived from DAY_NAMES
**Dependents:** 18
**Risk:** MEDIUM (many dependents, but change is additive)

#### Current Code
```javascript
/**
 * Day helper utilities for schedule selectors
 *
 * Day indices use JavaScript's 0-based standard (matching Date.getDay()):
 * 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
 */

// Import and re-export from canonical source for consistency
import { DAY_NAMES as CANONICAL_DAY_NAMES, DAY_ABBREVIATIONS } from '../constants.js';

// Re-export for backward compatibility
export const DAY_NAMES = CANONICAL_DAY_NAMES;

export const DAY_LETTERS = DAY_ABBREVIATIONS;

export const DAY_ABBREV = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

/**
 * Create a Day object from day of week
 * @param {number} dayOfWeek - 0-6 (Sunday-Saturday)
 * @param {boolean} isAvailable - Whether the day is available
 */
export const createDay = (dayOfWeek, isAvailable = true) => {
  const nextDay = (dayOfWeek + 1) % 7;
  const previousNight = (dayOfWeek - 1 + 7) % 7;

  return {
    id: `day-${dayOfWeek}`,
    name: DAY_NAMES[dayOfWeek],
    dayOfWeek,
    singleLetter: DAY_LETTERS[dayOfWeek],
    first3Letters: DAY_ABBREV[dayOfWeek],
    dayIndex: dayOfWeek,  // 0-based day index (0=Sunday through 6=Saturday)
    nextDay,
    previousNight,
    associatedNight: dayOfWeek,
    isAvailable
  };
};

// ... rest of file unchanged
```

#### Refactored Code
```javascript
/**
 * Day helper utilities for schedule selectors
 *
 * Day indices use JavaScript's 0-based standard (matching Date.getDay()):
 * 0=Sunday, 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday
 */

// Import and re-export from canonical source for consistency
import { DAY_NAMES as CANONICAL_DAY_NAMES, DAY_ABBREVIATIONS } from '../constants.js';

// Re-export for backward compatibility
export const DAY_NAMES = CANONICAL_DAY_NAMES;

export const DAY_LETTERS = DAY_ABBREVIATIONS;

/**
 * 3-letter day abbreviations derived from canonical DAY_NAMES
 * @type {string[]}
 */
export const DAY_ABBREV = CANONICAL_DAY_NAMES.map(name => name.slice(0, 3));

/**
 * Create a Day object from day of week
 * @param {number} dayOfWeek - 0-6 (Sunday-Saturday)
 * @param {boolean} isAvailable - Whether the day is available
 */
export const createDay = (dayOfWeek, isAvailable = true) => {
  const nextDay = (dayOfWeek + 1) % 7;
  const previousNight = (dayOfWeek - 1 + 7) % 7;

  return {
    id: `day-${dayOfWeek}`,
    name: DAY_NAMES[dayOfWeek],
    dayOfWeek,
    singleLetter: DAY_LETTERS[dayOfWeek],
    first3Letters: DAY_ABBREV[dayOfWeek],
    dayIndex: dayOfWeek,  // 0-based day index (0=Sunday through 6=Saturday)
    nextDay,
    previousNight,
    associatedNight: dayOfWeek,
    isAvailable
  };
};

/**
 * Sort days by day of week
 */
export const sortDays = (days) => {
  return [...days].sort((a, b) => a.dayOfWeek - b.dayOfWeek);
};

/**
 * Get next day
 */
export const getNextDay = (day) => {
  const nextDayOfWeek = (day.dayOfWeek + 1) % 7;
  return createDay(nextDayOfWeek);
};

/**
 * Get previous day
 */
export const getPreviousDay = (day) => {
  const previousDayOfWeek = (day.dayOfWeek - 1 + 7) % 7;
  return createDay(previousDayOfWeek);
};

/**
 * Convert day to number
 */
export const dayToNumber = (day) => day.dayOfWeek;

/**
 * Create all 7 days
 */
export const createAllDays = (availableDays = [0, 1, 2, 3, 4, 5, 6]) => {
  return Array.from({ length: 7 }, (_, i) => {
    return createDay(i, availableDays.includes(i));
  });
};

/**
 * Create Night object from day of week (0-6 indexing)
 * @param {number} nightNumber - 0-6 (Sunday-Saturday)
 */
export const createNight = (nightNumber) => {
  const nextDay = (nightNumber + 1) % 7;
  const nextNight = (nightNumber + 1) % 7;
  const previousDay = (nightNumber - 1 + 7) % 7;

  return {
    id: `night-${nightNumber}`,
    name: DAY_NAMES[nightNumber],
    nightNumber,
    dayIndex: nightNumber,  // 0-based day index (0=Sunday through 6=Saturday)
    associatedCheckin: nightNumber,
    associatedCheckout: nextDay,
    nextDay,
    nextNight,
    previousDay,
    sameDay: nightNumber,
    first3Letters: DAY_ABBREV[nightNumber],
    singleLetter: DAY_LETTERS[nightNumber]
  };
};

/**
 * Create nights from selected days
 */
export const createNightsFromDays = (days) => {
  if (days.length < 2) return [];

  const sortedDays = sortDays(days);
  const nights = [];

  // Nights are between check-in and check-out (days - 1)
  for (let i = 0; i < sortedDays.length - 1; i++) {
    nights.push(createNight(sortedDays[i].dayOfWeek));
  }

  return nights;
};

/**
 * Get unused nights from all available nights
 */
export const getUnusedNights = (allNights, selectedNights) => {
  const selectedNightNumbers = selectedNights.map(n => n.nightNumber);
  return allNights.filter(night => !selectedNightNumbers.includes(night.nightNumber));
};

/**
 * Get not selected days
 */
export const getNotSelectedDays = (allDays, selectedDays) => {
  const selectedDayNumbers = selectedDays.map(d => d.dayOfWeek);
  return allDays.filter(day => !selectedDayNumbers.includes(day.dayOfWeek));
};

/**
 * Check if a day is in range
 */
export const isDayInRange = (day, startDay, endDay) => {
  const dayNum = day.dayOfWeek;
  const start = startDay.dayOfWeek;
  const end = endDay.dayOfWeek;

  if (start <= end) {
    return dayNum >= start && dayNum <= end;
  } else {
    // Wraps around week
    return dayNum >= start || dayNum <= end;
  }
};
```

#### Changes Made
- Changed DAY_ABBREV from hardcoded array to derived from CANONICAL_DAY_NAMES
- Single source of truth: abbreviations now guaranteed to match full day names
- Added JSDoc describing the derivation
- No breaking changes to exports or API

---

## Verification Steps

After implementation, verify with:
1. `bun run lint` - Expect 0 errors
2. `bun run build` - Expect successful build
3. Visual check pages that use affected utilities:
   - `/search` (uses date formatting, pricing)
   - `/view-split-lease/:id` (uses scheduling calculations, pricing)
   - `/self-listing` (uses day helpers)
   - `/guest-proposals` (uses date formatting)

## Rollback Plan

If validation fails, reset these files:
- `src/logic/calculators/scheduling/getNextOccurrenceOfDay.js`
- `src/logic/processors/display/formatHostName.js`
- `src/lib/dateFormatters.js`
- `src/logic/rules/scheduling/isDateBlocked.js`
- `src/lib/priceCalculations.js`
- `src/logic/processors/listing/parseJsonArrayField.js`
- `src/lib/scheduleSelector/nightCalculations.js`
- `src/lib/scheduleSelector/dayHelpers.js`

---

## References

### Critical Impact Files (DO NOT MODIFY)
- `src/lib/supabase.js` - 99 dependents
- `src/lib/auth.js` - 90 dependents
- `src/lib/secureStorage.js` - 89 dependents
- `src/lib/constants.js` - 55 dependents

### Related Documentation
- [app/CLAUDE.md](../app/CLAUDE.md) - Frontend architecture
- [app/src/CLAUDE.md](../app/src/CLAUDE.md) - Source code patterns
- [Four-Layer Logic Architecture](../.claude/Documentation/largeCLAUDE.md) - Business logic patterns
