/ralph-loop:ralph-loop

Audit the codebase at: {target_path}

{high_impact_summary}

## Refactoring Guidelines Based on Dependencies
- Files marked CRITICAL (30+ dependents) should NOT be modified unless absolutely necessary
- Prefer modifying leaf files (0 dependents) when possible
- Files in CIRCULAR IMPORTS must be refactored together as a single atomic unit
- Follow topological levels: Level 0 first, then Level 1, etc.
- For HIGH impact files, ensure all dependent files are updated in the same batch

**Your Task:**

1. **Scan all files** in {target_path} recursively.
2. **Identify issues:** performance, maintainability, duplication, anti-patterns, or specifically {audit_type} issues.
3. **For each issue, determine affected pages:**
   - Trace imports and usage to find which UI pages are affected by this code.
   - List page URLs (e.g., "/search, /view-split-lease").
   - If it's a shared utility or logic, identify all entry points.
   - If uncertain, use "AUTO".

4. **Create a chunk-based refactoring plan** at: .claude/plans/New/{timestamp}_code_refactor_plan.md

**CRITICAL: Group chunks by affected page group.**

Structure:
# Code Refactoring Plan - {target_path}

Date: {date}
Audit Type: {audit_type}

~~~~~

## PAGE GROUP: /search (Chunks: 1, 3)

### CHUNK 1: [Brief description]
**File:** [path]
**Line:** [line]
**Issue:** [description]
**Affected Pages:** /search

**Current Code:**
```javascript
[exact code]
```

**Refactored Code:**
```javascript
[refactored code]
```

**Testing:**
- [ ] [step]

~~~~~

### CHUNK 3: [Brief description]
...

~~~~~

## PAGE GROUP: /view-split-lease (Chunks: 2)
...

## CRITICAL: Cascading Dependency Analysis

Before generating chunks, you MUST identify cascading dependencies:

1. **For any function/constant you plan to RENAME or MOVE:**
   - Search for ALL files that import it
   - List them in "Cascading Changes Required" section
   - Include ALL dependent files in the SAME page group

2. **For any function signature you plan to CHANGE:**
   - Identify all call sites
   - Ensure parameter changes are reflected everywhere

3. **Use this pattern to find dependencies:**
   ```
   grep -rn "import.*{{.*SYMBOL_NAME.*}}" app/src/
   ```

## Chunk Grouping Rules

- Group by PRIMARY affected page
- If a change affects SHARED code (lib/, logic/), include ALL pages that use it
- Mark cross-cutting changes as "GLOBAL" group
- Never split a rename/move across multiple groups

## Required Metadata Per Chunk

Each chunk MUST include:
- **File:** exact path
- **Line:** line number
- **Affected Pages:** list of pages
- **Cascading Changes:** files that import modified symbols (if any)

**CRITICAL FORMATTING RULES:**
1. **Group by PAGE GROUP** header.
2. **One chunk = one atomic fix**.
3. **Use horizontal rules (EXACTLY `~~~~~`)** to separate chunks.
4. **MANDATORY: Each chunk MUST have TWO complete code blocks (Current vs Refactored)**.
5. **Line numbers must be accurate**.
6. **Include affected pages in EACH chunk metadata**.
7. **Include cascading changes list for any renamed/moved symbols**.

## OUTPUT FORMAT REQUIREMENTS

You MUST format each chunk exactly as follows:

```
## Chunk N of M
- **Files**: `path/to/file1.js`, `path/to/file2.js`
- **Rationale**: Why these files are grouped together
- **Approach**: How to refactor them
```

IMPORTANT:
- Use exact file paths from the codebase (shown in dependency analysis above)
- Each file path MUST be wrapped in backticks
- Files in CIRCULAR IMPORTS must be in the SAME chunk
- Do NOT include files not mentioned in the dependency analysis
