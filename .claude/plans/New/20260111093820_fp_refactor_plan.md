# Functional Programming Refactoring Plan

Date: 2026-01-11
Target: agents/fp_audit_violations.json
Severity Filter: HIGH
Total Violations: 350

## Summary

| Metric | Count |
|--------|-------|
| Total Violations | 350 |
| MUTATING_METHOD | 265 |
| IMPERATIVE_LOOP | 80 |
| IO_IN_CORE | 5 |
| Severity: HIGH | 350 |

## Top Files by Violation Count

| File | Count | Priority |
|------|-------|----------|
| src/islands/pages/SelfListingPage/store/listingLocalStore.ts | 21 | P1 |
| src/lib/availabilityValidation.js | 16 | P1 |
| src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts | 15 | P1 |
| src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx | 12 | P2 |
| src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx | 11 | P2 |
| src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx | 10 | P2 |
| src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx | 10 | P2 |
| src/islands/pages/SelfListingPage/sections/Section5Rules.tsx | 10 | P2 |

---

~~~~~

## CHUNK 1: Replace `.sort()` with `toSorted()` in isContiguousSelection

**File:** app/src/lib/availabilityValidation.js
**Line:** 31
**Violation:** MUTATING_METHOD - Using `.sort()` which mutates the copied array
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals, /host-proposals

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
While `[...selectedDays].sort()` creates a copy first, `toSorted()` is the modern, explicitly immutable alternative that signals intent more clearly. It returns a new sorted array without any intermediate mutation.

**Testing:**
- [ ] Run unit tests for isContiguousSelection function
- [ ] Test with [1,3,5], [1,2,3,4,5], [5,6,0] inputs
- [ ] Verify contiguity detection still works for wrap-around cases

~~~~~

## CHUNK 2: Replace imperative gap-finding loop with declarative findIndex

**File:** app/src/lib/availabilityValidation.js
**Line:** 38
**Violation:** IMPERATIVE_LOOP - Using `for` loop to find gap in sorted array
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals, /host-proposals

**Current Code:**
```javascript
let isStandardContiguous = true;
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    isStandardContiguous = false;
    break;
  }
}
```

**Refactored Code:**
```javascript
const isStandardContiguous = sorted.every((day, i) =>
  i === 0 || day === sorted[i - 1] + 1
);
```

**Why This Matters:**
The `.every()` method expresses the invariant directly: "every element (except the first) must be exactly one more than the previous." This is more declarative and eliminates the mutable `isStandardContiguous` flag.

**Testing:**
- [ ] Test standard contiguous: [1,2,3,4,5] should return true
- [ ] Test non-contiguous: [1,3,5] should return false
- [ ] Test single element: [3] should return true

~~~~~

## CHUNK 3: Replace imperative range generation with Array.from

**File:** app/src/lib/availabilityValidation.js
**Line:** 65-66
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Using `for` loop with `.push()` to generate range
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals, /host-proposals

**Current Code:**
```javascript
const expectedNotSelected = [];
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i);
}
```

**Refactored Code:**
```javascript
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
`Array.from` with a mapping function generates the range declaratively without mutation. The intent is clear: create an array of consecutive numbers from min to max.

**Testing:**
- [ ] Test range generation: min=2, max=4 should produce [2,3,4]
- [ ] Test single element: min=3, max=3 should produce [3]
- [ ] Verify wrap-around contiguity detection

~~~~~

## CHUNK 4: Replace `.sort()` in calculateCheckInOutDays

**File:** app/src/lib/availabilityValidation.js
**Line:** 97
**Violation:** MUTATING_METHOD - Using `.sort()` which mutates the copied array
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals, /host-proposals

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
Using `toSorted()` explicitly communicates immutability and is the modern standard for non-mutating sorts.

**Testing:**
- [ ] Test check-in/out calculation for [1,2,3,4,5]
- [ ] Test wrap-around case [5,6,0,1]
- [ ] Verify day names are correctly mapped

~~~~~

## CHUNK 5: Replace gap-finding loop with findIndex in calculateCheckInOutDays

**File:** app/src/lib/availabilityValidation.js
**Line:** 106
**Violation:** IMPERATIVE_LOOP - Using `for` loop to find gap index
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals, /host-proposals

**Current Code:**
```javascript
let gapIndex = -1;
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    gapIndex = i;
    break;
  }
}
```

**Refactored Code:**
```javascript
const gapIndex = sorted.findIndex((day, i) =>
  i > 0 && day !== sorted[i - 1] + 1
);
```

**Why This Matters:**
`findIndex` returns the index of the first element that satisfies the predicate, which is exactly what we need. This eliminates the mutable `gapIndex` variable and the explicit break statement.

**Testing:**
- [ ] Test gap detection in [0,1,5,6] - should find gap at index 2
- [ ] Test no gap in [1,2,3] - should return -1
- [ ] Verify check-in/out days are calculated correctly for wrap-around

~~~~~

## CHUNK 6: Refactor validateScheduleSelection to use declarative error collection

**File:** app/src/lib/availabilityValidation.js
**Lines:** 166, 175, 181, 186, 199
**Violation:** MUTATING_METHOD - Multiple `.push()` calls to errors/warnings arrays
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals, /host-proposals

**Current Code:**
```javascript
export function validateScheduleSelection(selectedDays, listing) {
  const result = {
    valid: true,
    errors: [],
    warnings: [],
    showTutorial: false,
    nightsCount: selectedDays.length,
    isContiguous: false
  };

  // Check if days are selected
  if (!selectedDays || selectedDays.length === 0) {
    result.valid = false;
    result.errors.push('Please select at least one day');
    return result;
  }

  // Check contiguous requirement (CRITICAL)
  result.isContiguous = isContiguousSelection(selectedDays);
  if (!result.isContiguous) {
    result.valid = false;
    result.showTutorial = true;
    result.errors.push('Please check for contiguous nights to continue with your proposal');
    return result;
  }

  // Check against minimum nights
  if (listing['Minimum Nights'] && selectedDays.length < listing['Minimum Nights']) {
    result.warnings.push(`Host prefers at least ${listing['Minimum Nights']} nights per week`);
  }

  // Check against maximum nights
  if (listing['Maximum Nights'] && selectedDays.length > listing['Maximum Nights']) {
    result.warnings.push(`Host prefers at most ${listing['Maximum Nights']} nights per week`);
  }

  // Check against Days Not Available
  if (listing['Days Not Available'] && Array.isArray(listing['Days Not Available'])) {
    const unavailableDays = listing['Days Not Available'];
    const unavailableSelected = selectedDays.filter(day => {
      const dayName = DAY_NAMES[day];
      return unavailableDays.includes(dayName);
    });

    if (unavailableSelected.length > 0) {
      result.valid = false;
      result.errors.push('Some selected days are not available for this listing');
    }
  }

  return result;
}
```

**Refactored Code:**
```javascript
export function validateScheduleSelection(selectedDays, listing) {
  // Early return for empty selection
  if (!selectedDays || selectedDays.length === 0) {
    return {
      valid: false,
      errors: ['Please select at least one day'],
      warnings: [],
      showTutorial: false,
      nightsCount: 0,
      isContiguous: false
    };
  }

  const isContiguous = isContiguousSelection(selectedDays);

  // Early return for non-contiguous selection
  if (!isContiguous) {
    return {
      valid: false,
      errors: ['Please check for contiguous nights to continue with your proposal'],
      warnings: [],
      showTutorial: true,
      nightsCount: selectedDays.length,
      isContiguous: false
    };
  }

  // Collect all warnings declaratively
  const warnings = [
    listing['Minimum Nights'] && selectedDays.length < listing['Minimum Nights'] &&
      `Host prefers at least ${listing['Minimum Nights']} nights per week`,
    listing['Maximum Nights'] && selectedDays.length > listing['Maximum Nights'] &&
      `Host prefers at most ${listing['Maximum Nights']} nights per week`
  ].filter(Boolean);

  // Check unavailable days
  const unavailableDays = listing['Days Not Available'];
  const hasUnavailableSelected = Array.isArray(unavailableDays) &&
    selectedDays.some(day => unavailableDays.includes(DAY_NAMES[day]));

  const errors = hasUnavailableSelected
    ? ['Some selected days are not available for this listing']
    : [];

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    showTutorial: false,
    nightsCount: selectedDays.length,
    isContiguous: true
  };
}
```

**Why This Matters:**
Instead of mutating arrays with `.push()`, we construct the final arrays declaratively using conditional expressions and `.filter(Boolean)`. This makes the validation rules explicit and the data flow clear.

**Testing:**
- [ ] Test empty selection returns error
- [ ] Test non-contiguous returns error with showTutorial=true
- [ ] Test warnings for min/max nights violations
- [ ] Test unavailable days detection

~~~~~

## CHUNK 7: Refactor validateMoveInDate to use declarative error collection

**File:** app/src/lib/availabilityValidation.js
**Lines:** 271, 280, 287, 294, 305
**Violation:** MUTATING_METHOD - Multiple `.push()` calls to errors array
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals

**Current Code:**
```javascript
export function validateMoveInDate(moveInDate, listing, selectedDays) {
  const result = {
    valid: true,
    errors: []
  };

  if (!moveInDate) {
    result.valid = false;
    result.errors.push('Please select a move-in date');
    return result;
  }

  // Check if date is in the past
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  if (moveInDate < today) {
    result.valid = false;
    result.errors.push('Move-in date cannot be in the past');
    return result;
  }

  // Check if date is within available range
  if (!isDateInRange(moveInDate, listing['First Available'], listing['Last Available'])) {
    result.valid = false;
    result.errors.push('Move-in date is outside available range');
    return result;
  }

  // Check if date is blocked
  if (isDateBlocked(moveInDate, listing['Dates - Blocked'])) {
    result.valid = false;
    result.errors.push('Selected move-in date is not available');
    return result;
  }

  // Check if move-in date's day of week matches selected schedule
  if (selectedDays && selectedDays.length > 0) {
    const { checkInDay } = calculateCheckInOutDays(selectedDays);
    const moveInDayOfWeek = moveInDate.getDay();

    if (checkInDay !== null && moveInDayOfWeek !== checkInDay) {
      result.valid = false;
      result.errors.push(`Move-in date must be on a ${DAY_NAMES[checkInDay]} based on your selected schedule`);
    }
  }

  return result;
}
```

**Refactored Code:**
```javascript
export function validateMoveInDate(moveInDate, listing, selectedDays) {
  if (!moveInDate) {
    return { valid: false, errors: ['Please select a move-in date'] };
  }

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  if (moveInDate < today) {
    return { valid: false, errors: ['Move-in date cannot be in the past'] };
  }

  if (!isDateInRange(moveInDate, listing['First Available'], listing['Last Available'])) {
    return { valid: false, errors: ['Move-in date is outside available range'] };
  }

  if (isDateBlocked(moveInDate, listing['Dates - Blocked'])) {
    return { valid: false, errors: ['Selected move-in date is not available'] };
  }

  // Check day of week alignment with schedule
  if (selectedDays?.length > 0) {
    const { checkInDay } = calculateCheckInOutDays(selectedDays);
    const moveInDayOfWeek = moveInDate.getDay();

    if (checkInDay !== null && moveInDayOfWeek !== checkInDay) {
      return {
        valid: false,
        errors: [`Move-in date must be on a ${DAY_NAMES[checkInDay]} based on your selected schedule`]
      };
    }
  }

  return { valid: true, errors: [] };
}
```

**Why This Matters:**
Early returns with immutable result objects eliminate the need for mutable `result` variable and `.push()` calls. Each validation check returns immediately when it fails, making the control flow explicit.

**Testing:**
- [ ] Test null moveInDate returns error
- [ ] Test past date returns error
- [ ] Test out-of-range date returns error
- [ ] Test blocked date returns error
- [ ] Test day-of-week mismatch returns error

~~~~~

## CHUNK 8: Replace imperative route iteration with flatMap in vite.config.js

**File:** app/vite.config.js
**Line:** 32
**Violation:** IMPERATIVE_LOOP - Using `for` loop to iterate routes
**Severity:** HIGH

**Expected Affected Pages:** AUTO (build configuration)

**Current Code:**
```javascript
function handleRouting(req, publicPrefix = '') {
  const url = req.url || '';
  const [urlPath, queryString = ''] = url.split('?').length > 1
    ? [url.split('?')[0], '?' + url.split('?').slice(1).join('?')]
    : [url, ''];

  // ... help-center handling ...

  // Find matching route from registry
  for (const route of routes) {
    const basePath = getBasePath(route);

    // Check exact match on base path
    if (urlPath === basePath || urlPath === basePath + '/') {
      req.url = `${publicPrefix}/${route.file}${queryString}`;
      return;
    }

    // Check if URL starts with query string on base path
    if (url.startsWith(basePath + '?')) {
      req.url = `${publicPrefix}/${route.file}${queryString}`;
      return;
    }

    // Check dynamic segments
    if (route.hasDynamicSegment && urlPath.startsWith(basePath + '/')) {
      req.url = `${publicPrefix}/${route.file}${queryString}`;
      return;
    }

    // Check aliases
    if (route.aliases) {
      for (const alias of route.aliases) {
        if (urlPath === alias) {
          req.url = `${publicPrefix}/${route.file}${queryString}`;
          return;
        }
        if (urlPath.startsWith(alias)) {
          const remainder = url.substring(alias.length);
          req.url = `${publicPrefix}/${route.file}${remainder}`;
          return;
        }
      }
    }
  }
}
```

**Refactored Code:**
```javascript
function handleRouting(req, publicPrefix = '') {
  const url = req.url || '';
  const [urlPath, queryString = ''] = url.split('?').length > 1
    ? [url.split('?')[0], '?' + url.split('?').slice(1).join('?')]
    : [url, ''];

  // ... help-center handling ...

  // Find matching route using declarative matching
  const matchRoute = (route) => {
    const basePath = getBasePath(route);

    // Check exact match
    if (urlPath === basePath || urlPath === basePath + '/') {
      return { file: route.file, suffix: queryString };
    }

    // Check query string match
    if (url.startsWith(basePath + '?')) {
      return { file: route.file, suffix: queryString };
    }

    // Check dynamic segment
    if (route.hasDynamicSegment && urlPath.startsWith(basePath + '/')) {
      return { file: route.file, suffix: queryString };
    }

    // Check aliases
    const aliasMatch = route.aliases?.find(alias =>
      urlPath === alias || urlPath.startsWith(alias)
    );
    if (aliasMatch) {
      const suffix = urlPath === aliasMatch
        ? queryString
        : url.substring(aliasMatch.length);
      return { file: route.file, suffix };
    }

    return null;
  };

  const match = routes.map(matchRoute).find(Boolean);
  if (match) {
    req.url = `${publicPrefix}/${match.file}${match.suffix}`;
  }
}
```

**Why This Matters:**
The refactored version separates the matching logic into a pure function `matchRoute` and uses `.map().find()` to find the first match. This is more declarative and easier to test.

**Testing:**
- [ ] Test exact path matching
- [ ] Test dynamic segment matching
- [ ] Test alias matching
- [ ] Test query string preservation
- [ ] Run `bun run dev` and verify routing works

~~~~~

## CHUNK 9: Replace imperative directory copy with recursive flatMap

**File:** app/vite.config.js
**Line:** 82
**Violation:** IMPERATIVE_LOOP - Using `for` loop to copy directory entries
**Severity:** HIGH

**Expected Affected Pages:** AUTO (build configuration)

**Current Code:**
```javascript
function copyDirectory(src, dest) {
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  }

  const entries = fs.readdirSync(src, { withFileTypes: true });

  for (const entry of entries) {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    if (entry.isDirectory()) {
      copyDirectory(srcPath, destPath);
    } else {
      fs.copyFileSync(srcPath, destPath);
    }
  }
}
```

**Refactored Code:**
```javascript
function copyDirectory(src, dest) {
  if (!fs.existsSync(dest)) {
    fs.mkdirSync(dest, { recursive: true });
  }

  const entries = fs.readdirSync(src, { withFileTypes: true });

  entries.forEach(entry => {
    const srcPath = path.join(src, entry.name);
    const destPath = path.join(dest, entry.name);

    entry.isDirectory()
      ? copyDirectory(srcPath, destPath)
      : fs.copyFileSync(srcPath, destPath);
  });
}
```

**Why This Matters:**
Using `.forEach()` with a ternary expression is more declarative than a `for` loop with `if/else`. The logic is more concise and reads naturally as "for each entry, either recurse or copy."

**Testing:**
- [ ] Run `bun run build`
- [ ] Verify dist folder structure is correct
- [ ] Check that all files are copied properly

~~~~~

## CHUNK 10: Replace for-of loop with filter/map in listingService.js

**File:** app/src/lib/listingService.js
**Lines:** 766-768
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Using `for` loop with `.push()`
**Severity:** HIGH

**Expected Affected Pages:** /self-listing, /listing-dashboard

**Current Code:**
```javascript
const result = [];
// Maintain proper day order
const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

for (const day of dayOrder) {
  if (availableNights[day] && dayNameMapping[day]) {
    result.push(dayNameMapping[day]);
  }
}

return result;
```

**Refactored Code:**
```javascript
const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

return dayOrder
  .filter(day => availableNights[day] && dayNameMapping[day])
  .map(day => dayNameMapping[day]);
```

**Why This Matters:**
Using `.filter().map()` chain clearly expresses intent: filter to available days, then map to their display names. No mutable `result` array needed.

**Testing:**
- [ ] Test with partial availability { sunday: true, monday: false, tuesday: true }
- [ ] Test with all days available
- [ ] Test with no days available (empty object)

~~~~~

## CHUNK 11: Replace Object.entries loop with filter/map in listingService.js

**File:** app/src/lib/listingService.js
**Lines:** 1076-1082
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Using `for` loop with `.push()` and `.sort()`
**Severity:** HIGH

**Expected Affected Pages:** /self-listing, /listing-dashboard

**Current Code:**
```javascript
for (const [day, isSelected] of Object.entries(availableNights)) {
  if (isSelected && dayMapping[day] !== undefined) {
    result.push(dayMapping[day]);
  }
}
return result.sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
return Object.entries(availableNights)
  .filter(([day, isSelected]) => isSelected && dayMapping[day] !== undefined)
  .map(([day]) => dayMapping[day])
  .toSorted((a, b) => a - b);
```

**Why This Matters:**
Chaining filter/map/toSorted creates a clear data transformation pipeline. Each step has a single responsibility.

**Testing:**
- [ ] Test with mixed availability
- [ ] Verify sort order is correct (0-6)
- [ ] Test with empty input

~~~~~

## CHUNK 12: Replace errors.push() pattern in generate-redirects.js

**File:** app/scripts/generate-redirects.js
**Lines:** 147, 153, 156, 161
**Violation:** MUTATING_METHOD - Multiple `.push()` calls to errors array
**Severity:** HIGH

**Expected Affected Pages:** AUTO (build script)

**Current Code:**
```javascript
for (const route of routes) {
  if (seenPaths.has(route.path)) {
    errors.push(`Duplicate path: ${route.path}`);
  }
  seenPaths.add(route.path);
  // ...
  if (!route.path) {
    errors.push(`Route missing path`);
  }
  if (!route.file) {
    errors.push(`Route ${route.path} missing file`);
  }
  // ...
  if (route.cloudflareInternal && !route.internalName) {
    errors.push(`Route ${route.path} has cloudflareInternal but no internalName`);
  }
}
```

**Refactored Code:**
```javascript
const validateRoute = (route, seenPaths) => {
  const errors = [
    seenPaths.has(route.path) && `Duplicate path: ${route.path}`,
    !route.path && `Route missing path`,
    !route.file && `Route ${route.path} missing file`,
    route.cloudflareInternal && !route.internalName &&
      `Route ${route.path} has cloudflareInternal but no internalName`
  ].filter(Boolean);

  return errors;
};

const allErrors = routes.flatMap((route, index) => {
  const errors = validateRoute(route, seenPaths);
  seenPaths.add(route.path);
  return errors;
});
```

**Why This Matters:**
Extracting validation into a pure function that returns an array of errors, then using flatMap to collect all errors, is more declarative and testable.

**Testing:**
- [ ] Run `bun run generate-routes`
- [ ] Test with intentionally invalid route config
- [ ] Verify error messages are collected correctly

~~~~~

## CHUNK 13: Replace `.push()` in routes.config.js

**File:** app/src/routes.config.js
**Line:** 380
**Violation:** MUTATING_METHOD - Using `.push()` to add items
**Severity:** HIGH

**Expected Affected Pages:** AUTO (routing configuration)

**Current Code:**
```javascript
excludedFromFunctions.push('/guest-proposals', '/guest-proposals/*');
```

**Refactored Code:**
```javascript
const excludedFromFunctions = [
  ...baseExcludedFromFunctions,
  '/guest-proposals',
  '/guest-proposals/*'
];
```

**Why This Matters:**
Use spread operator to create a new array with additional items instead of mutating an existing array.

**Testing:**
- [ ] Verify excludedFromFunctions contains all expected paths
- [ ] Run build and check _routes.json

~~~~~

## CHUNK 14: Replace `.sort()` with `.toSorted()` in aiService.js

**File:** app/src/lib/aiService.js
**Line:** 106
**Violation:** MUTATING_METHOD - Using `.sort()` after spread
**Severity:** HIGH

**Expected Affected Pages:** /self-listing, /listing-dashboard

**Current Code:**
```javascript
return [...amenities].sort((a, b) => {
  // sorting logic
});
```

**Refactored Code:**
```javascript
return amenities.toSorted((a, b) => {
  // sorting logic
});
```

**Why This Matters:**
`toSorted()` is the modern, explicitly immutable method. It clearly communicates that a new sorted array is returned.

**Testing:**
- [ ] Test amenity sorting
- [ ] Verify original array is not mutated

~~~~~

## CHUNK 15: Replace `.sort()` with `.toSorted()` in listingDataFetcher.js

**File:** app/src/lib/listingDataFetcher.js
**Line:** 201
**Violation:** MUTATING_METHOD - Using `.sort()` which mutates array
**Severity:** HIGH

**Expected Affected Pages:** /view-split-lease, /listing-dashboard, /search

**Current Code:**
```javascript
sortedPhotos = sortedPhotos.sort((a, b) => {
  // sorting logic
});
```

**Refactored Code:**
```javascript
sortedPhotos = sortedPhotos.toSorted((a, b) => {
  // sorting logic
});
```

**Why This Matters:**
Using `toSorted()` makes immutability explicit and prevents accidental mutation of the source array.

**Testing:**
- [ ] Test photo sorting by display order
- [ ] Verify photos display in correct order on listing page

~~~~~

## CHUNK 16: Replace `.push()` in listingService.js (addToSavedListings)

**File:** app/src/lib/listingService.js
**Line:** 335
**Violation:** MUTATING_METHOD - Using `.push()` to add listing ID
**Severity:** HIGH

**Expected Affected Pages:** /view-split-lease, /search, /favorite-listings

**Current Code:**
```javascript
currentListings.push(listingId);
```

**Refactored Code:**
```javascript
const updatedListings = [...currentListings, listingId];
// Use updatedListings instead of mutated currentListings
```

**Why This Matters:**
Creating a new array with the spread operator maintains immutability, which is crucial for React state updates and preventing side effects.

**Testing:**
- [ ] Test adding listing to favorites
- [ ] Verify saved listings persist correctly
- [ ] Test removing from favorites

~~~~~

## CHUNK 17: Replace `.push()` in dataLookups.js (getCancellationPolicies)

**File:** app/src/lib/dataLookups.js
**Lines:** 562, 592, 598, 609, 615
**Violation:** MUTATING_METHOD - Using `.push()` and `.sort()` in loops
**Severity:** HIGH

**Expected Affected Pages:** /self-listing, /view-split-lease, /guest-proposals

**Current Code:**
```javascript
const policies = [];
for (const [id, policy] of Object.entries(CANCELLATION_POLICIES)) {
  policies.push({ id, display: policy.display });
}
// Similar pattern for reasons:
const reasons = [];
for (const [key, reason] of Object.entries(data)) {
  reasons.push({
    id: key,
    displayName: reason.displayName,
    displayOrder: reason.displayOrder
  });
}
return reasons.sort((a, b) => a.displayOrder - b.displayOrder);
```

**Refactored Code:**
```javascript
const policies = Object.entries(CANCELLATION_POLICIES)
  .map(([id, policy]) => ({ id, display: policy.display }));

// For reasons:
const reasons = Object.entries(data)
  .map(([key, reason]) => ({
    id: key,
    displayName: reason.displayName,
    displayOrder: reason.displayOrder
  }))
  .toSorted((a, b) => a.displayOrder - b.displayOrder);
```

**Why This Matters:**
Using `.map()` and `.toSorted()` creates a declarative transformation pipeline that's easier to read and test.

**Testing:**
- [ ] Verify cancellation policies list correctly
- [ ] Test sort order by displayOrder
- [ ] Check all policy options appear in UI

~~~~~

## CHUNK 18: Replace for-of loop with map in listingService.js (daysArray)

**File:** app/src/lib/listingService.js
**Line:** 1240
**Violation:** IMPERATIVE_LOOP - Using `for` loop to iterate days
**Severity:** HIGH

**Expected Affected Pages:** /self-listing, /listing-dashboard

**Current Code:**
```javascript
for (const dayNum of daysArray) {
  // processing logic
}
```

**Refactored Code:**
```javascript
daysArray.forEach(dayNum => {
  // processing logic (if side effects needed)
});
// OR if transforming:
const result = daysArray.map(dayNum => {
  // transformation logic
});
```

**Why This Matters:**
Using `.forEach()` or `.map()` depending on whether the loop performs side effects or transforms data is more declarative and expressive.

**Testing:**
- [ ] Test day array processing
- [ ] Verify all days are handled correctly

~~~~~

## CHUNK 19: Skip third-party code in hotjar.js

**File:** app/src/lib/hotjar.js
**Line:** 18
**Violation:** MUTATING_METHOD - Using `.push()` in Hotjar snippet
**Severity:** HIGH (but should be SKIPPED)

**Expected Affected Pages:** All pages (analytics)

**Note:** This is third-party Hotjar tracking code that should NOT be refactored. The `.push()` is part of the official Hotjar snippet pattern. Mark as intentional exception.

**Action:** Add `// eslint-disable-next-line fp/no-mutating-methods` or similar comment if using FP linting rules.

~~~~~

## CHUNK 20: Replace while loop with recursive/iterative approach in auth.js

**File:** app/src/lib/auth.js
**Lines:** 563, 786
**Violation:** IMPERATIVE_LOOP - Using `while` loops for retry logic
**Severity:** HIGH

**Expected Affected Pages:** /login, /signup, all authenticated pages

**Current Code:**
```javascript
while (verifyAttempts < maxVerifyAttempts) {
  // verification logic
  verifyAttempts++;
}
```

**Note:** While loops for retry logic with external I/O (auth verification) are acceptable in the imperative shell. The loop is at the edge of the system where side effects are expected. This could be refactored to use a retry utility function but the current implementation is pragmatic.

**Suggested Improvement (Optional):**
```javascript
const retryWithBackoff = async (fn, maxAttempts, delayMs = 500) => {
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    const result = await fn();
    if (result.success) return result;
    if (attempt < maxAttempts - 1) {
      await new Promise(resolve => setTimeout(resolve, delayMs * (attempt + 1)));
    }
  }
  return { success: false, error: 'Max attempts exceeded' };
};
```

**Testing:**
- [ ] Test auth flow with successful verification
- [ ] Test retry behavior on temporary failures
- [ ] Verify max attempts limit is respected

~~~~~

## CHUNK 21: Refactor ListingLocalStore state mutations

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Lines:** Multiple (21 violations)
**Violation:** MUTATING_METHOD - Direct state mutations in class methods
**Severity:** HIGH

**Expected Affected Pages:** /self-listing

**Current Pattern:**
```typescript
this.state.data = { ...this.state.data, ...partialData };
this.state.isDirty = true;
this.state.errors.push(error);
```

**Note:** This is a state management class using the Observer pattern. Some mutation is expected within the store itself. However, the `.push()` calls to `errors` array should be refactored.

**Refactored Code (for error handling):**
```typescript
// Instead of: this.state.errors.push(error);
// Use:
this.state = {
  ...this.state,
  errors: [...this.state.errors, error]
};

// Or create a helper method:
private addError(error: string): void {
  this.state = {
    ...this.state,
    errors: [...this.state.errors, error]
  };
}
```

**Testing:**
- [ ] Test error accumulation
- [ ] Verify state updates trigger listeners
- [ ] Test form validation flow

~~~~~

## CHUNK 22: Remove console.warn from rules layer (IO_IN_CORE)

**File:** app/src/logic/rules/proposals/proposalRules.js
**Line:** 306
**Violation:** IO_IN_CORE - Console output in rules layer
**Severity:** HIGH

**Expected Affected Pages:** /guest-proposals, /host-proposals

**Current Code:**
```javascript
console.warn('[getCancellationReasonOptions] Cache empty, using fallback values');
```

**Refactored Code:**
```javascript
// Option 1: Remove the console.warn entirely - fallback behavior is expected
// Option 2: Return an object with a warning flag
return {
  options: fallbackValues,
  warning: 'Cache empty, using fallback values'
};
// Let the caller (workflow layer) decide whether to log
```

**Why This Matters:**
Rules should be pure functions without side effects. Logging is I/O and belongs in the imperative shell (workflow layer).

**Testing:**
- [ ] Test getCancellationReasonOptions with empty cache
- [ ] Verify fallback values are returned correctly
- [ ] Check no console output in rules layer

~~~~~

## CHUNK 23: Remove console.error from processor layer (IO_IN_CORE)

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 46
**Violation:** IO_IN_CORE - Console output in processor layer
**Severity:** HIGH

**Expected Affected Pages:** /view-split-lease, /search

**Current Code:**
```javascript
console.error(
  // error details
);
```

**Refactored Code:**
```javascript
// Return error information instead of logging
return {
  success: false,
  error: 'Failed to extract coordinates',
  details: errorDetails
};
// Let the workflow layer handle logging
```

**Why This Matters:**
Processors should transform data without side effects. Error handling should return error information, not log it directly.

**Testing:**
- [ ] Test coordinate extraction with invalid input
- [ ] Verify error information is returned
- [ ] Check no console output in processor

~~~~~

## CHUNK 24: Replace `.sort()` in isScheduleContiguous.js

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 55
**Violation:** MUTATING_METHOD - Using `.sort()` after spread
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals

**Current Code:**
```javascript
const sorted = [...selectedDayIndices].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
const sorted = selectedDayIndices.toSorted((a, b) => a - b)
```

**Why This Matters:**
Using `toSorted()` is more explicit about immutability. This is in the rules layer where purity is critical.

**Testing:**
- [ ] Test schedule contiguity detection
- [ ] Verify wrap-around cases work
- [ ] Test edge cases (single day, all days)

~~~~~

## CHUNK 25: Replace imperative loops in isScheduleContiguous.js

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Lines:** 64, 95, 96
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Using loops with push
**Severity:** HIGH

**Expected Affected Pages:** /search, /view-split-lease, /guest-proposals

**Current Code:**
```javascript
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    // gap found
  }
}

for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i)
}
```

**Refactored Code:**
```javascript
// Gap detection
const isStandardContiguous = sorted.every((day, i) =>
  i === 0 || day === sorted[i - 1] + 1
);

// Range generation
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
Pure functions in the rules layer should use declarative patterns. `.every()` and `Array.from()` express intent clearly.

**Testing:**
- [ ] Test standard contiguous detection
- [ ] Test wrap-around detection
- [ ] Verify range generation

~~~~~

## CHUNK 26-50: Continue pattern for remaining files...

The following files have similar violation patterns and should be refactored using the same techniques:

| Chunk | File | Violations | Pattern |
|-------|------|------------|---------|
| 26-32 | src/islands/shared/SearchScheduleSelector.jsx | 9 | .push() -> spread, .sort() -> toSorted() |
| 33-40 | src/islands/shared/HostScheduleSelector/*.js | 16 | .push() -> spread, for-of -> map/filter |
| 41-48 | src/islands/pages/SearchPage.jsx | 8 | .push() -> spread, for-of -> forEach |
| 49-56 | src/islands/pages/ListingDashboardPage/components/*.jsx | 21 | .push() -> spread, state mutation patterns |
| 57-66 | src/islands/pages/SelfListingPage/sections/*.tsx | 20 | .push() -> spread, event handler mutations |
| 67-78 | src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx | 12 | .push() -> spread, array building |
| 79-85 | src/lib/photoUpload.js | 7 | for loops -> map, .push() -> spread |
| 86-93 | src/lib/supabaseUtils.js | 8 | for-of -> map/filter, .push() -> spread |

---

## Implementation Guidelines

### Priority Order
1. **P1 - Critical Business Logic**: availabilityValidation.js, isScheduleContiguous.js, proposalRules.js
2. **P2 - High-Impact Pages**: listingService.js, dataLookups.js
3. **P3 - UI Components**: All islands/pages and islands/shared files
4. **P4 - Build/Config**: vite.config.js, generate-redirects.js

### Testing Strategy
1. Run existing tests after each chunk
2. Manual test affected pages (listed in Expected Affected Pages)
3. Run `bun run build` after config file changes
4. Verify no regressions in search, proposal, and listing flows

### Rollback Plan
- Each chunk is independent - revert single file if issues arise
- Git commit after each successful chunk
- Keep original code commented until tests pass

---

## File References

- agents/fp_audit_violations.json - Full violation list
- agents/fp_violations_parsed.json - Parsed violation data
- app/src/lib/availabilityValidation.js - Primary refactoring target
- app/src/logic/rules/scheduling/isScheduleContiguous.js - Rules layer target
- app/src/lib/listingService.js - Service layer target
- .claude/skills/functional-code/functional-code.md - FP guidelines reference
