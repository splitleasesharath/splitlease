# Functional Programming Refactoring Plan

Date: 2026-01-13
Target: agents/20260113173055_fp_audit_violations.json
Severity Filter: high

~~~~~

## CHUNK 1: Replace imperative loop in isScheduleContiguous.js:64

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 64
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /host-proposals, /guest-proposals

**Current Code:**
```javascript
  // Check for standard contiguous sequence (no wrap around)
  let isStandardContiguous = true
  for (let i = 1; i < sorted.length; i++) {
    if (sorted[i] !== sorted[i - 1] + 1) {
      isStandardContiguous = false
      break
    }
  }

  if (isStandardContiguous) {
    return true
  }
```

**Refactored Code:**
```javascript
  // Check for standard contiguous sequence (no wrap around)
  const isStandardContiguous = sorted.every((day, i) => 
    i === 0 || day === sorted[i - 1] + 1
  )

  if (isStandardContiguous) {
    return true
  }
```

**Why This Matters:**
Declarative array methods like `.every()` express the intent of the check more clearly than an imperative loop with manual state tracking and break statements. This reduces the surface area for off-by-one errors.

**Testing:**
- [ ] Verify contiguous selections (e.g., Mon-Wed) return true.
- [ ] Verify non-contiguous selections (e.g., Mon, Wed) return false.
- [ ] Ensure single-day selections still work correctly.

~~~~~

## CHUNK 2: Replace imperative range loop in isScheduleContiguous.js:95

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 95
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /host-proposals, /guest-proposals

**Current Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = []
    for (let i = minNotSelected; i <= maxNotSelected; i++) {
      expectedNotSelected.push(i)
    }
```

**Refactored Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = Array.from(
      { length: maxNotSelected - minNotSelected + 1 },
      (_, i) => minNotSelected + i
    )
```

**Why This Matters:**
Using `Array.from` to generate a range is a declarative approach that avoids manual loop management and temporary mutable variables, making the code more predictable and easier to reason about.

**Testing:**
- [ ] Verify wrap-around contiguous selections (e.g., Sat-Mon) return true.
- [ ] Verify wrap-around non-contiguous selections return false.

~~~~~

## CHUNK 3: Replace .push() in isScheduleContiguous.js:96

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 96
**Violation:** MUTATING_METHOD - Using mutating array method
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /host-proposals, /guest-proposals

**Current Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = []
    for (let i = minNotSelected; i <= maxNotSelected; i++) {
      expectedNotSelected.push(i)
    }
```

**Refactored Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = Array.from(
      { length: maxNotSelected - minNotSelected + 1 },
      (_, i) => minNotSelected + i
    )
```

**Why This Matters:**
Mutation (via `.push()`) makes state tracking harder and can lead to side effects. Constructing the array in a single declarative step using `Array.from` ensures the data is created immutably.

**Testing:**
- [ ] Verify wrap-around logic works as expected.
- [ ] Check edge cases with 0 or 6 selected days.

~~~~~

## CHUNK 4: Remove I/O (console.error) from extractListingCoordinates.js:46

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 46
**Violation:** IO_IN_CORE - I/O operation found in core business logic
**Severity:** High

**Expected Affected Pages:** /search, /listing-dashboard

**Current Code:**
```javascript
    try {
      parsedSlightlyDifferent = JSON.parse(locationSlightlyDifferent)
    } catch (error) {
      console.error(
        '❌ extractListingCoordinates: Failed to parse Location - slightly different address:',
        {
          listingId,
          rawValue: locationSlightlyDifferent,
          error: error.message
        }
      )
      parsedSlightlyDifferent = null
    }
```

**Refactored Code:**
```javascript
    try {
      parsedSlightlyDifferent = JSON.parse(locationSlightlyDifferent)
    } catch (error) {
      // In a functional core, we avoid side effects like console.error.
      // The error is handled by returning null, letting the caller decide how to log.
      parsedSlightlyDifferent = null
    }
```

**Why This Matters:**
Pure business logic (processors) should not perform I/O like logging. This makes the code truly pure, easier to test in isolation, and follows the "Functional Core, Imperative Shell" pattern.

**Testing:**
- [ ] Verify that invalid JSON in `locationSlightlyDifferent` still results in `null` being returned.
- [ ] Ensure the application doesn't crash when a parse error occurs.

~~~~~

## CHUNK 5: Remove I/O (console.error) from extractListingCoordinates.js:62

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 62
**Violation:** IO_IN_CORE - I/O operation found in core business logic
**Severity:** High

**Expected Affected Pages:** /search, /listing-dashboard

**Current Code:**
```javascript
    try {
      parsedAddress = JSON.parse(locationAddress)
    } catch (error) {
      console.error('❌ extractListingCoordinates: Failed to parse Location - Address:', {
        listingId,
        rawValue: locationAddress,
        error: error.message
      })
      parsedAddress = null
    }
```

**Refactored Code:**
```javascript
    try {
      parsedAddress = JSON.parse(locationAddress)
    } catch (error) {
      // Side effects like logging should be handled at the edges (workflows/handlers)
      parsedAddress = null
    }
```

**Why This Matters:**
Separating logic from side effects (like logging) ensures that core processors are predictable and don't depend on the environment's global `console` object.

**Testing:**
- [ ] Verify that invalid JSON in `locationAddress` still results in fallback or `null`.

~~~~~

## CHUNK 6: Remove I/O (console.warn) from extractListingCoordinates.js:98

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 98
**Violation:** IO_IN_CORE - I/O operation found in core business logic
**Severity:** High

**Expected Affected Pages:** /search, /listing-dashboard

**Current Code:**
```javascript
  // No Fallback: Return null if no valid coordinates found
  console.warn('⚠️ extractListingCoordinates: No valid coordinates found for listing:', {
    listingId,
    hasSlightlyDifferent: !!parsedSlightlyDifferent,
    hasMainAddress: !!parsedAddress
  })

  return null
```

**Refactored Code:**
```javascript
  // No Fallback: Return null if no valid coordinates found
  // The caller (e.g., search workflow) is responsible for logging missing data.
  return null
```

**Why This Matters:**
A pure function should only return data. By removing the `console.warn`, we make the function pure and allow the calling workflow to handle missing data according to its own logging policy.

**Testing:**
- [ ] Verify listings without coordinates are still handled correctly by the caller.

~~~~~

## CHUNK 7: Remove I/O (console.warn) from processUserData.js:58

**File:** app/src/logic/processors/user/processUserData.js
**Line:** 58
**Violation:** IO_IN_CORE - I/O operation found in core business logic
**Severity:** High

**Expected Affected Pages:** /account-profile, /messages, AUTO

**Current Code:**
```javascript
    } else {
      // Use a default for users without any name fields
      fullName = 'Guest User'
      console.warn(`processUserData: User ${rawUser._id} has no name fields, using default`)
    }
```

**Refactored Code:**
```javascript
    } else {
      // Use a default for users without any name fields
      fullName = 'Guest User'
    }
```

**Why This Matters:**
Core data processors should be free of side effects. Logging is a side effect that belongs in the application's "shell" (workflows or UI components), not in the data transformation logic.

**Testing:**
- [ ] Verify that users with no name fields still default to "Guest User".
- [ ] Check display in Profile and Messages pages for such users.

~~~~~

## CHUNK 8: Use toSorted() in calculateCheckInOutDays.js:50

**File:** app/src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 50
**Violation:** MUTATING_METHOD - Using mutating array sort/reverse
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search

**Current Code:**
```javascript
  const sorted = [...selectedDays].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
  const sorted = selectedDays.toSorted((a, b) => a - b)
```

**Why This Matters:**
While `[...arr].sort()` is safe, `toSorted()` is the native, declarative way to perform an immutable sort. It clearly signals that the original array is not being modified and avoids the need for manual shallow copies.

**Testing:**
- [ ] Verify check-in/out calculation for standard selections.
- [ ] Verify check-in/out calculation for wrapped selections.

~~~~~

## CHUNK 9: Replace imperative loop in calculateCheckInOutDays.js:59

**File:** app/src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 59
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search

**Current Code:**
```javascript
    // Find gap to determine actual start/end
    let gapIndex = -1
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] !== sorted[i - 1] + 1) {
        gapIndex = i
        break
      }
    }
```

**Refactored Code:**
```javascript
    // Find gap to determine actual start/end
    const gapIndex = sorted.findIndex((day, i) => 
      i > 0 && day !== sorted[i - 1] + 1
    )
```

**Why This Matters:**
Using `.findIndex()` is more declarative than a `for` loop with a mutable `gapIndex` and a `break` statement. It expresses the intent of "finding the first occurrence of a gap" directly.

**Testing:**
- [ ] Verify gap detection in wrapped selections (e.g., [0, 5, 6] -> gap at index 1).
- [ ] Ensure non-wrapped selections still work correctly.

~~~~~

## CHUNK 10: Use toSorted() in calculateNextAvailableCheckIn.js:54

**File:** app/src/logic/calculators/scheduling/calculateNextAvailableCheckIn.js
**Line:** 54
**Violation:** MUTATING_METHOD - Using mutating array sort/reverse
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /host-proposals

**Current Code:**
```javascript
  // Get the first selected day (check-in day of week)
  // Days should already be sorted, but sort to be safe
  const sortedDays = [...selectedDayIndices].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
  // Get the first selected day (check-in day of week)
  // Days should already be sorted, but sort to be safe
  const sortedDays = selectedDayIndices.toSorted((a, b) => a - b)
```

**Why This Matters:**
Native immutable methods like `toSorted()` improve code readability and ensure that the original data remains untouched, adhering to the principle of immutability.

**Testing:**
- [ ] Verify next available check-in date calculation for various weekly patterns.
- [ ] Ensure it correctly identifies the next matching day of week from the `minDate`.
