# Functional Programming Refactoring Plan

Date: 2026-01-14
Target: agents/20260114055230_fp_audit_violations.json
Severity Filter: all

~~~~~

## CHUNK 1: Refactor Imperative Validation in listingLocalStore.ts

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 387
**Violation:** MUTATING_METHOD - Using mutating array method
**Severity:** High

**Expected Affected Pages:** /list-with-us, /self-listing

**Current Code:**
```typescript
  validateForSubmission(): string[] {
    const errors: string[] = [];
    const data = this.state.data;

    // Section 1: Space Snapshot
    if (!data.spaceSnapshot.listingName) {
      errors.push('Listing name is required');
    }
    if (!data.spaceSnapshot.typeOfSpace) {
      errors.push('Type of space is required');
    }
    // ... (many more push calls)
    return errors;
  }
```

**Refactored Code:**
```typescript
  validateForSubmission(): string[] {
    const data = this.state.data;
    
    return [
      // Section 1: Space Snapshot
      !data.spaceSnapshot.listingName && 'Listing name is required',
      !data.spaceSnapshot.typeOfSpace && 'Type of space is required',
      !data.spaceSnapshot.typeOfKitchen && 'Type of kitchen is required',
      !data.spaceSnapshot.typeOfParking && 'Type of parking is required',
      (!data.spaceSnapshot.address.fullAddress || !data.spaceSnapshot.address.validated) && 'Valid NYC address is required',

      // Section 2: Features
      data.features.amenitiesInsideUnit.length === 0 && 'At least one amenity inside unit is required',
      !data.features.descriptionOfLodging && 'Description of lodging is required',

      // Section 3: Lease Styles
      !data.leaseStyles.rentalType && 'Rental type is required',
      data.leaseStyles.rentalType === 'Nightly' && (!data.leaseStyles.availableNights || !Object.values(data.leaseStyles.availableNights).some((v) => v)) && 'At least one available night must be selected',
      data.leaseStyles.rentalType === 'Weekly' && !data.leaseStyles.weeklyPattern && 'Weekly pattern is required',

      // Section 4: Pricing
      data.pricing.damageDeposit < 500 && 'Damage deposit must be at least $500',
      data.leaseStyles.rentalType === 'Monthly' && !data.pricing.monthlyCompensation && 'Monthly compensation is required',
      data.leaseStyles.rentalType === 'Weekly' && !data.pricing.weeklyCompensation && 'Weekly compensation is required',
      data.leaseStyles.rentalType === 'Nightly' && !data.pricing.nightlyPricing?.oneNightPrice && 'Nightly pricing is required',

      // Section 5: Rules
      !data.rules.cancellationPolicy && 'Cancellation policy is required',
      !data.rules.checkInTime && 'Check-in time is required',
      !data.rules.checkOutTime && 'Check-out time is required',

      // Section 6: Photos
      data.photos.photos.length < data.photos.minRequired && `At least ${data.photos.minRequired} photos are required`
    ].filter(Boolean) as string[];
  }
```

**Why This Matters:**
Replacing imperative `push` calls with a declarative array construction makes the validation logic easier to read and test. It eliminates intermediate state mutation and clearly defines the rules as a list of conditions.

**Testing:**
- [ ] Verify validation errors appear correctly when fields are missing
- [ ] Verify no errors are returned when all fields are valid
- [ ] Check specific conditional validations (e.g. Nightly rental type)

~~~~~

## CHUNK 2: Refactor Imperative Name Extraction Loop in AiSignupMarketReport.jsx

**File:** app/src/islands/shared/AiSignupMarketReport/AiSignupMarketReport.jsx
**Line:** 47
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /ai-market-report (or pages using this modal)

**Current Code:**
```javascript
  for (const pattern of namePatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      // Clean up and return the first name only
      const fullName = match[1].trim();
      const firstName = fullName.split(/\s+/)[0];
      return firstName;
    }
  }
```

**Refactored Code:**
```javascript
  const matchedName = namePatterns
    .map(pattern => text.match(pattern))
    .find(match => match && match[1]);

  if (matchedName) {
    const fullName = matchedName[1].trim();
    return fullName.split(/\s+/)[0];
  }
```

**Why This Matters:**
Using `map` and `find` is more declarative than an imperative `for` loop with early return. It clearly expresses the intent: find the first pattern that matches and extract the name.

**Testing:**
- [ ] Test name extraction with various text inputs ("I'm John", "My name is Jane")
- [ ] Verify fallback behavior when no name is found

~~~~~

## CHUNK 3: Refactor Imperative Phone Extraction Loop in AiSignupMarketReport.jsx

**File:** app/src/islands/shared/AiSignupMarketReport/AiSignupMarketReport.jsx
**Line:** 111
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /ai-market-report

**Current Code:**
```javascript
  for (const pattern of standardPhonePatterns) {
    const match = text.match(pattern);
    if (match) return match[0];
  }
```

**Refactored Code:**
```javascript
  const standardMatch = standardPhonePatterns
    .map(pattern => text.match(pattern))
    .find(match => match);
  
  if (standardMatch) return standardMatch[0];
```

**Why This Matters:**
Declarative array methods improve readability and maintainability.

**Testing:**
- [ ] Test phone extraction with various formats
- [ ] Verify correct extraction order

~~~~~

## CHUNK 4: Refactor Imperative Explicit Phone Loop in AiSignupMarketReport.jsx

**File:** app/src/islands/shared/AiSignupMarketReport/AiSignupMarketReport.jsx
**Line:** 123
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /ai-market-report

**Current Code:**
```javascript
  for (const pattern of explicitPhonePatterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      return match[1];
    }
  }
```

**Refactored Code:**
```javascript
  const explicitMatch = explicitPhonePatterns
    .map(pattern => text.match(pattern))
    .find(match => match && match[1]);

  if (explicitMatch) return explicitMatch[1];
```

**Why This Matters:**
Consistent use of declarative patterns across the codebase.

**Testing:**
- [ ] Test explicit phone extraction ("call me at ...")
- [ ] Verify priority over standard patterns

~~~~~

## CHUNK 5: Refactor Topic Detection Loop in AiSignupMarketReport.jsx

**File:** app/src/islands/shared/AiSignupMarketReport/AiSignupMarketReport.jsx
**Line:** 680
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /ai-market-report

**Current Code:**
```javascript
  const detectedTopics = [];

  for (const topic of FREEFORM_TOPICS) {
    const isDetected = topic.patterns.some(pattern => pattern.test(text));
    if (isDetected) {
      detectedTopics.push(topic.id);
    }
  }

  return detectedTopics;
```

**Refactored Code:**
```javascript
  return FREEFORM_TOPICS
    .filter(topic => topic.patterns.some(pattern => pattern.test(text)))
    .map(topic => topic.id);
```

**Why This Matters:**
This is a classic case where `filter` and `map` (or flatMap) are superior to `for` loops with `push`. It makes the transformation from topics to detected IDs explicit and immutable.

**Testing:**
- [ ] Verify topics are detected correctly based on keywords
- [ ] Check empty text returns empty array

~~~~~

## CHUNK 6: Replace Exception with Result in bubbleAPI.js (createListingInCode)

**File:** app/src/lib/bubbleAPI.js
**Line:** 44
**Violation:** EXCEPTION_FOR_FLOW - Exception used for validation/expected errors
**Severity:** Medium

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  if (!listingName?.trim()) {
    throw new Error('Listing name is required');
  }
```

**Refactored Code:**
```javascript
  if (!listingName?.trim()) {
    return { success: false, error: 'Listing name is required' };
  }
```

**Why This Matters:**
Using return values for expected validation errors is more type-safe and predictable than throwing exceptions. Note: Callers of `createListingInCode` must be updated to handle the result object.

**Testing:**
- [ ] Verify calling with empty name returns error object instead of throwing
- [ ] Update call sites to check `.success` property

~~~~~

## CHUNK 7: Replace Exception with Result in bubbleAPI.js (getListingById)

**File:** app/src/lib/bubbleAPI.js
**Line:** 88
**Violation:** EXCEPTION_FOR_FLOW - Exception used for validation/expected errors
**Severity:** Medium

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  if (!listingId?.trim()) {
    throw new Error('Listing ID is required');
  }
```

**Refactored Code:**
```javascript
  if (!listingId?.trim()) {
    return { success: false, error: 'Listing ID is required' };
  }
```

**Why This Matters:**
Consistent error handling pattern.

**Testing:**
- [ ] Verify calling with empty ID returns error object
- [ ] Update call sites

~~~~~

## CHUNK 8: Replace Exception with Result in bubbleAPI.js (uploadListingPhotos)

**File:** app/src/lib/bubbleAPI.js
**Line:** 135
**Violation:** EXCEPTION_FOR_FLOW - Exception used for validation/expected errors
**Severity:** Medium

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  if (!listingId?.trim()) {
    throw new Error('Listing ID is required');
  }

  if (!Array.isArray(photos) || photos.length === 0) {
    throw new Error('At least one photo is required');
  }
```

**Refactored Code:**
```javascript
  if (!listingId?.trim()) {
    return { success: false, error: 'Listing ID is required' };
  }

  if (!Array.isArray(photos) || photos.length === 0) {
    return { success: false, error: 'At least one photo is required' };
  }
```

**Why This Matters:**
Validation failures are expected outcomes, not exceptional system states.

**Testing:**
- [ ] Verify validation for ID and photos
- [ ] Update call sites

~~~~~

## CHUNK 9: Replace Exception with Result in bubbleAPI.js (submitListingFull)

**File:** app/src/lib/bubbleAPI.js
**Line:** 190
**Violation:** EXCEPTION_FOR_FLOW - Exception used for validation/expected errors
**Severity:** Medium

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  if (!listingId?.trim()) {
    throw new Error('Listing ID is required');
  }

  if (!userEmail?.trim()) {
    throw new Error('User email is required');
  }

  if (!listingData || typeof listingData !== 'object') {
    throw new Error('Listing data is required');
  }
```

**Refactored Code:**
```javascript
  if (!listingId?.trim()) {
    return { success: false, error: 'Listing ID is required' };
  }

  if (!userEmail?.trim()) {
    return { success: false, error: 'User email is required' };
  }

  if (!listingData || typeof listingData !== 'object') {
    return { success: false, error: 'Listing data is required' };
  }
```

**Why This Matters:**
Completes the pattern for `bubbleAPI.js`.

**Testing:**
- [ ] Verify all validation checks
- [ ] Update call sites

~~~~~

## CHUNK 10: Refactor Imperative Loop in prepareListingSubmission.ts

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Line:** 93
**Violation:** MUTATING_METHOD - Using mutating array method
**Severity:** High

**Expected Affected Pages:** /list-with-us

**Current Code:**
```typescript
  const result: string[] = [];
  if (nights.sunday) result.push('sunday');
  if (nights.monday) result.push('monday');
  if (nights.tuesday) result.push('tuesday');
  if (nights.wednesday) result.push('wednesday');
  if (nights.thursday) result.push('thursday');
  if (nights.friday) result.push('friday');
  if (nights.saturday) result.push('saturday');
  return result;
```

**Refactored Code:**
```typescript
  return [
    nights.sunday && 'sunday',
    nights.monday && 'monday',
    nights.tuesday && 'tuesday',
    nights.wednesday && 'wednesday',
    nights.thursday && 'thursday',
    nights.friday && 'friday',
    nights.saturday && 'saturday',
  ].filter(Boolean) as string[];
```

**Why This Matters:**
Declarative array construction is cleaner and less error-prone than imperative pushing.

**Testing:**
- [ ] Verify correct days are returned based on input object
- [ ] Verify empty array if no days selected

~~~~~

## CHUNK 11: Refactor Validation Logic in prepareListingSubmission.ts

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Line:** 270
**Violation:** MUTATING_METHOD - Using mutating array method
**Severity:** High

**Expected Affected Pages:** /list-with-us

**Current Code:**
```typescript
  const errors: string[] = [];
  if (!payload.Name) errors.push('Name is required');
  if (!payload['Type of Space']) errors.push('Type of Space is required');
  if (!payload.Address) errors.push('Address is required');
  // ... more pushes
  return errors;
```

**Refactored Code:**
```typescript
  return [
    !payload.Name && 'Name is required',
    !payload['Type of Space'] && 'Type of Space is required',
    !payload.Address && 'Address is required',
    !payload['Rental Type'] && 'Rental Type is required',
    // Add other checks here following the same pattern
  ].filter(Boolean) as string[];
```

**Why This Matters:**
Same principle as Chunk 1: declarative validation.

**Testing:**
- [ ] Verify validation logic remains correct

~~~~~

## CHUNK 12: Refactor Mutating Sort in listingLocalStore.ts

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 198
**Violation:** MUTATING_METHOD - Using mutating array sort/reverse
**Severity:** High

**Expected Affected Pages:** /list-with-us

**Current Code:**
```typescript
    this.state.data.completedSections = Array.from(completedSections).sort();
```

**Refactored Code:**
```typescript
    this.state.data.completedSections = [...completedSections].sort((a, b) => a - b);
```

**Why This Matters:**
`Array.from` creates a new array, so `sort()` technically mutates that new array, which is fine here, but explicit numeric sort `(a, b) => a - b` is safer for numbers than default string sort. Also `toSorted()` is preferred if available, but spread + sort is standard.

**Testing:**
- [ ] Verify sections are sorted numerically

~~~~~
