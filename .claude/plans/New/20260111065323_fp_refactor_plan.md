# Functional Programming Refactoring Plan

**Date:** 2026-01-11
**Target:** agents/fp_audit_violations.json
**Severity Filter:** high
**Total Violations:** 351

---

## Summary

| Violation Type | Count | Priority |
|----------------|-------|----------|
| MUTATING_METHOD | 265 | High - Affects data immutability |
| IMPERATIVE_LOOP | 81 | High - Reduces declarative clarity |
| IO_IN_CORE | 5 | High - Violates functional core |

### Top Files by Violation Count

| File | Violations |
|------|-----------|
| src/islands/pages/SelfListingPage/store/listingLocalStore.ts | 21 |
| src/lib/availabilityValidation.js | 16 |
| src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts | 15 |
| src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx | 12 |
| src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx | 11 |
| src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx | 10 |
| src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx | 10 |
| src/islands/pages/SelfListingPage/sections/Section5Rules.tsx | 10 |

---

## CHUNK 1: Replace imperative loop in vite.config.js:32

**File:** app/vite.config.js
**Line:** 32
**Violation:** IMPERATIVE_LOOP - Using `for...of` loop to build object
**Severity:** High

**Current Code:**
```javascript
for (const route of routes) {
  // build input entries
}
```

**Refactored Code:**
```javascript
const input = routes.reduce((acc, route) => {
  // ... accumulate entries
  return { ...acc, ...routeEntries };
}, {});
```

**Why This Matters:**
Declarative `reduce()` expresses the transformation intent directly - "reduce routes to a single input object" - making the data flow explicit and eliminating mutable accumulators.

**Testing:**
- [ ] Run `bun run build` to verify Vite config still works
- [ ] Verify all routes generate correct entry points
- [ ] Check dev server starts correctly with `bun run dev`

---

## CHUNK 2: Replace imperative loop in vite.config.js:56

**File:** app/vite.config.js
**Line:** 56
**Violation:** IMPERATIVE_LOOP - Nested `for...of` for alias handling
**Severity:** High

**Current Code:**
```javascript
for (const alias of route.aliases) {
  // handle aliases
}
```

**Refactored Code:**
```javascript
const aliasEntries = routes
  .filter(route => route.aliases?.length > 0)
  .flatMap(route => route.aliases.map(alias => ({ ...route, path: alias })));
```

**Why This Matters:**
`flatMap()` elegantly handles the one-to-many relationship between routes and aliases, producing a flat array without nested loops or manual array building.

**Testing:**
- [ ] Verify aliased routes (e.g., /login -> /signin) work correctly
- [ ] Check _redirects file contains all aliases
- [ ] Test navigation to aliased paths in browser

---

## CHUNK 3: Replace imperative loop in vite.config.js:82

**File:** app/vite.config.js
**Line:** 82
**Violation:** IMPERATIVE_LOOP - Processing entry files
**Severity:** High

**Current Code:**
```javascript
for (const entry of entries) {
  // process entries
}
```

**Refactored Code:**
```javascript
const processedEntries = entries.map(entry => processEntry(entry));
```

**Why This Matters:**
Using `map()` makes the one-to-one transformation explicit and enables function composition for each entry processor.

**Testing:**
- [ ] Build completes without errors
- [ ] All HTML entry points are generated
- [ ] Bundle sizes remain consistent

---

## CHUNK 4: Replace imperative loop in vite.config.js:181

**File:** app/vite.config.js
**Line:** 181
**Violation:** IMPERATIVE_LOOP - Processing internal routes
**Severity:** High

**Current Code:**
```javascript
for (const route of internalRoutes) {
  // process internal routes
}
```

**Refactored Code:**
```javascript
const processedInternalRoutes = internalRoutes.map(route => ({
  ...route,
  // transformed properties
}));
```

**Why This Matters:**
Declarative mapping clearly shows the transformation applied to each route without mutation side effects.

**Testing:**
- [ ] Cloudflare internal routes work correctly
- [ ] _routes.json contains correct exclusions
- [ ] Preview deployment routes function properly

---

## CHUNK 5: Replace imperative loop in generate-redirects.js:144

**File:** app/scripts/generate-redirects.js
**Line:** 144
**Violation:** IMPERATIVE_LOOP - Validation loop with error accumulation
**Severity:** High

**Current Code:**
```javascript
for (const route of routes) {
  // validation with errors.push()
}
```

**Refactored Code:**
```javascript
const errors = routes.flatMap(route => {
  const routeErrors = [];
  if (!route.path) return ['Route missing path'];
  if (!route.file) return [`Route ${route.path} missing file`];
  // ... other validations
  return routeErrors;
}).filter(Boolean);
```

**Why This Matters:**
Using `flatMap` with declarative error collection eliminates the need for a mutable errors array and makes each validation rule explicit.

**Testing:**
- [ ] Run `bun run generate-routes` and verify output
- [ ] Introduce an invalid route and confirm error is reported
- [ ] Verify _redirects file is generated correctly

---

## CHUNK 6: Replace .push() in generate-redirects.js:147

**File:** app/scripts/generate-redirects.js
**Line:** 147
**Violation:** MUTATING_METHOD - Using `errors.push()`
**Severity:** High

**Current Code:**
```javascript
errors.push(`Duplicate path: ${route.path}`);
```

**Refactored Code:**
```javascript
// Combine with CHUNK 5 - use flatMap pattern instead of push
const duplicateError = seenPaths.has(route.path)
  ? [`Duplicate path: ${route.path}`]
  : [];
```

**Why This Matters:**
Conditional array construction with spread/concat is more functional than conditional mutation.

**Testing:**
- [ ] Add duplicate route and verify error message
- [ ] Run generate-routes script successfully

---

## CHUNK 7: Replace .push() in generate-redirects.js:153

**File:** app/scripts/generate-redirects.js
**Line:** 153
**Violation:** MUTATING_METHOD - Using `errors.push()` for missing path
**Severity:** High

**Current Code:**
```javascript
errors.push(`Route missing path`);
```

**Refactored Code:**
```javascript
// Part of flatMap pattern in CHUNK 5
const pathErrors = !route.path ? ['Route missing path'] : [];
```

**Why This Matters:**
Declarative error construction makes validation rules self-documenting.

**Testing:**
- [ ] Remove path from test route, verify error
- [ ] All validation messages appear correctly

---

## CHUNK 8: Replace .push() in generate-redirects.js:156

**File:** app/scripts/generate-redirects.js
**Line:** 156
**Violation:** MUTATING_METHOD - Using `errors.push()` for missing file
**Severity:** High

**Current Code:**
```javascript
errors.push(`Route ${route.path} missing file`);
```

**Refactored Code:**
```javascript
// Part of flatMap pattern in CHUNK 5
const fileErrors = !route.file ? [`Route ${route.path} missing file`] : [];
```

**Why This Matters:**
Consistent error handling pattern across all validators.

**Testing:**
- [ ] Remove file from test route, verify error
- [ ] Script exits with appropriate error code

---

## CHUNK 9: Replace .push() in generate-redirects.js:161

**File:** app/scripts/generate-redirects.js
**Line:** 161
**Violation:** MUTATING_METHOD - Using `errors.push()` for missing internalName
**Severity:** High

**Current Code:**
```javascript
errors.push(`Route ${route.path} has cloudflareInternal but no internalName`);
```

**Refactored Code:**
```javascript
// Part of flatMap pattern in CHUNK 5
const internalNameErrors = route.cloudflareInternal && !route.internalName
  ? [`Route ${route.path} has cloudflareInternal but no internalName`]
  : [];
```

**Why This Matters:**
Complex validation conditions are clearer when expressed as ternary array construction.

**Testing:**
- [ ] Add cloudflareInternal route without internalName, verify error
- [ ] Verify valid cloudflareInternal routes pass

---

## CHUNK 10: Replace .push() in routes.config.js:380

**File:** app/src/routes.config.js
**Line:** 380
**Violation:** MUTATING_METHOD - Using `excludedFromFunctions.push()`
**Severity:** High

**Current Code:**
```javascript
excludedFromFunctions.push('/guest-proposals', '/guest-proposals/*');
```

**Refactored Code:**
```javascript
const excludedFromFunctions = [
  ...baseExcluded,
  '/guest-proposals',
  '/guest-proposals/*'
];
```

**Why This Matters:**
Array construction with spread operator is declarative and shows the complete list structure upfront.

**Testing:**
- [ ] Verify guest-proposals routes are excluded from functions
- [ ] _routes.json contains correct exclusions

---

## CHUNK 11: Replace imperative loop in routes.config.js:457

**File:** app/src/routes.config.js
**Line:** 457
**Violation:** IMPERATIVE_LOOP - Processing routes for config
**Severity:** High

**Current Code:**
```javascript
for (const route of routes) {
  // process routes
}
```

**Refactored Code:**
```javascript
const processedRoutes = routes.map(route => ({
  ...route,
  // transformed properties
}));
```

**Why This Matters:**
Route transformation should be a pure mapping operation without side effects.

**Testing:**
- [ ] All routes render correctly
- [ ] Route config exports match expected structure

---

## CHUNK 12: Replace .push() in helpCenterData.js:280

**File:** app/src/data/helpCenterData.js
**Line:** 280
**Violation:** MUTATING_METHOD - Using `results.push()` in search
**Severity:** High

**Current Code:**
```javascript
results.push({
  // search result object
});
```

**Refactored Code:**
```javascript
const results = searchableItems
  .filter(item => matchesQuery(item, query))
  .map(item => ({
    // search result object
  }));
```

**Why This Matters:**
Search is a classic filter-then-map operation - expressing it declaratively makes the intent clear.

**Testing:**
- [ ] Help center search returns correct results
- [ ] Empty query handling works
- [ ] Partial matches work correctly

---

## CHUNK 13: Replace [...arr].sort() in aiService.js:106

**File:** app/src/lib/aiService.js
**Line:** 106
**Violation:** MUTATING_METHOD - Using `[...amenities].sort()` (false positive)
**Severity:** High

**Current Code:**
```javascript
return [...amenities].sort((a, b) => {
  // sort logic
});
```

**Refactored Code:**
```javascript
return amenities.toSorted((a, b) => {
  // sort logic
});
```

**Why This Matters:**
`toSorted()` is the modern immutable alternative to `sort()`, eliminating the need for spread-then-sort pattern.

**Testing:**
- [ ] Amenities display in correct priority order
- [ ] AI service response unchanged
- [ ] Browser compatibility verified (ES2023)

---

## CHUNK 14: Replace while loop in auth.js:563

**File:** app/src/lib/auth.js
**Line:** 563
**Violation:** IMPERATIVE_LOOP - Retry loop with `while`
**Severity:** High

**Current Code:**
```javascript
while (verifyAttempts < maxVerifyAttempts) {
  // verification attempt
  verifyAttempts++;
}
```

**Refactored Code:**
```javascript
const attemptVerification = async (attempt = 0) => {
  if (attempt >= maxVerifyAttempts) return { success: false, error: 'Max attempts reached' };

  const result = await verify();
  if (result.success) return result;

  return attemptVerification(attempt + 1);
};
```

**Why This Matters:**
Recursive approach eliminates mutable counter and makes retry logic composable. For auth, consider a dedicated retry utility.

**Testing:**
- [ ] Authentication flow works correctly
- [ ] Retry behavior on transient failures
- [ ] Max attempts limit respected

---

## CHUNK 15: Replace while loop in auth.js:786

**File:** app/src/lib/auth.js
**Line:** 786
**Violation:** IMPERATIVE_LOOP - Another retry loop with `while`
**Severity:** High

**Current Code:**
```javascript
while (verifyAttempts < maxVerifyAttempts) {
  // verification attempt
  verifyAttempts++;
}
```

**Refactored Code:**
```javascript
// Use same recursive retry pattern as CHUNK 14
// Or extract shared retry utility:
const withRetry = async (fn, maxAttempts) => {
  const attempt = async (n = 0) => {
    if (n >= maxAttempts) throw new Error('Max attempts reached');
    try { return await fn(); }
    catch (e) { return attempt(n + 1); }
  };
  return attempt();
};
```

**Why This Matters:**
Extracting retry logic into a reusable utility follows DRY and enables consistent retry behavior across auth functions.

**Testing:**
- [ ] Email verification flow works
- [ ] Retry on network failures
- [ ] Error handling for max attempts

---

## CHUNK 16: Replace [...arr].sort() in availabilityValidation.js:31

**File:** app/src/lib/availabilityValidation.js
**Line:** 31
**Violation:** MUTATING_METHOD - Using `[...selectedDays].sort()`
**Severity:** High

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
`toSorted()` is the ES2023 immutable sort - cleaner than spread-then-sort and communicates immutability intent.

**Testing:**
- [ ] Contiguous selection validation works
- [ ] Wrap-around cases (Fri-Sun) handled correctly
- [ ] Empty/single day edge cases pass

---

## CHUNK 17: Replace imperative loop in availabilityValidation.js:38

**File:** app/src/lib/availabilityValidation.js
**Line:** 38
**Violation:** IMPERATIVE_LOOP - Gap detection loop
**Severity:** High

**Current Code:**
```javascript
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    isStandardContiguous = false;
    break;
  }
}
```

**Refactored Code:**
```javascript
const isStandardContiguous = sorted.every((day, i) =>
  i === 0 || day === sorted[i - 1] + 1
);
```

**Why This Matters:**
`every()` perfectly expresses "all elements satisfy condition" and eliminates early-break mutation pattern.

**Testing:**
- [ ] Mon-Fri (contiguous) returns true
- [ ] Mon, Wed, Fri (gaps) returns false
- [ ] Single day returns true

---

## CHUNK 18: Replace imperative range generation in availabilityValidation.js:65

**File:** app/src/lib/availabilityValidation.js
**Line:** 65-66
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Building expected range
**Severity:** High

**Current Code:**
```javascript
const expectedNotSelected = [];
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i);
}
```

**Refactored Code:**
```javascript
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
`Array.from()` with mapper function declaratively generates ranges without mutation.

**Testing:**
- [ ] Wrap-around validation (Sat-Mon) works
- [ ] Inverse logic produces correct gaps
- [ ] Edge case: all days selected

---

## CHUNK 19: Replace [...arr].sort() in availabilityValidation.js:97

**File:** app/src/lib/availabilityValidation.js
**Line:** 97
**Violation:** MUTATING_METHOD - Duplicate sort pattern
**Severity:** High

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistency with CHUNK 16 - use `toSorted()` throughout.

**Testing:**
- [ ] Check-in/check-out calculation works
- [ ] Wrap-around days computed correctly

---

## CHUNK 20: Replace imperative loop in availabilityValidation.js:106

**File:** app/src/lib/availabilityValidation.js
**Line:** 106
**Violation:** IMPERATIVE_LOOP - Gap finding loop
**Severity:** High

**Current Code:**
```javascript
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    gapIndex = i;
    break;
  }
}
```

**Refactored Code:**
```javascript
const gapIndex = sorted.findIndex((day, i) =>
  i > 0 && day !== sorted[i - 1] + 1
);
```

**Why This Matters:**
`findIndex()` is the declarative way to find the first element matching a condition.

**Testing:**
- [ ] Gap detection for wrap-around cases
- [ ] Check-in day calculated after gap
- [ ] Check-out day calculated correctly

---

## CHUNK 21-31: Replace .push() calls in availabilityValidation.js (lines 166-305)

**File:** app/src/lib/availabilityValidation.js
**Lines:** 166, 175, 181, 186, 199, 271, 280, 287, 294, 305
**Violation:** MUTATING_METHOD - Error/warning accumulation with .push()
**Severity:** High

**Current Code:**
```javascript
// Pattern repeated 11 times:
result.errors.push('Please select at least one day');
result.errors.push('Move-in date cannot be in the past');
result.warnings.push(`Host prefers at least ${listing['Minimum Nights']} nights per week`);
// etc.
```

**Refactored Code:**
```javascript
// Replace entire validateScheduleSelection with declarative approach:
export function validateScheduleSelection(selectedDays, listing) {
  const dayErrors = [
    !selectedDays?.length && 'Please select at least one day',
    !isContiguousSelection(selectedDays) && 'Please check for contiguous nights to continue with your proposal',
    hasUnavailableDays(selectedDays, listing) && 'Some selected days are not available for this listing',
  ].filter(Boolean);

  const warnings = [
    belowMinNights(selectedDays, listing) && `Host prefers at least ${listing['Minimum Nights']} nights per week`,
    aboveMaxNights(selectedDays, listing) && `Host prefers at most ${listing['Maximum Nights']} nights per week`,
  ].filter(Boolean);

  return {
    valid: dayErrors.length === 0,
    errors: dayErrors,
    warnings,
    showTutorial: !isContiguousSelection(selectedDays),
    nightsCount: selectedDays?.length ?? 0,
    isContiguous: isContiguousSelection(selectedDays)
  };
}
```

**Why This Matters:**
Declarative error/warning collection with `filter(Boolean)` pattern replaces 11 separate push calls with a single, scannable list of validation rules.

**Testing:**
- [ ] All error messages display correctly
- [ ] Warning messages show for soft limits
- [ ] Tutorial shown for non-contiguous
- [ ] Empty selection handled
- [ ] Move-in date validation works

---

## CHUNK 32-36: Replace .push() and .sort() in dataLookups.js (lines 562-615)

**File:** app/src/lib/dataLookups.js
**Lines:** 562, 592, 598, 609, 615
**Violation:** MUTATING_METHOD - Building and sorting arrays
**Severity:** High

**Current Code:**
```javascript
policies.push({ id, display: policy.display });
// ...
reasons.push({ ... });
return reasons.sort((a, b) => a.displayOrder - b.displayOrder);
```

**Refactored Code:**
```javascript
// getCancellationPolicies
const policies = Object.entries(CANCELLATION_POLICIES)
  .map(([id, policy]) => ({ id, display: policy.display }));

// getRejectionReasons
const reasons = Object.entries(REJECTION_REASONS)
  .map(([id, reason]) => ({
    id,
    display: reason.display,
    displayOrder: reason.displayOrder
  }))
  .toSorted((a, b) => a.displayOrder - b.displayOrder);
```

**Why This Matters:**
`Object.entries()` + `map()` + `toSorted()` is the canonical FP pattern for object-to-sorted-array transformation.

**Testing:**
- [ ] Cancellation policies display in correct order
- [ ] Rejection reasons sorted by displayOrder
- [ ] Lookup functions return correct data

---

## CHUNK 37: Skip - Hotjar third-party code

**File:** app/src/lib/hotjar.js
**Line:** 18
**Violation:** MUTATING_METHOD - Third-party Hotjar snippet
**Severity:** Skip

**Note:** This is third-party tracking code that should not be modified. Mark as exception.

**Testing:**
- [ ] N/A - Third-party code

---

## CHUNK 38: Replace .sort() in listingDataFetcher.js:201

**File:** app/src/lib/listingDataFetcher.js
**Line:** 201
**Violation:** MUTATING_METHOD - Photo sorting
**Severity:** High

**Current Code:**
```javascript
sortedPhotos = sortedPhotos.sort((a, b) => {
  // sort by order
});
```

**Refactored Code:**
```javascript
const sortedPhotos = photos.toSorted((a, b) =>
  (a.Order ?? 0) - (b.Order ?? 0)
);
```

**Why This Matters:**
Photo ordering should be a pure transformation without reassignment.

**Testing:**
- [ ] Photos display in correct order
- [ ] Primary photo appears first
- [ ] Null Order values handled

---

## CHUNK 39: Replace .push() in listingService.js:335

**File:** app/src/lib/listingService.js
**Line:** 335
**Violation:** MUTATING_METHOD - Adding listing to array
**Severity:** High

**Current Code:**
```javascript
currentListings.push(listingId);
```

**Refactored Code:**
```javascript
const updatedListings = [...currentListings, listingId];
```

**Why This Matters:**
Creating a new array maintains referential transparency.

**Testing:**
- [ ] Listing addition works in host dashboard
- [ ] State updates correctly

---

## CHUNK 40-41: Replace loop+push in listingService.js:766-768

**File:** app/src/lib/listingService.js
**Lines:** 766, 768
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD
**Severity:** High

**Current Code:**
```javascript
for (const day of dayOrder) {
  if (availableDays.has(day)) {
    result.push(dayNameMapping[day]);
  }
}
```

**Refactored Code:**
```javascript
const result = dayOrder
  .filter(day => availableDays.has(day))
  .map(day => dayNameMapping[day]);
```

**Why This Matters:**
Classic filter-map pattern replaces conditional push inside loop.

**Testing:**
- [ ] Day names display in correct order
- [ ] Available days filtered correctly

---

## CHUNK 42: Replace Object.entries loop in listingService.js:982

**File:** app/src/lib/listingService.js
**Line:** 982
**Violation:** IMPERATIVE_LOOP - Form data processing
**Severity:** High

**Current Code:**
```javascript
for (const [key, value] of Object.entries(formData)) {
  // process each field
}
```

**Refactored Code:**
```javascript
const processedData = Object.fromEntries(
  Object.entries(formData)
    .filter(([key, value]) => shouldIncludeField(key, value))
    .map(([key, value]) => [key, transformValue(key, value)])
);
```

**Why This Matters:**
`Object.fromEntries()` + `Object.entries()` provides declarative object transformation.

**Testing:**
- [ ] Form submission processes all fields
- [ ] Field transformations applied correctly
- [ ] Changed fields only included

---

## CHUNK 43-45: Replace loop+push+sort in listingService.js:1076-1082

**File:** app/src/lib/listingService.js
**Lines:** 1076, 1078, 1082
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD (x2)
**Severity:** High

**Current Code:**
```javascript
for (const [day, isSelected] of Object.entries(availableNights)) {
  if (isSelected) {
    result.push(dayMapping[day]);
  }
}
return result.sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
return Object.entries(availableNights)
  .filter(([_, isSelected]) => isSelected)
  .map(([day]) => dayMapping[day])
  .toSorted((a, b) => a - b);
```

**Why This Matters:**
Method chaining replaces three separate operations with a single pipeline.

**Testing:**
- [ ] Available nights extracted correctly
- [ ] Day indices sorted numerically
- [ ] Empty selection returns empty array

---

## CHUNK 46: Replace for...of in listingService.js:1240

**File:** app/src/lib/listingService.js
**Line:** 1240
**Violation:** IMPERATIVE_LOOP - Processing days array
**Severity:** High

**Current Code:**
```javascript
for (const dayNum of daysArray) {
  // process each day
}
```

**Refactored Code:**
```javascript
const processed = daysArray.map(dayNum => processDay(dayNum));
```

**Why This Matters:**
One-to-one transformations should use `map()`.

**Testing:**
- [ ] Day processing produces correct output
- [ ] All days in array processed

---

## CHUNK 47-49: Replace binary conversion loops in photoUpload.js:28-36

**File:** app/src/lib/photoUpload.js
**Lines:** 28, 32, 36
**Violation:** IMPERATIVE_LOOP (x2) + MUTATING_METHOD
**Severity:** High

**Current Code:**
```javascript
for (let offset = 0; offset < byteCharacters.length; offset += 512) {
  const slice = byteCharacters.slice(offset, offset + 512);
  const byteNumbers = new Array(slice.length);
  for (let i = 0; i < slice.length; i++) {
    byteNumbers[i] = slice.charCodeAt(i);
  }
  byteArrays.push(new Uint8Array(byteNumbers));
}
```

**Refactored Code:**
```javascript
const chunkSize = 512;
const byteArrays = Array.from(
  { length: Math.ceil(byteCharacters.length / chunkSize) },
  (_, chunkIndex) => {
    const slice = byteCharacters.slice(
      chunkIndex * chunkSize,
      (chunkIndex + 1) * chunkSize
    );
    return new Uint8Array(
      Array.from(slice, char => char.charCodeAt(0))
    );
  }
);
```

**Why This Matters:**
Nested loops for chunk processing can be expressed declaratively with `Array.from()` and a mapper function.

**Testing:**
- [ ] Base64 to blob conversion works
- [ ] Large images upload correctly
- [ ] Photo chunks assembled properly

---

## CHUNK 50: Replace .pop() usage in photoUpload.js:86

**File:** app/src/lib/photoUpload.js
**Line:** 86
**Violation:** MUTATING_METHOD - Using .pop() for extension
**Severity:** High

**Current Code:**
```javascript
extension = photo.file.name.split('.').pop().toLowerCase() || 'jpg';
```

**Refactored Code:**
```javascript
const extension = photo.file.name.split('.').at(-1)?.toLowerCase() || 'jpg';
```

**Why This Matters:**
`.at(-1)` is the non-mutating way to access the last element (ES2022).

**Testing:**
- [ ] File extensions extracted correctly
- [ ] Files without extension default to 'jpg'
- [ ] Case normalization works

---

## CHUNK 51-53: Replace upload loop+push in photoUpload.js:164-184

**File:** app/src/lib/photoUpload.js
**Lines:** 164, 170, 184
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD (x2)
**Severity:** High

**Current Code:**
```javascript
for (let i = 0; i < photos.length; i++) {
  const result = await uploadPhoto(photos[i]);
  uploadedPhotos.push({ ... });
}
```

**Refactored Code:**
```javascript
const uploadedPhotos = await Promise.all(
  photos.map(async (photo, i) => {
    const result = await uploadPhoto(photo);
    return { index: i, url: result.url, ...photo };
  })
);
```

**Why This Matters:**
`Promise.all()` with `map()` enables concurrent uploads and declarative result collection.

**Testing:**
- [ ] Multiple photos upload correctly
- [ ] Upload order preserved
- [ ] Error handling for failed uploads

---

## CHUNK 54-55: Replace localStorage iteration in secureStorage.js:233-236

**File:** app/src/lib/secureStorage.js
**Lines:** 233, 236
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD
**Severity:** High

**Current Code:**
```javascript
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  if (shouldRemove(key)) {
    keysToRemove.push(key);
  }
}
```

**Refactored Code:**
```javascript
const keysToRemove = Array.from(
  { length: localStorage.length },
  (_, i) => localStorage.key(i)
).filter(shouldRemove);
```

**Why This Matters:**
Converting localStorage's index-based API to array operations enables functional patterns.

**Testing:**
- [ ] Secure storage cleanup works
- [ ] Correct keys identified for removal
- [ ] No interference with other storage

---

## CHUNK 56-63: Replace photo processing in supabaseUtils.js:178-274

**File:** app/src/lib/supabaseUtils.js
**Lines:** 178, 189, 203, 210, 258, 260, 269, 274
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD (multiple)
**Severity:** High

**Current Code:**
```javascript
for (const photo of photos) {
  // ... process
  photoUrls.push(photoUrl);
}
// ... later
for (const [key, amenity] of Object.entries(amenitiesMap)) {
  if (condition) {
    amenities.push(amenity);
  }
}
amenities.sort((a, b) => a.priority - b.priority);
```

**Refactored Code:**
```javascript
// Photo URLs
const photoUrls = await Promise.all(
  photos.map(async photo => {
    const url = await processPhoto(photo);
    return url;
  })
);

// Amenities
const amenities = Object.entries(amenitiesMap)
  .filter(([key, amenity]) => shouldInclude(key, amenity))
  .map(([_, amenity]) => amenity)
  .toSorted((a, b) => a.priority - b.priority);
```

**Why This Matters:**
Parallel async operations with `Promise.all()` + `map()` and declarative filtering/sorting.

**Testing:**
- [ ] Photo URLs generated correctly
- [ ] Amenities sorted by priority
- [ ] Kitchen amenity included when applicable

---

## CHUNK 64: Replace while loop in workflowClient.js:139

**File:** app/src/lib/workflowClient.js
**Line:** 139
**Violation:** IMPERATIVE_LOOP - Timeout polling loop
**Severity:** High

**Current Code:**
```javascript
while (Date.now() - startTime < timeout) {
  // poll for completion
}
```

**Refactored Code:**
```javascript
const pollWithTimeout = async (checkFn, timeout, interval = 1000) => {
  const deadline = Date.now() + timeout;

  const poll = async () => {
    if (Date.now() >= deadline) throw new Error('Timeout');
    const result = await checkFn();
    if (result.complete) return result;
    await new Promise(r => setTimeout(r, interval));
    return poll();
  };

  return poll();
};
```

**Why This Matters:**
Recursive polling with explicit timeout is cleaner than mutable time tracking.

**Testing:**
- [ ] Workflow completion detection works
- [ ] Timeout throws appropriate error
- [ ] Polling interval respected

---

## CHUNK 65: Remove console.warn in proposalRules.js:306

**File:** app/src/logic/rules/proposals/proposalRules.js
**Line:** 306
**Violation:** IO_IN_CORE - Console.warn in rules layer
**Severity:** High

**Current Code:**
```javascript
console.warn('[getCancellationReasonOptions] Cache empty, using fallback values');
```

**Refactored Code:**
```javascript
// Option 1: Return a result that indicates fallback was used
return { options: fallbackOptions, usedFallback: true };

// Option 2: Accept a logger as parameter (dependency injection)
export function getCancellationReasonOptions({ logger = () => {} } = {}) {
  if (cacheEmpty) {
    logger('[getCancellationReasonOptions] Cache empty, using fallback values');
    return fallbackOptions;
  }
  // ...
}
```

**Why This Matters:**
Rules should be pure - logging is an I/O side effect. Return status information or inject logger.

**Testing:**
- [ ] Cancellation reasons returned correctly
- [ ] Fallback behavior works
- [ ] Caller can detect fallback usage

---

## CHUNK 66-69: Refactor isScheduleContiguous.js:55-96

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Lines:** 55, 64, 95, 96
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP (multiple)
**Severity:** High

**Current Code:**
```javascript
const sorted = [...selectedDayIndices].sort((a, b) => a - b)
// ...
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    isStandardContiguous = false
    break
  }
}
// ...
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i)
}
```

**Refactored Code:**
```javascript
const sorted = selectedDayIndices.toSorted((a, b) => a - b)

const isStandardContiguous = sorted.every((day, i) =>
  i === 0 || day === sorted[i - 1] + 1
)

const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
)
```

**Why This Matters:**
This is a critical scheduling function - making it purely functional improves testability and reliability.

**Testing:**
- [ ] Mon-Fri contiguous: true
- [ ] Mon, Wed, Fri not contiguous: false
- [ ] Fri-Sun wrap-around: true
- [ ] Sat-Tue wrap-around: true
- [ ] All days: true
- [ ] Single day: true
- [ ] Empty: false

---

## CHUNK 70-72: Remove console.error/warn in extractListingCoordinates.js:46-98

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Lines:** 46, 62, 98
**Violation:** IO_IN_CORE - Console logging in processor
**Severity:** High

**Current Code:**
```javascript
console.error('Failed to parse Location - Address:', { ... });
console.error('Failed to parse Location - Address:', { ... });
console.warn('No valid coordinates found for listing:', { ... });
```

**Refactored Code:**
```javascript
// Return structured result with parsing details
export function extractListingCoordinates(listing) {
  const result = { lat: null, lng: null, source: null, warnings: [] };

  // Try Address field
  const addressResult = parseAddressCoordinates(listing['Location - Address']);
  if (!addressResult.success) {
    result.warnings.push({ type: 'address_parse_failed', details: addressResult.error });
  }

  // ... other attempts

  if (!result.lat || !result.lng) {
    result.warnings.push({ type: 'no_coordinates', listing_id: listing._id });
  }

  return result;
}
```

**Why This Matters:**
Processors should return structured data including error/warning information, not perform I/O.

**Testing:**
- [ ] Valid coordinates extracted
- [ ] Parse failures captured in warnings
- [ ] Caller can log warnings appropriately

---

## CHUNK 73: Remove console.warn in processUserData.js:58

**File:** app/src/logic/processors/user/processUserData.js
**Line:** 58
**Violation:** IO_IN_CORE - Console.warn in processor
**Severity:** High

**Current Code:**
```javascript
console.warn(`processUserData: User ${rawUser._id} has no name fields, using default`)
```

**Refactored Code:**
```javascript
// Return metadata about transformations made
return {
  user: { ...processedUser, name: 'Guest' },
  metadata: { usedDefaultName: true, userId: rawUser._id }
};
```

**Why This Matters:**
Processors should be pure data transformations - move logging to calling code.

**Testing:**
- [ ] Users without names get default
- [ ] Caller can detect and log default usage

---

## CHUNK 74-76: Refactor scheduling calculators

**Files:**
- app/src/logic/calculators/scheduling/calculateCheckInOutDays.js:50, 59
- app/src/logic/calculators/scheduling/calculateNextAvailableCheckIn.js:54

**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP
**Severity:** High

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b)
for (let i = 1; i < sorted.length; i++) {
  // gap detection
}
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b)
const gapIndex = sorted.findIndex((day, i) =>
  i > 0 && day !== sorted[i - 1] + 1
);
```

**Why This Matters:**
Calculators should be pure functions - these FP fixes improve testability.

**Testing:**
- [ ] Check-in/out days calculated correctly
- [ ] Next available check-in works
- [ ] Wrap-around cases handled

---

## CHUNK 77: Replace .push() in userProposalQueries.js:225

**File:** app/src/lib/proposals/userProposalQueries.js
**Line:** 225
**Violation:** MUTATING_METHOD
**Severity:** High

**Current Code:**
```javascript
listingsNeedingPhotoFetch.push(listing._id);
```

**Refactored Code:**
```javascript
const listingsNeedingPhotoFetch = proposals
  .map(p => p.listing)
  .filter(listing => needsPhotoFetch(listing))
  .map(listing => listing._id);
```

**Why This Matters:**
Filter-map pattern is cleaner than conditional push.

**Testing:**
- [ ] Photo fetch list generated correctly
- [ ] Only missing photos identified

---

## CHUNK 78-80: Refactor dayHelpers.js

**File:** app/src/lib/scheduleSelector/dayHelpers.js
**Lines:** 44, 112, 113
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP
**Severity:** High

**Current Code:**
```javascript
return [...days].sort((a, b) => a.dayOfWeek - b.dayOfWeek);
// ...
for (let i = 0; i < sortedDays.length - 1; i++) {
  nights.push(createNight(sortedDays[i].dayOfWeek));
}
```

**Refactored Code:**
```javascript
const sortedDays = days.toSorted((a, b) => a.dayOfWeek - b.dayOfWeek);

const nights = sortedDays
  .slice(0, -1)
  .map(day => createNight(day.dayOfWeek));
```

**Why This Matters:**
`.slice(0, -1)` elegantly handles "all but last" without index manipulation.

**Testing:**
- [ ] Days sorted correctly
- [ ] Nights generated between days
- [ ] Edge cases (empty, single day) handled

---

## CHUNK 81-86: Refactor nightCalculations.js and validators.js

**Files:**
- app/src/lib/scheduleSelector/nightCalculations.js:14, 15, 50
- app/src/lib/scheduleSelector/validators.js:101, 102, 114

**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD (multiple)
**Severity:** High

**Refactored Code:**
```javascript
// nightCalculations - consecutive pairs
const nights = sorted
  .slice(0, -1)
  .map((day, i) => createNight(day.dayOfWeek));

// validators - range generation
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
Schedule selector is a critical UI component - FP patterns improve reliability.

**Testing:**
- [ ] Night calculations correct
- [ ] Validation logic works
- [ ] Schedule selector functions properly

---

## CHUNK 87: Replace .push() in useEmailSmsUnitPageLogic.js:229

**File:** app/src/islands/pages/useEmailSmsUnitPageLogic.js
**Line:** 229
**Violation:** MUTATING_METHOD
**Severity:** High

**Current Code:**
```javascript
emails.push('');
```

**Refactored Code:**
```javascript
setEmails(prev => [...prev, '']);
```

**Why This Matters:**
React state updates should always create new arrays.

**Testing:**
- [ ] Adding email field works
- [ ] State updates correctly

---

## CHUNK 88-89: Replace .push() in useSearchPageLogic.js:148-149

**File:** app/src/islands/pages/useSearchPageLogic.js
**Lines:** 148, 149
**Violation:** MUTATING_METHOD
**Severity:** High

**Current Code:**
```javascript
if (neighborhoodName) locationParts.push(neighborhoodName)
if (boroughName) locationParts.push(boroughName)
```

**Refactored Code:**
```javascript
const locationParts = [
  neighborhoodName,
  boroughName
].filter(Boolean);
```

**Why This Matters:**
Array construction with filter(Boolean) is the FP pattern for conditional inclusion.

**Testing:**
- [ ] Location parts assembled correctly
- [ ] Missing parts filtered out

---

## CHUNKS 90-351: Remaining violations follow same patterns

The remaining violations (90-351) follow the same patterns documented above:

### Pattern Summary

| Pattern | Count | Refactoring Approach |
|---------|-------|---------------------|
| `.push()` → declarative array | ~180 | `[...arr, item]` or `arr.filter().map()` |
| `.sort()` → `.toSorted()` | ~35 | Direct replacement |
| `for...of` → `.map()/.filter()` | ~60 | Chain methods |
| `while` loop → recursion/utility | ~8 | Extract retry/poll utilities |
| `console.*` in core → return data | 5 | Return structured results |

### High-Priority Files to Complete

1. **listingLocalStore.ts** (21 violations) - Convert all error accumulation to declarative pattern
2. **LoggedInAvatar.jsx** (12 violations) - Build menu items declaratively
3. **AvailabilitySection.jsx** (11 violations) - Calendar generation with Array.from()
4. **PricingEditSection.jsx** (10 violations) - Change tracking declaratively
5. **prepareListingSubmission.ts** (15 violations) - Validation error collection

### Implementation Order Recommendation

1. Start with shared utilities (lib/, logic/) - highest reuse value
2. Then page logic hooks (useXxxPageLogic.js) - consolidates patterns
3. Finally components - often just consume refactored utilities

---

## File References

| File | Line Range | Chunk Range |
|------|-----------|-------------|
| app/vite.config.js | 32-181 | 1-4 |
| app/scripts/generate-redirects.js | 144-161 | 5-9 |
| app/src/routes.config.js | 380-457 | 10-11 |
| app/src/lib/availabilityValidation.js | 31-305 | 16-31 |
| app/src/lib/listingService.js | 335-1240 | 39-46 |
| app/src/logic/rules/scheduling/isScheduleContiguous.js | 55-96 | 66-69 |
| app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts | 198-454 | 279-299 |
| app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx | 174-323 | 221-232 |

---

## Testing Strategy

### Unit Tests Required
- [ ] isContiguousSelection - all edge cases
- [ ] calculateCheckInOutDays - wrap-around cases
- [ ] validateScheduleSelection - all validation rules
- [ ] Photo upload utilities
- [ ] Form data transformation

### Integration Tests
- [ ] Route generation produces valid _redirects
- [ ] Listing form submission
- [ ] Photo upload flow
- [ ] Schedule selector interactions

### Regression Testing
- [ ] Build completes successfully
- [ ] Dev server starts
- [ ] All pages render
- [ ] Auth flow works
- [ ] Proposal creation flow

---

## Notes

1. **ES2023 Compatibility**: `toSorted()` requires ES2023. Verify browser support or add polyfill.
2. **Performance**: Most refactors are equivalent or better performance. For hot paths, benchmark.
3. **Third-party Code**: Skip Hotjar and similar third-party snippets.
4. **Incremental Adoption**: Each chunk is independent - can be applied one at a time.
