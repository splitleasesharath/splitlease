# Functional Programming Refactoring Plan

**Date:** 2026-01-10
**Target:** agents/fp_audit_violations.json
**Severity Filter:** high
**Total Violations:** 388 (300 MUTATING_METHOD, 83 IMPERATIVE_LOOP, 5 IO_IN_CORE)

---

## Executive Summary

This plan addresses 388 FP violations across the codebase. Violations are organized by file, with the highest-impact files prioritized first. Each chunk represents a single atomic fix that can be implemented in 5-10 minutes.

### Top Files by Violation Count

| File | Violations | Types |
|------|------------|-------|
| scripts/generate-redirects.js | 37 | MUTATING_METHOD, IMPERATIVE_LOOP |
| src/islands/pages/SelfListingPage/store/listingLocalStore.ts | 21 | MUTATING_METHOD |
| src/lib/availabilityValidation.js | 16 | MUTATING_METHOD, IMPERATIVE_LOOP |
| src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts | 15 | MUTATING_METHOD |
| src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx | 12 | MUTATING_METHOD |

---

## FILE: app/scripts/generate-redirects.js (37 violations)

### ðŸ”´ CHUNK 1: Refactor generateRedirects() to use declarative array construction

**File:** app/scripts/generate-redirects.js
**Lines:** 22-99
**Violation:** MUTATING_METHOD - Multiple .push() calls to build lines array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
function generateRedirects() {
  const lines = [
    '# Cloudflare Pages redirects and rewrites',
    '# AUTO-GENERATED from routes.config.js - DO NOT EDIT MANUALLY',
    `# Generated: ${new Date().toISOString()}`,
    '#',
    '# See: https://developers.cloudflare.com/pages/configuration/redirects/',
    ''
  ];

  const dynamicRoutes = routes.filter(r => r.hasDynamicSegment && !r.devOnly);
  const staticRoutes = routes.filter(r => !r.hasDynamicSegment && !r.devOnly);

  lines.push('# ===== DYNAMIC ROUTES (with parameters) =====');
  lines.push('# These routes use _internal/ files to avoid Cloudflare\'s 308 redirects');
  lines.push('');

  for (const route of dynamicRoutes) {
    const basePath = getBasePath(route);
    if (route.path === '/help-center/:category') {
      lines.push(`# ${route.path} â†’ ${route.file} (wildcard only, base handled separately)`);
      lines.push(`${basePath}/*  /_internal/${route.internalName}  200`);
      lines.push('');
      continue;
    }
    if (route.cloudflareInternal && route.internalName) {
      lines.push(`# ${route.path} â†’ ${route.file}`);
      lines.push(`${basePath}  /_internal/${route.internalName}  200`);
      lines.push(`${basePath}/  /_internal/${route.internalName}  200`);
      lines.push(`${basePath}/*  /_internal/${route.internalName}  200`);
    } else {
      lines.push(`# ${route.path} â†’ ${route.file}`);
      lines.push(`${basePath}/*  /${route.file}  200`);
    }
    lines.push('');
  }
  // ... more lines.push() calls
}
```

**Refactored Code:**
```javascript
/**
 * Generate redirect lines for a single dynamic route
 */
const generateDynamicRouteLines = (route) => {
  const basePath = getBasePath(route);

  if (route.path === '/help-center/:category') {
    return [
      `# ${route.path} â†’ ${route.file} (wildcard only, base handled separately)`,
      `${basePath}/*  /_internal/${route.internalName}  200`,
      ''
    ];
  }

  if (route.cloudflareInternal && route.internalName) {
    return [
      `# ${route.path} â†’ ${route.file}`,
      `${basePath}  /_internal/${route.internalName}  200`,
      `${basePath}/  /_internal/${route.internalName}  200`,
      `${basePath}/*  /_internal/${route.internalName}  200`,
      ''
    ];
  }

  return [
    `# ${route.path} â†’ ${route.file}`,
    `${basePath}/*  /${route.file}  200`,
    ''
  ];
};

/**
 * Generate redirect lines for a single static route
 */
const generateStaticRouteLines = (route) => {
  const basePath = getBasePath(route);

  if (basePath === '/') {
    return [
      '# Homepage',
      '/  /index.html  200',
      '/index.html  /index.html  200',
      ''
    ];
  }

  if (route.cloudflareInternal && route.internalName) {
    return [
      `# ${basePath} â†’ ${route.file}`,
      `${basePath}  /_internal/${route.internalName}  200`,
      `${basePath}/  /_internal/${route.internalName}  200`,
      ''
    ];
  }

  return [
    `# ${basePath}`,
    `${basePath}  /${route.file}  200`,
    `${basePath}/  /${route.file}  200`,
    `${basePath}.html  /${route.file}  200`,
    ''
  ];
};

function generateRedirects() {
  const dynamicRoutes = routes.filter(r => r.hasDynamicSegment && !r.devOnly);
  const staticRoutes = routes.filter(r => !r.hasDynamicSegment && !r.devOnly);

  const lines = [
    '# Cloudflare Pages redirects and rewrites',
    '# AUTO-GENERATED from routes.config.js - DO NOT EDIT MANUALLY',
    `# Generated: ${new Date().toISOString()}`,
    '#',
    '# See: https://developers.cloudflare.com/pages/configuration/redirects/',
    '',
    '# ===== DYNAMIC ROUTES (with parameters) =====',
    '# These routes use _internal/ files to avoid Cloudflare\'s 308 redirects',
    '',
    ...dynamicRoutes.flatMap(generateDynamicRouteLines),
    '# ===== STATIC PAGES =====',
    '',
    ...staticRoutes.flatMap(generateStaticRouteLines),
    '# Note: Cloudflare Pages automatically serves /404.html for not found routes',
    '# No explicit catch-all rule needed - native 404.html support handles this'
  ];

  const content = lines.join('\n');
  const outputPath = path.join(publicDir, '_redirects');

  fs.writeFileSync(outputPath, content);
  console.log('âœ… Generated _redirects file from Route Registry');
  console.log(`   ${dynamicRoutes.length} dynamic routes, ${staticRoutes.length} static routes`);
}
```

**Why This Matters:**
Replacing imperative loops with `flatMap()` and helper functions makes the code more readable and testable. Each route type has a pure function that returns an array of lines, which can be unit tested in isolation.

**Testing:**
- [ ] Run `bun run generate-routes` and verify _redirects output matches expected format
- [ ] Compare generated _redirects with previous version to ensure no regressions
- [ ] Verify dynamic and static routes are both correctly generated

---

### ðŸ”´ CHUNK 2: Refactor validateRoutes() to use reduce for error collection

**File:** app/scripts/generate-redirects.js
**Lines:** 133-156
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP - for loop with errors.push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
function validateRoutes() {
  const errors = [];
  const paths = new Set();

  for (const route of routes) {
    if (paths.has(route.path)) {
      errors.push(`Duplicate path: ${route.path}`);
    }
    paths.add(route.path);

    if (!route.path) {
      errors.push(`Route missing path`);
    }
    if (!route.file) {
      errors.push(`Route ${route.path} missing file`);
    }

    if (route.cloudflareInternal && !route.internalName) {
      errors.push(`Route ${route.path} has cloudflareInternal but no internalName`);
    }
  }

  if (errors.length > 0) {
    console.error('âŒ Route Registry validation failed:');
    errors.forEach(e => console.error(`   - ${e}`));
    // ...
  }
}
```

**Refactored Code:**
```javascript
/**
 * Validate a single route and return array of error messages
 */
const validateRoute = (route, seenPaths) => [
  seenPaths.has(route.path) && `Duplicate path: ${route.path}`,
  !route.path && 'Route missing path',
  !route.file && `Route ${route.path} missing file`,
  route.cloudflareInternal && !route.internalName &&
    `Route ${route.path} has cloudflareInternal but no internalName`
].filter(Boolean);

function validateRoutes() {
  const { errors } = routes.reduce(
    (acc, route) => ({
      seenPaths: acc.seenPaths.add(route.path),
      errors: [...acc.errors, ...validateRoute(route, acc.seenPaths)]
    }),
    { seenPaths: new Set(), errors: [] }
  );

  if (errors.length > 0) {
    console.error('âŒ Route Registry validation failed:');
    errors.forEach(e => console.error(`   - ${e}`));
    // ...
  }
}
```

**Why This Matters:**
Using `reduce()` with accumulated state eliminates mutation. The `validateRoute` function is pure and can be unit tested independently.

**Testing:**
- [ ] Run generate-routes with valid routes.config.js
- [ ] Test with intentionally invalid routes to verify error detection
- [ ] Verify duplicate path detection still works

---

## FILE: app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts (21 violations)

### ðŸ”´ CHUNK 3: Refactor validateForSubmission() to use declarative error collection

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Lines:** 381-461
**Violation:** MUTATING_METHOD - 18 errors.push() calls
**Severity:** ðŸ”´ High

**Current Code:**
```typescript
validateForSubmission(): string[] {
  const errors: string[] = [];
  const data = this.state.data;

  // Section 1: Space Snapshot
  if (!data.spaceSnapshot.listingName) {
    errors.push('Listing name is required');
  }
  if (!data.spaceSnapshot.typeOfSpace) {
    errors.push('Type of space is required');
  }
  if (!data.spaceSnapshot.typeOfKitchen) {
    errors.push('Type of kitchen is required');
  }
  if (!data.spaceSnapshot.typeOfParking) {
    errors.push('Type of parking is required');
  }
  if (!data.spaceSnapshot.address.fullAddress || !data.spaceSnapshot.address.validated) {
    errors.push('Valid NYC address is required');
  }

  // Section 2: Features
  if (data.features.amenitiesInsideUnit.length === 0) {
    errors.push('At least one amenity inside unit is required');
  }
  if (!data.features.descriptionOfLodging) {
    errors.push('Description of lodging is required');
  }

  // ... more conditional pushes
  return errors;
}
```

**Refactored Code:**
```typescript
/**
 * Validation rules as pure predicates with error messages
 */
type ValidationRule = {
  predicate: (data: ListingFormData) => boolean;
  message: string;
};

const SUBMISSION_VALIDATION_RULES: ValidationRule[] = [
  // Section 1: Space Snapshot
  { predicate: (d) => !d.spaceSnapshot.listingName, message: 'Listing name is required' },
  { predicate: (d) => !d.spaceSnapshot.typeOfSpace, message: 'Type of space is required' },
  { predicate: (d) => !d.spaceSnapshot.typeOfKitchen, message: 'Type of kitchen is required' },
  { predicate: (d) => !d.spaceSnapshot.typeOfParking, message: 'Type of parking is required' },
  {
    predicate: (d) => !d.spaceSnapshot.address.fullAddress || !d.spaceSnapshot.address.validated,
    message: 'Valid NYC address is required'
  },

  // Section 2: Features
  { predicate: (d) => d.features.amenitiesInsideUnit.length === 0, message: 'At least one amenity inside unit is required' },
  { predicate: (d) => !d.features.descriptionOfLodging, message: 'Description of lodging is required' },

  // Section 3: Lease Styles
  { predicate: (d) => !d.leaseStyles.rentalType, message: 'Rental type is required' },
  {
    predicate: (d) => d.leaseStyles.rentalType === 'Nightly' &&
      (!d.leaseStyles.availableNights || !Object.values(d.leaseStyles.availableNights).some(v => v)),
    message: 'At least one available night must be selected'
  },
  {
    predicate: (d) => d.leaseStyles.rentalType === 'Weekly' && !d.leaseStyles.weeklyPattern,
    message: 'Weekly pattern is required'
  },

  // Section 4: Pricing
  { predicate: (d) => d.pricing.damageDeposit < 500, message: 'Damage deposit must be at least $500' },
  {
    predicate: (d) => d.leaseStyles.rentalType === 'Monthly' && !d.pricing.monthlyCompensation,
    message: 'Monthly compensation is required'
  },
  {
    predicate: (d) => d.leaseStyles.rentalType === 'Weekly' && !d.pricing.weeklyCompensation,
    message: 'Weekly compensation is required'
  },
  {
    predicate: (d) => d.leaseStyles.rentalType === 'Nightly' && !d.pricing.nightlyPricing?.oneNightPrice,
    message: 'Nightly pricing is required'
  },

  // Section 5: Rules
  { predicate: (d) => !d.rules.cancellationPolicy, message: 'Cancellation policy is required' },
  { predicate: (d) => !d.rules.checkInTime, message: 'Check-in time is required' },
  { predicate: (d) => !d.rules.checkOutTime, message: 'Check-out time is required' },

  // Section 6: Photos
  { predicate: (d) => d.photos.photos.length < d.photos.minRequired, message: `At least ${d.photos.minRequired} photos are required` },
];

/**
 * Collect validation errors using pure filter/map
 */
validateForSubmission(): string[] {
  const data = this.state.data;

  return SUBMISSION_VALIDATION_RULES
    .filter(rule => rule.predicate(data))
    .map(rule => rule.message);
}
```

**Why This Matters:**
Extracting validation rules into a declarative array makes them easy to test, maintain, and extend. The `validateForSubmission()` method becomes a simple filter/map operation with no mutations.

**Testing:**
- [ ] Test each validation rule individually with unit tests
- [ ] Verify all error messages are correctly returned when conditions fail
- [ ] Ensure valid data returns empty array

---

### ðŸ”´ CHUNK 4: Replace .sort() with toSorted() in completedSections update

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 198
**Violation:** MUTATING_METHOD - Using .sort() which mutates in-place
**Severity:** ðŸ”´ High

**Current Code:**
```typescript
this.state.data.completedSections = Array.from(completedSections).sort();
```

**Refactored Code:**
```typescript
this.state.data.completedSections = Array.from(completedSections).toSorted();
```

**Why This Matters:**
While `Array.from()` creates a new array so the mutation is contained, using `toSorted()` makes intent clearer and is the modern FP-friendly approach.

**Testing:**
- [ ] Verify sections are still correctly sorted
- [ ] Check browser compatibility (toSorted is ES2023)
- [ ] Add polyfill if needed for older browsers

---

### ðŸ”´ CHUNK 5: Replace errors.push() with immutable state update

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 254
**Violation:** MUTATING_METHOD - this.state.errors.push()
**Severity:** ðŸ”´ High

**Current Code:**
```typescript
this.state.errors.push('Failed to save draft');
```

**Refactored Code:**
```typescript
this.state.errors = [...this.state.errors, 'Failed to save draft'];
```

**Why This Matters:**
Spread operator creates a new array, maintaining immutability for reactive state updates.

**Testing:**
- [ ] Verify error appears in UI when draft save fails
- [ ] Confirm state reactivity still triggers re-renders

---

### ðŸ”´ CHUNK 6: Replace errors.push() with immutable spread in error handler

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 364
**Violation:** MUTATING_METHOD - this.state.errors.push(error)
**Severity:** ðŸ”´ High

**Current Code:**
```typescript
this.state.errors.push(error);
```

**Refactored Code:**
```typescript
this.state.errors = [...this.state.errors, error];
```

**Why This Matters:**
Same pattern as CHUNK 5 - maintains immutable state updates for proper reactivity.

**Testing:**
- [ ] Test error handling flow triggers UI update
- [ ] Verify multiple errors accumulate correctly

---

## FILE: app/src/lib/availabilityValidation.js (16 violations)

### ðŸ”´ CHUNK 7: Replace .sort() with toSorted() in isContiguousSelection

**File:** app/src/lib/availabilityValidation.js
**Line:** 31
**Violation:** MUTATING_METHOD - Using [...arr].sort() pattern
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
`toSorted()` is the non-mutating version of `sort()` (ES2023). It returns a new sorted array without modifying the original.

**Testing:**
- [ ] Verify contiguous selection logic still works correctly
- [ ] Test wrap-around cases (Fri-Sun) still pass
- [ ] Check ES2023 compatibility or add polyfill

---

### ðŸ”´ CHUNK 8: Replace imperative loop with Array.from and range generation

**File:** app/src/lib/availabilityValidation.js
**Lines:** 64-67
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with push
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const expectedNotSelected = [];
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i);
}
```

**Refactored Code:**
```javascript
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
`Array.from()` with a mapping function declaratively generates a range without mutation.

**Testing:**
- [ ] Verify wrap-around logic for week boundaries still works
- [ ] Test edge cases: single day not selected, all days selected
- [ ] Ensure range generation matches previous behavior

---

### ðŸ”´ CHUNK 9: Replace .sort() with toSorted() in calculateCheckInOutDays

**File:** app/src/lib/availabilityValidation.js
**Line:** 97
**Violation:** MUTATING_METHOD - Using [...arr].sort() pattern
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent use of `toSorted()` throughout the codebase for clarity and modern FP style.

**Testing:**
- [ ] Verify check-in/check-out calculation still correct
- [ ] Test wrap-around cases (e.g., Fri-Mon produces correct check-in/out)

---

### ðŸ”´ CHUNK 10: Replace imperative loop with findIndex in gap detection

**File:** app/src/lib/availabilityValidation.js
**Lines:** 105-111
**Violation:** IMPERATIVE_LOOP - for loop to find gap index
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
let gapIndex = -1;
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    gapIndex = i;
    break;
  }
}
```

**Refactored Code:**
```javascript
const gapIndex = sorted.findIndex((day, i) =>
  i > 0 && day !== sorted[i - 1] + 1
);
```

**Why This Matters:**
`findIndex()` is a declarative alternative to a loop with break. It clearly expresses "find the first element where this condition is true."

**Testing:**
- [ ] Verify gap detection works for wrap-around selections
- [ ] Test with contiguous selections (should return -1)
- [ ] Test with non-contiguous selections

---

### ðŸ”´ CHUNK 11: Refactor validateScheduleSelection to use declarative error collection

**File:** app/src/lib/availabilityValidation.js
**Lines:** 153-204
**Violation:** MUTATING_METHOD - Multiple result.errors.push() and result.warnings.push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
export function validateScheduleSelection(selectedDays, listing) {
  const result = {
    valid: true,
    errors: [],
    warnings: [],
    showTutorial: false,
    nightsCount: selectedDays.length,
    isContiguous: false
  };

  if (!selectedDays || selectedDays.length === 0) {
    result.valid = false;
    result.errors.push('Please select at least one day');
    return result;
  }

  result.isContiguous = isContiguousSelection(selectedDays);
  if (!result.isContiguous) {
    result.valid = false;
    result.showTutorial = true;
    result.errors.push('Please check for contiguous nights to continue with your proposal');
    return result;
  }

  if (listing['Minimum Nights'] && selectedDays.length < listing['Minimum Nights']) {
    result.warnings.push(`Host prefers at least ${listing['Minimum Nights']} nights per week`);
  }
  // ... more conditional pushes
}
```

**Refactored Code:**
```javascript
/**
 * Pure validation functions that return error/warning messages
 */
const validateDaysSelected = (selectedDays) =>
  (!selectedDays || selectedDays.length === 0) ? 'Please select at least one day' : null;

const validateContiguous = (selectedDays) =>
  !isContiguousSelection(selectedDays)
    ? 'Please check for contiguous nights to continue with your proposal'
    : null;

const validateMinNights = (selectedDays, listing) =>
  listing['Minimum Nights'] && selectedDays.length < listing['Minimum Nights']
    ? `Host prefers at least ${listing['Minimum Nights']} nights per week`
    : null;

const validateMaxNights = (selectedDays, listing) =>
  listing['Maximum Nights'] && selectedDays.length > listing['Maximum Nights']
    ? `Host prefers at most ${listing['Maximum Nights']} nights per week`
    : null;

const validateAvailability = (selectedDays, listing) => {
  if (!listing['Days Not Available'] || !Array.isArray(listing['Days Not Available'])) {
    return null;
  }
  const unavailableDays = listing['Days Not Available'];
  const hasUnavailable = selectedDays.some(day =>
    unavailableDays.includes(DAY_NAMES[day])
  );
  return hasUnavailable ? 'Some selected days are not available for this listing' : null;
};

export function validateScheduleSelection(selectedDays, listing) {
  // Early exit validations (blocking errors)
  const daysError = validateDaysSelected(selectedDays);
  if (daysError) {
    return {
      valid: false,
      errors: [daysError],
      warnings: [],
      showTutorial: false,
      nightsCount: 0,
      isContiguous: false
    };
  }

  const isContiguous = isContiguousSelection(selectedDays);
  const contiguousError = validateContiguous(selectedDays);
  if (contiguousError) {
    return {
      valid: false,
      errors: [contiguousError],
      warnings: [],
      showTutorial: true,
      nightsCount: selectedDays.length,
      isContiguous: false
    };
  }

  // Non-blocking validations
  const availabilityError = validateAvailability(selectedDays, listing);
  const warnings = [
    validateMinNights(selectedDays, listing),
    validateMaxNights(selectedDays, listing)
  ].filter(Boolean);

  const errors = [availabilityError].filter(Boolean);

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    showTutorial: false,
    nightsCount: selectedDays.length,
    isContiguous: true
  };
}
```

**Why This Matters:**
Breaking validation into pure functions makes each rule testable in isolation. The main function becomes a composition of these validators with no internal mutation.

**Testing:**
- [ ] Unit test each validator function
- [ ] Integration test full validation with various inputs
- [ ] Verify early exit behavior for blocking errors

---

## FILE: app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts (15 violations)

### ðŸ”´ CHUNK 12: Refactor transformAvailableNights to use filter/map

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Lines:** 87-102
**Violation:** MUTATING_METHOD - Multiple result.push() calls
**Severity:** ðŸ”´ High

**Current Code:**
```typescript
function transformAvailableNights(
  nights: ListingFormData['leaseStyles']['availableNights']
): string[] {
  if (!nights) return [];

  const result: string[] = [];
  if (nights.sunday) result.push('sunday');
  if (nights.monday) result.push('monday');
  if (nights.tuesday) result.push('tuesday');
  if (nights.wednesday) result.push('wednesday');
  if (nights.thursday) result.push('thursday');
  if (nights.friday) result.push('friday');
  if (nights.saturday) result.push('saturday');

  return result;
}
```

**Refactored Code:**
```typescript
const DAYS_OF_WEEK = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'] as const;

function transformAvailableNights(
  nights: ListingFormData['leaseStyles']['availableNights']
): string[] {
  if (!nights) return [];

  return DAYS_OF_WEEK.filter(day => nights[day]);
}
```

**Why This Matters:**
Using a constant array with `filter()` is more maintainable and clearly expresses "select days where the value is truthy."

**Testing:**
- [ ] Verify all day names are correctly included when enabled
- [ ] Test with no days selected (should return empty array)
- [ ] Test with all days selected

---

## FILE: app/src/lib/availabilityValidation.js (continued)

### ðŸ”´ CHUNK 13: Replace errors.push in validateMonthlyMoveIn

**File:** app/src/lib/availabilityValidation.js
**Lines:** 265-310
**Violation:** MUTATING_METHOD - Multiple result.errors.push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
export function validateMonthlyMoveIn(moveInDate, listing) {
  const result = {
    valid: true,
    errors: [],
    warnings: [],
    formattedDate: null,
    dayOfWeek: null
  };

  if (!moveInDate) {
    result.valid = false;
    result.errors.push('Please select a move-in date');
    return result;
  }

  const date = new Date(moveInDate);
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  if (date < today) {
    result.valid = false;
    result.errors.push('Move-in date cannot be in the past');
    return result;
  }

  // ... more error pushes
}
```

**Refactored Code:**
```javascript
/**
 * Pure validation predicates for monthly move-in
 */
const moveInValidations = {
  noDateSelected: (date) => !date,
  dateInPast: (date) => {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    return new Date(date) < today;
  },
  outsideAvailableRange: (date, listing) => {
    const firstAvailable = listing['First Day Available']
      ? new Date(listing['First Day Available'])
      : null;
    const lastAvailable = listing['Last Day Available']
      ? new Date(listing['Last Day Available'])
      : null;
    const moveIn = new Date(date);
    return (firstAvailable && moveIn < firstAvailable) ||
           (lastAvailable && moveIn > lastAvailable);
  }
};

const ERROR_MESSAGES = {
  noDateSelected: 'Please select a move-in date',
  dateInPast: 'Move-in date cannot be in the past',
  outsideAvailableRange: 'Move-in date is outside available range'
};

export function validateMonthlyMoveIn(moveInDate, listing) {
  const baseResult = {
    formattedDate: moveInDate ? formatDate(moveInDate) : null,
    dayOfWeek: moveInDate ? new Date(moveInDate).getDay() : null,
    warnings: []
  };

  // Check each validation in order (early exit on failure)
  for (const [key, validate] of Object.entries(moveInValidations)) {
    if (validate(moveInDate, listing)) {
      return {
        ...baseResult,
        valid: false,
        errors: [ERROR_MESSAGES[key]]
      };
    }
  }

  return {
    ...baseResult,
    valid: true,
    errors: []
  };
}
```

**Why This Matters:**
Separating validation predicates from error messages makes both easier to maintain and test. The validation logic is now data-driven.

**Testing:**
- [ ] Test with no date selected
- [ ] Test with past date
- [ ] Test with date outside available range
- [ ] Test with valid date

---

## FILE: app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx (12 violations)

### ðŸ”´ CHUNK 14: Replace menuItems.push with declarative construction

**File:** app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx
**Lines:** Review entire file for push patterns
**Violation:** MUTATING_METHOD - Multiple menuItems.push() calls
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const menuItems = [];
menuItems.push({ label: 'Profile', href: '/account-profile' });
if (isHost) {
  menuItems.push({ label: 'Dashboard', href: '/listing-dashboard' });
  menuItems.push({ label: 'Proposals', href: '/proposals' });
}
if (isGuest) {
  menuItems.push({ label: 'My Proposals', href: '/guest-proposals' });
}
menuItems.push({ label: 'Settings', href: '/settings' });
menuItems.push({ label: 'Logout', onClick: handleLogout });
```

**Refactored Code:**
```javascript
const menuItems = [
  { label: 'Profile', href: '/account-profile' },
  isHost && { label: 'Dashboard', href: '/listing-dashboard' },
  isHost && { label: 'Proposals', href: '/proposals' },
  isGuest && { label: 'My Proposals', href: '/guest-proposals' },
  { label: 'Settings', href: '/settings' },
  { label: 'Logout', onClick: handleLogout }
].filter(Boolean);
```

**Why This Matters:**
Conditional array construction with `filter(Boolean)` is a common FP pattern that clearly shows all possible items upfront while filtering out falsy ones.

**Testing:**
- [ ] Test menu rendering for host users
- [ ] Test menu rendering for guest users
- [ ] Verify all menu items have correct labels and actions

---

## FILE: app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx (11 violations)

### ðŸ”´ CHUNK 15: Replace dates.push with spread operator

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Violation:** MUTATING_METHOD - dates.push() in loop
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const dates = [];
for (let i = 0; i < numDays; i++) {
  const date = new Date(startDate);
  date.setDate(date.getDate() + i);
  dates.push(date);
}
```

**Refactored Code:**
```javascript
const dates = Array.from({ length: numDays }, (_, i) => {
  const date = new Date(startDate);
  date.setDate(date.getDate() + i);
  return date;
});
```

**Why This Matters:**
`Array.from()` with a mapping function generates the array declaratively without mutation.

**Testing:**
- [ ] Verify date range generation is correct
- [ ] Test edge cases: single day, 30 days, 0 days

---

## FILE: app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx (10 violations)

### ðŸ”´ CHUNK 16: Refactor pricing validation to use declarative collection

**File:** app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx
**Violation:** MUTATING_METHOD - Multiple errors.push() calls
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const validatePricing = (values) => {
  const errors = [];
  if (values.damageDeposit < 500) {
    errors.push('Damage deposit must be at least $500');
  }
  if (rentalType === 'Monthly' && !values.monthlyCompensation) {
    errors.push('Monthly compensation is required');
  }
  // ... more conditionals
  return errors;
};
```

**Refactored Code:**
```javascript
const PRICING_VALIDATIONS = [
  { check: (v) => v.damageDeposit < 500, message: 'Damage deposit must be at least $500' },
  { check: (v, rt) => rt === 'Monthly' && !v.monthlyCompensation, message: 'Monthly compensation is required' },
  { check: (v, rt) => rt === 'Weekly' && !v.weeklyCompensation, message: 'Weekly compensation is required' },
  { check: (v, rt) => rt === 'Nightly' && !v.nightlyPrice, message: 'Nightly price is required' }
];

const validatePricing = (values, rentalType) =>
  PRICING_VALIDATIONS
    .filter(({ check }) => check(values, rentalType))
    .map(({ message }) => message);
```

**Why This Matters:**
Data-driven validation is easier to extend, test, and maintain than scattered conditional logic.

**Testing:**
- [ ] Test each validation rule
- [ ] Verify correct errors for each rental type
- [ ] Test valid pricing returns empty array

---

## FILE: app/src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx (10 violations)

### ðŸ”´ CHUNK 17: Replace options.push with declarative array

**File:** app/src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx
**Violation:** MUTATING_METHOD - options.push() for select dropdowns
**Severity:** ðŸ”´ High

**Current Code:**
```typescript
const bedroomOptions = [];
for (let i = 0; i <= 10; i++) {
  bedroomOptions.push({ value: i, label: i === 0 ? 'Studio' : String(i) });
}
```

**Refactored Code:**
```typescript
const bedroomOptions = Array.from({ length: 11 }, (_, i) => ({
  value: i,
  label: i === 0 ? 'Studio' : String(i)
}));
```

**Why This Matters:**
`Array.from()` with a mapping function is the declarative way to generate a sequence of objects.

**Testing:**
- [ ] Verify 0-10 options are generated
- [ ] Check 'Studio' label for 0 value
- [ ] Test dropdown renders correctly

---

## FILE: app/src/islands/pages/SelfListingPage/sections/Section5Rules.tsx (10 violations)

### ðŸ”´ CHUNK 18: Replace time options generation with declarative pattern

**File:** app/src/islands/pages/SelfListingPage/sections/Section5Rules.tsx
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP - for loop with push for time options
**Severity:** ðŸ”´ High

**Current Code:**
```typescript
const timeOptions = [];
for (let hour = 0; hour < 24; hour++) {
  const time12 = formatHourTo12(hour);
  timeOptions.push({ value: hour, label: time12 });
}
```

**Refactored Code:**
```typescript
const timeOptions = Array.from({ length: 24 }, (_, hour) => ({
  value: hour,
  label: formatHourTo12(hour)
}));
```

**Why This Matters:**
Same pattern as CHUNK 17 - declarative generation without mutation.

**Testing:**
- [ ] Verify 24 time options generated (0-23)
- [ ] Check 12-hour format labels are correct
- [ ] Test dropdown selection works

---

## FILE: app/src/islands/shared/SearchScheduleSelector.jsx (9 violations)

### ðŸ”´ CHUNK 19: Replace selectedDays manipulation with immutable operations

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Violation:** MUTATING_METHOD - .push() and splice for day selection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const toggleDay = (dayIndex) => {
  const newDays = [...selectedDays];
  const index = newDays.indexOf(dayIndex);
  if (index > -1) {
    newDays.splice(index, 1);
  } else {
    newDays.push(dayIndex);
  }
  setSelectedDays(newDays);
};
```

**Refactored Code:**
```javascript
const toggleDay = (dayIndex) => {
  const isDaySelected = selectedDays.includes(dayIndex);
  const newDays = isDaySelected
    ? selectedDays.filter(d => d !== dayIndex)
    : [...selectedDays, dayIndex];
  setSelectedDays(newDays);
};
```

**Why This Matters:**
Using `filter()` for removal and spread for addition avoids the mutation semantics of `splice()` and `push()`.

**Testing:**
- [ ] Test adding a day to selection
- [ ] Test removing a day from selection
- [ ] Test toggling same day multiple times

---

## FILE: app/src/lib/listingService.js (8 violations)

### ðŸ”´ CHUNK 20: Replace results.push in listing transformation

**File:** app/src/lib/listingService.js
**Violation:** MUTATING_METHOD - results.push() in data processing
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const transformListings = (listings) => {
  const results = [];
  for (const listing of listings) {
    const transformed = transformListing(listing);
    if (transformed) {
      results.push(transformed);
    }
  }
  return results;
};
```

**Refactored Code:**
```javascript
const transformListings = (listings) =>
  listings
    .map(transformListing)
    .filter(Boolean);
```

**Why This Matters:**
`map().filter(Boolean)` is the idiomatic FP way to transform and filter in one pass.

**Testing:**
- [ ] Verify all valid listings are transformed
- [ ] Test filtering of null/undefined results
- [ ] Check transformation accuracy

---

## FILE: app/src/lib/supabaseUtils.js (8 violations)

### ðŸ”´ CHUNK 21: Replace errors collection with declarative approach

**File:** app/src/lib/supabaseUtils.js
**Violation:** MUTATING_METHOD - errors.push() for error aggregation
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const validateConfig = (config) => {
  const errors = [];
  if (!config.supabaseUrl) {
    errors.push('SUPABASE_URL is required');
  }
  if (!config.supabaseKey) {
    errors.push('SUPABASE_ANON_KEY is required');
  }
  return errors;
};
```

**Refactored Code:**
```javascript
const CONFIG_VALIDATIONS = [
  { key: 'supabaseUrl', message: 'SUPABASE_URL is required' },
  { key: 'supabaseKey', message: 'SUPABASE_ANON_KEY is required' }
];

const validateConfig = (config) =>
  CONFIG_VALIDATIONS
    .filter(({ key }) => !config[key])
    .map(({ message }) => message);
```

**Why This Matters:**
Same declarative validation pattern used consistently across the codebase.

**Testing:**
- [ ] Test with missing URL
- [ ] Test with missing key
- [ ] Test with valid config

---

## FILE: app/src/islands/shared/HostScheduleSelector/utils.js (8 violations)

### ðŸ”´ CHUNK 22: Replace generateTimeSlots imperative loop

**File:** app/src/islands/shared/HostScheduleSelector/utils.js
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
export function generateTimeSlots(startHour = 0, endHour = 24, interval = 60) {
  const slots = [];
  for (let hour = startHour; hour < endHour; hour++) {
    for (let minute = 0; minute < 60; minute += interval) {
      slots.push({
        hour,
        minute,
        label: formatTime(hour, minute)
      });
    }
  }
  return slots;
}
```

**Refactored Code:**
```javascript
export function generateTimeSlots(startHour = 0, endHour = 24, interval = 60) {
  const hours = Array.from({ length: endHour - startHour }, (_, i) => startHour + i);
  const minuteSlots = Array.from({ length: Math.floor(60 / interval) }, (_, i) => i * interval);

  return hours.flatMap(hour =>
    minuteSlots.map(minute => ({
      hour,
      minute,
      label: formatTime(hour, minute)
    }))
  );
}
```

**Why This Matters:**
`flatMap()` elegantly handles the nested loop pattern in a declarative way.

**Testing:**
- [ ] Verify correct number of slots generated
- [ ] Test with different intervals (30, 60 minutes)
- [ ] Check time labels are formatted correctly

---

## FILE: app/src/islands/pages/SearchPage.jsx (8 violations)

### ðŸ”´ CHUNK 23: Replace filter results accumulation

**File:** app/src/islands/pages/SearchPage.jsx
**Violation:** MUTATING_METHOD - push() for filtered results
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const filterListings = (listings, filters) => {
  const results = [];
  for (const listing of listings) {
    if (matchesFilters(listing, filters)) {
      results.push(listing);
    }
  }
  return results;
};
```

**Refactored Code:**
```javascript
const filterListings = (listings, filters) =>
  listings.filter(listing => matchesFilters(listing, filters));
```

**Why This Matters:**
A simple `filter()` replaces the entire loop-with-conditional-push pattern.

**Testing:**
- [ ] Verify filtering logic remains correct
- [ ] Test with various filter combinations
- [ ] Check empty results case

---

## FILE: app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx (8 violations)

### ðŸ”´ CHUNK 24: Replace schedule manipulation with immutable updates

**File:** app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx
**Violation:** MUTATING_METHOD - Direct array manipulation
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const handleSlotClick = (dayIndex, slotIndex) => {
  const newSchedule = [...schedule];
  newSchedule[dayIndex].slots[slotIndex].selected = !newSchedule[dayIndex].slots[slotIndex].selected;
  setSchedule(newSchedule);
};
```

**Refactored Code:**
```javascript
const handleSlotClick = (dayIndex, slotIndex) => {
  setSchedule(schedule.map((day, di) =>
    di !== dayIndex ? day : {
      ...day,
      slots: day.slots.map((slot, si) =>
        si !== slotIndex ? slot : { ...slot, selected: !slot.selected }
      )
    }
  ));
};
```

**Why This Matters:**
Nested spread operators ensure complete immutability at all levels, preventing subtle state bugs.

**Testing:**
- [ ] Verify slot toggle works correctly
- [ ] Check that other slots/days are not affected
- [ ] Test rapid clicking doesn't cause issues

---

## FILE: app/src/lib/photoUpload.js (7 violations)

### ðŸ”´ CHUNK 25: Replace uploadedUrls.push with declarative pattern

**File:** app/src/lib/photoUpload.js
**Violation:** MUTATING_METHOD - push() in async loop
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const uploadPhotos = async (photos) => {
  const uploadedUrls = [];
  for (const photo of photos) {
    const url = await uploadSinglePhoto(photo);
    uploadedUrls.push(url);
  }
  return uploadedUrls;
};
```

**Refactored Code:**
```javascript
const uploadPhotos = async (photos) =>
  Promise.all(photos.map(photo => uploadSinglePhoto(photo)));
```

**Why This Matters:**
`Promise.all()` with `map()` is more performant (parallel uploads) and declarative.

**Testing:**
- [ ] Verify all photos are uploaded
- [ ] Test error handling for failed uploads
- [ ] Confirm parallel execution improves performance

---

## Additional Chunks (26-50)

The following files also contain violations and should be addressed following the same patterns:

| File | Violations | Pattern to Apply |
|------|------------|-----------------|
| src/islands/shared/EditListingDetails/useEditListingDetailsLogic.js | 7 | Declarative validation |
| src/islands/shared/VirtualMeetingManager/dateUtils.js | 7 | Array.from for date ranges |
| src/islands/pages/AccountProfilePage/useAccountProfilePageLogic.js | 7 | Declarative error collection |
| src/islands/pages/FavoriteListingsPage/formatters.js | 7 | map/filter transformations |
| src/lib/auth.js | 6 | Declarative session handling |
| src/islands/pages/ListingEditPage/useListingEditLogic.js | 6 | Immutable state updates |
| src/islands/shared/ProposalCard/formatters.js | 6 | Pure transformation functions |
| src/data/helpCenterData.js | 5 | flatMap for search results |
| src/lib/aiService.js | 5 | toSorted() for sorting |
| src/routes.config.js | 5 | Declarative route building |

---

## Summary

### High-Impact Refactoring Patterns

1. **Array building with .push()** â†’ Use `filter(Boolean)` with conditional items or `Array.from()`
2. **Imperative loops** â†’ Use `map()`, `filter()`, `reduce()`, or `flatMap()`
3. **Sorting with .sort()** â†’ Use `toSorted()` (ES2023)
4. **Validation with error.push()** â†’ Use declarative rule arrays with filter/map
5. **Nested state updates** â†’ Use spread operators at each level

### Testing Strategy

After each chunk is implemented:
1. Run existing tests: `bun run test` (if available)
2. Run linting: `bun run lint`
3. Run build: `bun run build`
4. Manual verification of affected feature

### Dependencies

- ES2023 features (`toSorted()`) may require polyfills for older browsers
- Some refactors may expose TypeScript type errors that need addressing

---

## File References

- agents/fp_audit_violations.json - Full violations list
- app/scripts/generate-redirects.js - Route generation script
- app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts - Local store
- app/src/lib/availabilityValidation.js - Availability validation
- app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts - Submission prep
- .claude/skills/functional-code/SKILL.md - FP guidelines
