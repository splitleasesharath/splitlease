# Functional Programming Refactoring Plan

Date: 2026-01-11
Target: agents/20260111113933_fp_audit_violations.json
Severity Filter: high

## Summary

| Metric | Value |
|--------|-------|
| **Total Violations** | 348 |
| **Unique Files** | 84 |
| **MUTATING_METHOD** | 263 (75.6%) |
| **IMPERATIVE_LOOP** | 80 (23.0%) |
| **IO_IN_CORE** | 5 (1.4%) |

### Top 10 Files by Violation Count

| File | Count |
|------|-------|
| listingLocalStore.ts | 21 |
| availabilityValidation.js | 15 |
| prepareListingSubmission.ts | 15 |
| LoggedInAvatar.jsx | 12 |
| AvailabilitySection.jsx | 11 |
| PricingEditSection.jsx | 10 |
| Section1SpaceSnapshot.tsx | 10 |
| Section5Rules.tsx | 10 |
| SearchScheduleSelector.jsx | 9 |
| listingService.js | 8 |

---

## Priority 1: Core Logic Files (Effects at Edges)

These are the most critical violations - I/O operations in pure business logic layers.

~~~~~

## CHUNK 1: Remove console.warn from proposalRules.js

**File:** app/src/logic/rules/proposals/proposalRules.js
**Line:** 306
**Violation:** IO_IN_CORE - console.warn in core business logic
**Severity:** High

**Expected Affected Pages:** /host-proposals, /guest-proposals, /view-split-lease

**Current Code:**
```javascript
console.warn('[getCancellationReasonOptions] Cache empty, using fallback values');
```

**Refactored Code:**
```javascript
// Remove console.warn - the function should return the fallback values silently
// If logging is needed, the caller (workflow layer) should handle it
```

**Why This Matters:**
Pure functions in the rules layer should never perform I/O (including console operations). This makes functions unpredictable and harder to test. Move logging to the workflow/handler layer that calls this function.

**Testing:**
- [ ] Run unit tests for proposalRules.js
- [ ] Verify getCancellationReasonOptions still returns fallback values correctly
- [ ] Check that no errors occur when cache is empty

~~~~~

## CHUNK 2: Remove console.error from extractListingCoordinates.js (line 46)

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 46
**Violation:** IO_IN_CORE - console.error in processor layer
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /favorite-listings

**Current Code:**
```javascript
console.error(
  'extractListingCoordinates: Missing coordinates in listing:',
  { listingId: listing._id }
);
```

**Refactored Code:**
```javascript
// Return a Result type with error information instead of logging
// The caller will decide how to handle the error (log, display, etc.)
return {
  success: false,
  coordinates: null,
  error: {
    type: 'MISSING_COORDINATES',
    listingId: listing._id
  }
};
```

**Why This Matters:**
Processors should be pure data transformers. I/O operations belong at the application boundaries. Return error information as data, letting the caller decide how to handle it.

**Testing:**
- [ ] Verify function returns structured error instead of logging
- [ ] Update callers to handle the new return format
- [ ] Check map rendering with missing coordinates

~~~~~

## CHUNK 3: Remove console.error from extractListingCoordinates.js (line 62)

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 62
**Violation:** IO_IN_CORE - console.error in processor layer
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /favorite-listings

**Current Code:**
```javascript
console.error('extractListingCoordinates: Failed to parse Location - Address:', {
  listingId: listing._id,
  address: listing['Location - Address']
});
```

**Refactored Code:**
```javascript
// Return structured error data instead of logging
return {
  success: false,
  coordinates: null,
  error: {
    type: 'PARSE_FAILED',
    listingId: listing._id,
    address: listing['Location - Address']
  }
};
```

**Why This Matters:**
Errors as values allow callers to make decisions about error handling. Logging in processors couples them to a specific I/O mechanism.

**Testing:**
- [ ] Verify error structure is returned correctly
- [ ] Test with malformed address data
- [ ] Ensure callers handle the error case

~~~~~

## CHUNK 4: Remove console.warn from extractListingCoordinates.js (line 98)

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 98
**Violation:** IO_IN_CORE - console.warn in processor layer
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /favorite-listings

**Current Code:**
```javascript
console.warn('extractListingCoordinates: No valid coordinates found for listing:', {
  listingId: listing._id
});
```

**Refactored Code:**
```javascript
// Return result with warning/info in the data structure
return {
  success: false,
  coordinates: null,
  warning: {
    type: 'NO_VALID_COORDINATES',
    listingId: listing._id
  }
};
```

**Why This Matters:**
Warnings should also be returned as data. The workflow layer can then decide whether to log, display to user, or ignore.

**Testing:**
- [ ] Verify warning structure is returned
- [ ] Check listing display when no coordinates found
- [ ] Ensure map gracefully handles missing coordinate cases

~~~~~

## CHUNK 5: Remove console.warn from processUserData.js

**File:** app/src/logic/processors/user/processUserData.js
**Line:** 58
**Violation:** IO_IN_CORE - console.warn in processor layer
**Severity:** High

**Expected Affected Pages:** /account-profile, /host-overview, /guest-proposals

**Current Code:**
```javascript
console.warn(`processUserData: User ${rawUser._id} has no name fields, using default`)
```

**Refactored Code:**
```javascript
// Return the processed data with a flag indicating default was used
// Remove the console.warn - caller can log if needed
const hasName = !!(firstName || lastName);
return {
  ...processedUser,
  _meta: {
    usedDefaultName: !hasName
  }
};
```

**Why This Matters:**
Processors should focus on data transformation. Metadata about the transformation (like "used default") can be included in the return value for callers to act upon.

**Testing:**
- [ ] Verify user data processes correctly with and without names
- [ ] Check _meta field is properly set
- [ ] Ensure UI handles users with default names

~~~~~

## Priority 2: High-Impact Shared Components

These files affect multiple pages and should be refactored early.

~~~~~

## CHUNK 6: Refactor menu items building in LoggedInAvatar.jsx

**File:** app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx
**Line:** 174-323
**Violation:** MUTATING_METHOD - Multiple items.push() calls
**Severity:** High

**Expected Affected Pages:** All authenticated pages (global header component)

**Current Code:**
```javascript
const items = [];

// Host section
if (showHostSection) {
  items.push({
    label: 'Host Overview',
    href: '/host-overview',
    icon: '...'
  });
}

if (showListings) {
  items.push({
    label: 'My Listings',
    href: '/account-profile/listings',
    icon: '...'
  });
}

// ... many more conditional pushes
```

**Refactored Code:**
```javascript
const items = [
  // Host section
  showHostSection && {
    label: 'Host Overview',
    href: '/host-overview',
    icon: '...'
  },
  showListings && {
    label: 'My Listings',
    href: '/account-profile/listings',
    icon: '...'
  },
  // Guest section
  showGuestSection && {
    label: 'My Proposals',
    href: '/guest-proposals',
    icon: '...'
  },
  showFavorites && {
    label: 'Favorites',
    href: '/favorite-listings',
    icon: '...'
  },
  // ... all other items
  // Settings section (always shown)
  { type: 'divider' },
  {
    label: 'Account Settings',
    href: '/account-profile',
    icon: '...'
  },
  {
    label: 'Sign Out',
    onClick: handleSignOut,
    icon: '...'
  }
].filter(Boolean);
```

**Why This Matters:**
Declarative array construction shows all possible menu items at a glance. The filter(Boolean) removes any falsy values from conditional items, making the logic cleaner and more predictable.

**Testing:**
- [ ] Verify all menu items appear correctly for host users
- [ ] Verify all menu items appear correctly for guest users
- [ ] Test hybrid users see correct combined menu
- [ ] Check dividers appear in correct positions

~~~~~

## CHUNK 7: Refactor CSS class building in HostScheduleSelector.jsx

**File:** app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx
**Line:** 248-309
**Violation:** MUTATING_METHOD - Multiple classes.push() calls
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /account-profile, /edit-listing

**Current Code:**
```javascript
const classes = ['hss-day'];
if (isSelected) classes.push('hss-selected');
if (isNonContiguous) classes.push('hss-non-contiguous');
if (!isAvailable) classes.push('hss-unavailable');
if (disabled) classes.push('hss-disabled');
if (isPreviewMode) classes.push('hss-preview-mode');
if (isStepByStepMode) classes.push('hss-step-by-step-mode');
if (isProposalMode) classes.push('hss-proposal-mode');
if (className) classes.push(className);
```

**Refactored Code:**
```javascript
const classes = [
  'hss-day',
  isSelected && 'hss-selected',
  isNonContiguous && 'hss-non-contiguous',
  !isAvailable && 'hss-unavailable',
  disabled && 'hss-disabled',
  isPreviewMode && 'hss-preview-mode',
  isStepByStepMode && 'hss-step-by-step-mode',
  isProposalMode && 'hss-proposal-mode',
  className
].filter(Boolean).join(' ');
```

**Why This Matters:**
Declarative class construction is a common React pattern. All possible classes are visible at once, making it easier to understand the component's styling states.

**Testing:**
- [ ] Verify selected days have correct styling
- [ ] Check non-contiguous warning styles
- [ ] Test disabled state appearance
- [ ] Verify all modes render correctly

~~~~~

## CHUNK 8: Replace .push() with declarative array in SearchScheduleSelector.jsx gap detection

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Line:** 319-346
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP - for loop with push
**Severity:** High

**Expected Affected Pages:** /search, /favorite-listings

**Current Code:**
```javascript
const sortedDays = [...daysArray].sort((a, b) => a - b);
let hasGaps = false;

for (let i = 1; i < sortedDays.length; i++) {
  const prev = sortedDays[i - 1];
  const curr = sortedDays[i];
  const gap = (curr - prev + 7) % 7;
  if (gap > 1) {
    hasGaps = true;
    break;
  }
}
```

**Refactored Code:**
```javascript
const sortedDays = [...daysArray].toSorted((a, b) => a - b);

const hasGaps = sortedDays.some((curr, i) => {
  if (i === 0) return false;
  const prev = sortedDays[i - 1];
  const gap = (curr - prev + 7) % 7;
  return gap > 1;
});
```

**Why This Matters:**
Using `some()` expresses intent clearly: "do any adjacent days have a gap?" The early termination behavior is preserved (some stops on first true), but the code is more declarative.

**Testing:**
- [ ] Test with contiguous day selections (no gaps)
- [ ] Test with non-contiguous selections (has gaps)
- [ ] Verify edge case: days wrapping around week (Sat-Sun)
- [ ] Check schedule selector UI reflects gap detection

~~~~~

## CHUNK 9: Replace .sort() with .toSorted() in SearchScheduleSelector.jsx

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Line:** 546, 617
**Violation:** MUTATING_METHOD - Using .sort() on arrays
**Severity:** High

**Expected Affected Pages:** /search, /favorite-listings

**Current Code:**
```javascript
// Line 546
const sortedDays = [...selectedDaysArray].sort((a, b) => a - b);

// Line 617
const selectedDaysArray = Array.from(selectedDays).sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
// Line 546
const sortedDays = [...selectedDaysArray].toSorted((a, b) => a - b);

// Line 617
const selectedDaysArray = Array.from(selectedDays).toSorted((a, b) => a - b);
```

**Why This Matters:**
`.toSorted()` is the immutable alternative to `.sort()`. While the current code creates a copy before sorting, using `.toSorted()` expresses immutable intent more clearly and is the modern best practice.

**Testing:**
- [ ] Verify day sorting still works correctly
- [ ] Test schedule selection with various day combinations
- [ ] Check that original arrays are not mutated (already the case, but verify)

~~~~~

## CHUNK 10: Refactor validation error collection in availabilityValidation.js

**File:** app/src/lib/availabilityValidation.js
**Line:** 166-305
**Violation:** MUTATING_METHOD - Multiple result.errors.push() and result.warnings.push()
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /host-proposals, /guest-proposals

**Current Code:**
```javascript
const result = { errors: [], warnings: [], valid: true };

if (selectedDays.length === 0) {
  result.errors.push('Please select at least one day');
}
if (!isContiguous) {
  result.errors.push('Please check for contiguous nights to continue with your proposal');
}
if (belowMinNights) {
  result.warnings.push(`Host prefers at least ${listing['Minimum Nights']} nights per week`);
}
if (aboveMaxNights) {
  result.warnings.push(`Host prefers at most ${listing['Maximum Nights']} nights per week`);
}
// ... more conditions
```

**Refactored Code:**
```javascript
const errors = [
  selectedDays.length === 0 && 'Please select at least one day',
  !isContiguous && 'Please check for contiguous nights to continue with your proposal',
  hasUnavailableDays && 'Some selected days are not available for this listing',
  !moveInDate && 'Please select a move-in date',
  isPastMoveIn && 'Move-in date cannot be in the past',
  isOutsideRange && 'Move-in date is outside available range',
  !isAvailableMoveIn && 'Selected move-in date is not available',
  !isCorrectCheckInDay && `Move-in date must be on a ${DAY_NAMES[checkInDay]} based on your selected schedule`
].filter(Boolean);

const warnings = [
  belowMinNights && `Host prefers at least ${listing['Minimum Nights']} nights per week`,
  aboveMaxNights && `Host prefers at most ${listing['Maximum Nights']} nights per week`
].filter(Boolean);

return {
  errors,
  warnings,
  valid: errors.length === 0
};
```

**Why This Matters:**
Declarative construction makes all possible errors and warnings visible in one place. This is easier to maintain and test than scattered conditional pushes throughout the function.

**Testing:**
- [ ] Test each error condition individually
- [ ] Verify warnings appear but don't block submission
- [ ] Check combined error/warning scenarios
- [ ] Ensure valid flag is correctly computed

~~~~~

## Priority 3: Business Logic (Calculators/Rules)

~~~~~

## CHUNK 11: Replace .sort() with .toSorted() in calculateCheckInOutDays.js

**File:** app/src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 50
**Violation:** MUTATING_METHOD - Using [...arr].sort()
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /host-proposals, /guest-proposals

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
const sorted = [...selectedDays].toSorted((a, b) => a - b)
```

**Why This Matters:**
Calculators should be pure functions. Using `.toSorted()` ensures immutability and signals that this is a pure transformation.

**Testing:**
- [ ] Verify check-in/out day calculation remains accurate
- [ ] Test with various day selection patterns
- [ ] Ensure proposal schedule displays correctly

~~~~~

## CHUNK 12: Refactor contiguity check loop in calculateCheckInOutDays.js

**File:** app/src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 59
**Violation:** IMPERATIVE_LOOP - for loop to detect gaps
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /host-proposals, /guest-proposals

**Current Code:**
```javascript
for (let i = 1; i < sorted.length; i++) {
  const prev = sorted[i - 1];
  const curr = sorted[i];
  if ((curr - prev + 7) % 7 !== 1) {
    return { checkInDay: null, checkOutDay: null, isContiguous: false };
  }
}
```

**Refactored Code:**
```javascript
const isContiguous = sorted.every((curr, i) => {
  if (i === 0) return true;
  const prev = sorted[i - 1];
  return (curr - prev + 7) % 7 === 1;
});

if (!isContiguous) {
  return { checkInDay: null, checkOutDay: null, isContiguous: false };
}
```

**Why This Matters:**
Using `every()` clearly expresses the intent: "all adjacent pairs must be consecutive." The declarative approach is more readable and maintainable.

**Testing:**
- [ ] Test contiguous selections (Mon-Tue-Wed)
- [ ] Test non-contiguous selections (Mon-Wed)
- [ ] Test week-wrapping (Sat-Sun-Mon)
- [ ] Verify check-in/out calculation for valid selections

~~~~~

## CHUNK 13: Replace .sort() with .toSorted() in calculateNextAvailableCheckIn.js

**File:** app/src/logic/calculators/scheduling/calculateNextAvailableCheckIn.js
**Line:** 54
**Violation:** MUTATING_METHOD - Using [...arr].sort()
**Severity:** High

**Expected Affected Pages:** /view-split-lease

**Current Code:**
```javascript
const sortedDays = [...selectedDayIndices].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
const sortedDays = [...selectedDayIndices].toSorted((a, b) => a - b)
```

**Why This Matters:**
Consistent use of `.toSorted()` in calculators reinforces the pure function pattern across the codebase.

**Testing:**
- [ ] Verify next available check-in calculation
- [ ] Test with various move-in date selections
- [ ] Check calendar shows correct available dates

~~~~~

## CHUNK 14: Refactor contiguity check in isScheduleContiguous.js

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 64-96
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with push
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search, /host-proposals

**Current Code:**
```javascript
for (let i = 1; i < sorted.length; i++) {
  const prev = sorted[i - 1];
  const curr = sorted[i];
  const gap = (curr - prev + 7) % 7;
  if (gap > 1) {
    return false;
  }
}

// Later:
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i)
}
```

**Refactored Code:**
```javascript
// Check contiguity
const isContiguous = sorted.every((curr, i) => {
  if (i === 0) return true;
  const prev = sorted[i - 1];
  return (curr - prev + 7) % 7 === 1;
});

if (!isContiguous) return false;

// Generate expected not-selected days
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
Rules should be pure predicates. Using `every()` and `Array.from()` makes the logic declarative and removes mutation.

**Testing:**
- [ ] Test contiguous schedule detection
- [ ] Test non-contiguous schedule detection
- [ ] Verify gap detection works across week boundary
- [ ] Check UI correctly shows contiguity warnings

~~~~~

## CHUNK 15: Refactor gap detection in HostScheduleSelector/utils.js

**File:** app/src/islands/shared/HostScheduleSelector/utils.js
**Line:** 25-65
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP - sort and loop with push
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /account-profile

**Current Code:**
```javascript
const numbers = nights.map(n => getDayIndex(n)).sort((a, b) => a - b);

for (let i = 1; i < numbers.length; i++) {
  // ... gap detection logic
  gaps.push(i);
}

// Sequence building:
for (let i = startIdx; i <= endIdx; i++) {
  sequence.push(getNightByDayIndex(i).id);
}
```

**Refactored Code:**
```javascript
const numbers = nights.map(n => getDayIndex(n)).toSorted((a, b) => a - b);

// Detect gaps using reduce
const gaps = numbers.reduce((acc, curr, i) => {
  if (i === 0) return acc;
  const prev = numbers[i - 1];
  const gap = (curr - prev + 7) % 7;
  return gap > 1 ? [...acc, i] : acc;
}, []);

// Build sequence using Array.from
const sequence = Array.from(
  { length: endIdx - startIdx + 1 },
  (_, i) => getNightByDayIndex(startIdx + i).id
);
```

**Why This Matters:**
Utility functions should be pure. Using `.toSorted()`, `reduce()`, and `Array.from()` eliminates all mutation, making these utilities easier to test and reason about.

**Testing:**
- [ ] Verify gap detection for various night selections
- [ ] Test sequence generation
- [ ] Check host schedule selector UI reflects changes correctly

~~~~~

## Priority 4: Page Components

~~~~~

## CHUNK 16: Refactor location parts building in SearchPage.jsx

**File:** app/src/islands/pages/SearchPage.jsx
**Line:** 1979-1980
**Violation:** MUTATING_METHOD - Conditional pushes
**Severity:** High

**Expected Affected Pages:** /search

**Current Code:**
```javascript
const locationParts = [];
if (neighborhoodName) locationParts.push(neighborhoodName);
if (boroughName) locationParts.push(boroughName);
```

**Refactored Code:**
```javascript
const locationParts = [
  neighborhoodName,
  boroughName
].filter(Boolean);
```

**Why This Matters:**
This is a common pattern throughout the codebase. Using filter(Boolean) is more concise and shows all parts at once.

**Testing:**
- [ ] Verify location display with neighborhood only
- [ ] Verify location display with borough only
- [ ] Verify location display with both
- [ ] Check search results header displays correctly

~~~~~

## CHUNK 17: Replace .sort() with .toSorted() in SearchPage.jsx

**File:** app/src/islands/pages/SearchPage.jsx
**Line:** 89, 2318
**Violation:** MUTATING_METHOD - Using [...arr].sort()
**Severity:** High

**Expected Affected Pages:** /search

**Current Code:**
```javascript
// Line 89
const sortedDays = [...selectedDaysArray].sort((a, b) => a - b);

// Line 2318
const sortedJsDays = [...daysInJsFormat].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
// Line 89
const sortedDays = [...selectedDaysArray].toSorted((a, b) => a - b);

// Line 2318
const sortedJsDays = [...daysInJsFormat].toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent use of `.toSorted()` across the codebase ensures immutability is explicit and predictable.

**Testing:**
- [ ] Verify search filter day sorting
- [ ] Check schedule display in search results
- [ ] Test mobile and desktop views

~~~~~

## CHUNK 18: Refactor contiguity check loop in SearchPage.jsx

**File:** app/src/islands/pages/SearchPage.jsx
**Line:** 99, 2330
**Violation:** IMPERATIVE_LOOP - for loop for gap detection
**Severity:** High

**Expected Affected Pages:** /search

**Current Code:**
```javascript
for (let i = 1; i < sortedDays.length; i++) {
  const prev = sortedDays[i - 1];
  const curr = sortedDays[i];
  // gap detection logic
}
```

**Refactored Code:**
```javascript
const hasGap = sortedDays.some((curr, i) => {
  if (i === 0) return false;
  const prev = sortedDays[i - 1];
  const gap = (curr - prev + 7) % 7;
  return gap > 1;
});
```

**Why This Matters:**
`some()` clearly expresses the intent to find if any gap exists. Early termination is preserved.

**Testing:**
- [ ] Test search with contiguous day filter
- [ ] Test search with non-contiguous day filter
- [ ] Verify schedule selector warning appears

~~~~~

## CHUNK 19: Refactor features array building in ViewSplitLeasePage-old.jsx

**File:** app/src/islands/pages/ViewSplitLeasePage-old.jsx
**Line:** 250-266
**Violation:** MUTATING_METHOD - Conditional pushes for features
**Severity:** High

**Expected Affected Pages:** /view-split-lease (legacy version)

**Current Code:**
```javascript
const features = [];
if (listing['Kitchen Type']) {
  features.push({ icon: 'chef-hat', text: listing['Kitchen Type'] });
}
if (count) {
  features.push({ icon: 'bath', text: `${count} ${text}` });
}
if (listing.resolvedTypeOfSpace) {
  features.push({ icon: 'home', text: listing.resolvedTypeOfSpace });
}
if (bedCount) {
  features.push({ icon: 'bed-double', text: `${bedCount} ${bedText}` });
}
```

**Refactored Code:**
```javascript
const features = [
  listing['Kitchen Type'] && { icon: 'chef-hat', text: listing['Kitchen Type'] },
  bathCount && { icon: 'bath', text: `${bathCount} ${bathText}` },
  listing.resolvedTypeOfSpace && { icon: 'home', text: listing.resolvedTypeOfSpace },
  bedCount && { icon: 'bed-double', text: `${bedCount} ${bedText}` }
].filter(Boolean);
```

**Why This Matters:**
Declarative construction shows all possible features at a glance, making the code easier to maintain.

**Testing:**
- [ ] Verify all features display correctly
- [ ] Test listing with missing optional features
- [ ] Check feature icons render properly

~~~~~

## CHUNK 20: Replace .sort() with .toSorted() in ViewSplitLeasePage.jsx

**File:** app/src/islands/pages/ViewSplitLeasePage.jsx
**Line:** 798, 1256
**Violation:** MUTATING_METHOD - Using [...arr].sort()
**Severity:** High

**Expected Affected Pages:** /view-split-lease

**Current Code:**
```javascript
// Line 798
const sortedDays = [...selectedDayNumbers].sort((a, b) => a - b);

// Line 1256
const sortedJsDays = [...daysInJsFormat].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
// Line 798
const sortedDays = [...selectedDayNumbers].toSorted((a, b) => a - b);

// Line 1256
const sortedJsDays = [...daysInJsFormat].toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent immutable operations across page components.

**Testing:**
- [ ] Verify listing page day display
- [ ] Check proposal creation flow
- [ ] Test schedule selector functionality

~~~~~

## Priority 5: Service Layer

~~~~~

## CHUNK 21: Refactor day iteration in listingService.js

**File:** app/src/lib/listingService.js
**Line:** 766-768
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for...of with push
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /edit-listing, /host-overview

**Current Code:**
```javascript
for (const day of dayOrder) {
  if (availableDays.includes(day)) {
    result.push(dayNameMapping[day]);
  }
}
```

**Refactored Code:**
```javascript
const result = dayOrder
  .filter(day => availableDays.includes(day))
  .map(day => dayNameMapping[day]);
```

**Why This Matters:**
Filter-then-map is a standard FP pattern that clearly separates the selection from the transformation.

**Testing:**
- [ ] Verify available days display correctly
- [ ] Test with various day availability patterns
- [ ] Check listing dashboard schedule display

~~~~~

## CHUNK 22: Refactor Object.entries loop in listingService.js

**File:** app/src/lib/listingService.js
**Line:** 982, 1076-1082
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for...of with push
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /edit-listing

**Current Code:**
```javascript
for (const [key, value] of Object.entries(formData)) {
  // transformation logic
}

for (const [day, isSelected] of Object.entries(availableNights)) {
  if (isSelected) {
    result.push(dayMapping[day]);
  }
}
return result.sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const transformedData = Object.fromEntries(
  Object.entries(formData).map(([key, value]) => [key, transformValue(value)])
);

const result = Object.entries(availableNights)
  .filter(([_, isSelected]) => isSelected)
  .map(([day]) => dayMapping[day])
  .toSorted((a, b) => a - b);
```

**Why This Matters:**
Object.entries with filter/map is the idiomatic way to transform objects in a declarative style.

**Testing:**
- [ ] Verify form data transformation
- [ ] Test night selection to index conversion
- [ ] Check listing update saves correctly

~~~~~

## CHUNK 23: Refactor data lookups in dataLookups.js

**File:** app/src/lib/dataLookups.js
**Line:** 562-615
**Violation:** MUTATING_METHOD - push and sort operations
**Severity:** High

**Expected Affected Pages:** /host-proposals, /guest-proposals, /view-split-lease

**Current Code:**
```javascript
const policies = [];
for (const [id, policy] of Object.entries(CANCELLATION_POLICIES)) {
  policies.push({ id, display: policy.display });
}

const reasons = [];
for (const [id, reason] of Object.entries(DECLINE_REASONS)) {
  reasons.push({
    id,
    display: reason.display,
    displayOrder: reason.displayOrder
  });
}
return reasons.sort((a, b) => a.displayOrder - b.displayOrder);
```

**Refactored Code:**
```javascript
const policies = Object.entries(CANCELLATION_POLICIES)
  .map(([id, policy]) => ({ id, display: policy.display }));

const reasons = Object.entries(DECLINE_REASONS)
  .map(([id, reason]) => ({
    id,
    display: reason.display,
    displayOrder: reason.displayOrder
  }))
  .toSorted((a, b) => a.displayOrder - b.displayOrder);
```

**Why This Matters:**
Object.entries().map() is the declarative way to transform object dictionaries into arrays.

**Testing:**
- [ ] Verify cancellation policies display correctly
- [ ] Check decline reasons are sorted by display order
- [ ] Test proposal decline flow

~~~~~

## CHUNK 24: Refactor photo URL building in supabaseUtils.js

**File:** app/src/lib/supabaseUtils.js
**Line:** 178-274
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for...of with push
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search, /listing-dashboard

**Current Code:**
```javascript
const photoUrls = [];
for (const photo of photos) {
  const photoUrl = await getSignedUrl(photo);
  if (photoUrl) {
    photoUrls.push(photoUrl);
  }
}

// Later:
for (const [key, amenity] of Object.entries(amenitiesMap)) {
  if (listing[key]) {
    amenities.push(amenity);
  }
}
amenities.sort((a, b) => a.priority - b.priority);
```

**Refactored Code:**
```javascript
// For async operations, use Promise.all with map
const photoUrls = (await Promise.all(
  photos.map(photo => getSignedUrl(photo))
)).filter(Boolean);

// For amenities:
const amenities = Object.entries(amenitiesMap)
  .filter(([key]) => listing[key])
  .map(([_, amenity]) => amenity)
  .toSorted((a, b) => a.priority - b.priority);
```

**Why This Matters:**
Promise.all with map is the FP pattern for async operations. It's also more performant as it runs requests in parallel rather than sequentially.

**Testing:**
- [ ] Verify photo URLs are fetched correctly
- [ ] Test amenities display in correct priority order
- [ ] Check listing photos load properly

~~~~~

## Priority 6: Form Validation and Error Collection

~~~~~

## CHUNK 25: Refactor validation errors in listingLocalStore.ts

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 387-454
**Violation:** MUTATING_METHOD - Multiple errors.push() calls
**Severity:** High

**Expected Affected Pages:** /self-listing (new listing creation)

**Current Code:**
```typescript
const errors: string[] = [];
if (!payload.Name) errors.push('Listing name is required');
if (!payload['Type of Space']) errors.push('Type of space is required');
if (!payload['Kitchen Type']) errors.push('Type of kitchen is required');
if (!payload['Type of Parking']) errors.push('Type of parking is required');
// ... many more conditions
```

**Refactored Code:**
```typescript
const errors = [
  !payload.Name && 'Listing name is required',
  !payload['Type of Space'] && 'Type of space is required',
  !payload['Kitchen Type'] && 'Type of kitchen is required',
  !payload['Type of Parking'] && 'Type of parking is required',
  !payload.Address && 'Valid NYC address is required',
  !payload['Inside-Unit Amenities']?.length && 'At least one amenity inside unit is required',
  !payload.Description && 'Description of lodging is required',
  !payload['Rental Type'] && 'Rental type is required',
  !hasAvailableNights && 'At least one available night must be selected',
  !payload['Weeks Offered'] && 'Weekly pattern is required',
  (payload['Damage Deposit'] || 0) < 500 && 'Damage deposit must be at least $500',
  isMonthly && !payload['Monthly Compensation'] && 'Monthly compensation is required',
  isWeekly && !payload['Weekly Compensation'] && 'Weekly compensation is required',
  isNightly && !payload['Nightly Pricing'] && 'Nightly pricing is required',
  !payload['Cancellation Policy'] && 'Cancellation policy is required',
  !payload['Check-In Time'] && 'Check-in time is required',
  !payload['Check-Out Time'] && 'Check-out time is required',
  photoCount < minRequired && `At least ${minRequired} photos are required`
].filter(Boolean) as string[];
```

**Why This Matters:**
All validation rules are visible in one place. This makes it easy to add, remove, or modify validation without hunting through scattered conditionals.

**Testing:**
- [ ] Test each validation rule individually
- [ ] Verify all errors display on incomplete form
- [ ] Test successful submission with all fields valid
- [ ] Check error messages are user-friendly

~~~~~

## CHUNK 26: Refactor night selection in prepareListingSubmission.ts

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Line:** 93-99
**Violation:** MUTATING_METHOD - Conditional push for each day
**Severity:** High

**Expected Affected Pages:** /self-listing

**Current Code:**
```typescript
const result: string[] = [];
if (nights.sunday) result.push('sunday');
if (nights.monday) result.push('monday');
if (nights.tuesday) result.push('tuesday');
if (nights.wednesday) result.push('wednesday');
if (nights.thursday) result.push('thursday');
if (nights.friday) result.push('friday');
if (nights.saturday) result.push('saturday');
```

**Refactored Code:**
```typescript
const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'] as const;

const result = dayNames.filter(day => nights[day]);
```

**Why This Matters:**
Using an array of day names and filter is more concise, less error-prone, and easier to maintain.

**Testing:**
- [ ] Verify all day selections are captured
- [ ] Test with single day selected
- [ ] Test with all days selected
- [ ] Check listing creation saves correct nights

~~~~~

## CHUNK 27: Refactor validation errors in prepareListingSubmission.ts

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Line:** 270-288
**Violation:** MUTATING_METHOD - Conditional push for validation errors
**Severity:** High

**Expected Affected Pages:** /self-listing

**Current Code:**
```typescript
const errors: string[] = [];
if (!payload.Name) errors.push('Name is required');
if (!payload['Type of Space']) errors.push('Type of Space is required');
if (!payload.Address) errors.push('Address is required');
if (!payload['Rental Type']) errors.push('Rental Type is required');
if (isMonthly && !payload['Monthly Compensation']) {
  errors.push('Monthly Compensation is required for Monthly rentals');
}
// ... more conditions
```

**Refactored Code:**
```typescript
const isMonthly = payload['Rental Type'] === 'Monthly';
const isWeekly = payload['Rental Type'] === 'Weekly';
const isNightly = payload['Rental Type'] === 'Nightly';

const errors = [
  !payload.Name && 'Name is required',
  !payload['Type of Space'] && 'Type of Space is required',
  !payload.Address && 'Address is required',
  !payload['Rental Type'] && 'Rental Type is required',
  isMonthly && !payload['Monthly Compensation'] && 'Monthly Compensation is required for Monthly rentals',
  isWeekly && !payload['Weekly Compensation'] && 'Weekly Compensation is required for Weekly rentals',
  isNightly && !payload['Nightly Pricing'] && 'Nightly pricing is required for Nightly rentals',
  (payload['Damage Deposit'] || 0) < 500 && 'Damage Deposit must be at least $500'
].filter(Boolean) as string[];
```

**Why This Matters:**
Consistent validation pattern across the codebase. All rules visible at a glance.

**Testing:**
- [ ] Verify each validation rule triggers correctly
- [ ] Test rental type-specific validations
- [ ] Check form cannot submit with errors
- [ ] Verify error display in UI

~~~~~

## CHUNK 28: Refactor error collection in Section1SpaceSnapshot.tsx

**File:** app/src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx
**Line:** 291-329
**Violation:** MUTATING_METHOD - Conditional push for error order
**Severity:** High

**Expected Affected Pages:** /self-listing

**Current Code:**
```typescript
const errorOrder: string[] = [];
if (!listingName || listingName.length < 5) errorOrder.push('listingName');
if (!typeOfSpace) errorOrder.push('typeOfSpace');
if (!bedrooms) errorOrder.push('bedrooms');
if (!typeOfKitchen) errorOrder.push('typeOfKitchen');
if (!typeOfParking) errorOrder.push('typeOfParking');
if (!bathrooms) errorOrder.push('bathrooms');
if (!fullAddress || !fullAddress.isValid) errorOrder.push('fullAddress');
```

**Refactored Code:**
```typescript
const errorOrder = [
  (!listingName || listingName.length < 5) && 'listingName',
  !typeOfSpace && 'typeOfSpace',
  !bedrooms && 'bedrooms',
  !typeOfKitchen && 'typeOfKitchen',
  !typeOfParking && 'typeOfParking',
  !bathrooms && 'bathrooms',
  (!fullAddress || !fullAddress.isValid) && 'fullAddress'
].filter(Boolean) as string[];
```

**Why This Matters:**
Field order for error scrolling is declaratively defined. Easy to reorder or add fields.

**Testing:**
- [ ] Verify form scrolls to first error
- [ ] Test error order matches form field order
- [ ] Check all required fields trigger errors

~~~~~

## Priority 7: Calendar and Date Generation

~~~~~

## CHUNK 29: Refactor calendar generation in AvailabilitySection.jsx

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Line:** 45-134
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Multiple loops with push
**Severity:** High

**Expected Affected Pages:** /listing-dashboard

**Current Code:**
```javascript
// Generate date range
while (current <= end) {
  dates.push(formatDateKey(current));
  current = addDays(current, 1);
}

// Generate calendar days
for (let i = startPadding - 1; i >= 0; i--) {
  days.push({ date: prevMonthDate, isOtherMonth: true });
}
for (let i = 1; i <= daysInMonth; i++) {
  days.push({ date: currentDate, isOtherMonth: false });
}
for (let i = 1; i <= remaining; i++) {
  days.push({ date: nextMonthDate, isOtherMonth: true });
}
```

**Refactored Code:**
```javascript
// Generate date range
const dates = Array.from(
  { length: differenceInDays(end, start) + 1 },
  (_, i) => formatDateKey(addDays(start, i))
);

// Generate calendar days
const prevMonthDays = Array.from(
  { length: startPadding },
  (_, i) => ({
    date: subDays(firstDay, startPadding - i),
    isOtherMonth: true
  })
);

const currentMonthDays = Array.from(
  { length: daysInMonth },
  (_, i) => ({
    date: addDays(firstDay, i),
    isOtherMonth: false
  })
);

const nextMonthDays = Array.from(
  { length: remaining },
  (_, i) => ({
    date: addDays(lastDay, i + 1),
    isOtherMonth: true
  })
);

const days = [...prevMonthDays, ...currentMonthDays, ...nextMonthDays];
```

**Why This Matters:**
Array.from with index-based generation is the declarative way to create sequences. The calendar structure is clearly visible as three concatenated arrays.

**Testing:**
- [ ] Verify calendar displays correct month
- [ ] Check previous/next month padding days
- [ ] Test navigation between months
- [ ] Verify availability status is correct

~~~~~

## CHUNK 30: Refactor time slot generation in cohostService.js

**File:** app/src/islands/shared/ScheduleCohost/cohostService.js
**Line:** 40-66
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Nested loops with push
**Severity:** High

**Expected Affected Pages:** /schedule-cohost

**Current Code:**
```javascript
// Generate days
for (let i = 0; i < totalDays; i++) {
  const date = addDays(startDate, i);
  days.push(date);
}

// Generate time slots
for (let hour = startHour; hour < endHour; hour++) {
  for (let minutes = 0; minutes < 60; minutes += intervalMinutes) {
    slots.push({
      hour,
      minutes,
      display: formatTime(hour, minutes)
    });
  }
}
```

**Refactored Code:**
```javascript
// Generate days
const days = Array.from(
  { length: totalDays },
  (_, i) => addDays(startDate, i)
);

// Generate time slots
const slotsPerHour = 60 / intervalMinutes;
const totalSlots = (endHour - startHour) * slotsPerHour;

const slots = Array.from({ length: totalSlots }, (_, i) => {
  const hour = startHour + Math.floor(i / slotsPerHour);
  const minutes = (i % slotsPerHour) * intervalMinutes;
  return {
    hour,
    minutes,
    display: formatTime(hour, minutes)
  };
});
```

**Why This Matters:**
Flattening nested loops into a single Array.from is cleaner and avoids mutation entirely.

**Testing:**
- [ ] Verify correct number of days generated
- [ ] Check time slots are at correct intervals
- [ ] Test slot selection functionality
- [ ] Verify display format is correct

~~~~~

## Priority 8: Proposal and Listings Components

~~~~~

## CHUNK 31: Refactor change tracking in PricingEditSection.jsx

**File:** app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx
**Line:** 326-371
**Violation:** MUTATING_METHOD - Conditional push for change descriptions
**Severity:** High

**Expected Affected Pages:** /listing-dashboard

**Current Code:**
```javascript
const changes = [];
if (leaseStyleChanged) {
  changes.push(`Lease style: ${originalLeaseStyle} → ${selectedRentalType}`);
}
if (depositChanged) {
  changes.push(`Damage deposit: $${listing?.damageDeposit || 500} → $${damageDeposit}`);
}
if (maintenanceChanged) {
  changes.push(`Maintenance fee: $${listing?.maintenanceFee || 125} → $${maintenanceFee}`);
}
// ... more changes
```

**Refactored Code:**
```javascript
const changes = [
  leaseStyleChanged && `Lease style: ${originalLeaseStyle} → ${selectedRentalType}`,
  depositChanged && `Damage deposit: $${listing?.damageDeposit || 500} → $${damageDeposit}`,
  maintenanceChanged && `Maintenance fee: $${listing?.maintenanceFee || 125} → $${maintenanceFee}`,
  nightsChanged && `Available nights updated (${selectedNights.length} nights)`,
  nightsRangeChanged && `Nights range: ${minNights}-${maxNights}`,
  nightlyRatesChanged && 'Nightly rates updated',
  weeklyRateChanged && `Weekly rate: $${weeklyRate}/week`,
  weeksOfferedChanged && `Weekly pattern: ${patternLabels[weeksOffered] || weeksOffered}`,
  monthlyRateChanged && `Monthly rate: $${monthlyRate}/month`
].filter(Boolean);
```

**Why This Matters:**
All possible change descriptions visible in one array. Easy to add or modify change tracking.

**Testing:**
- [ ] Verify change summary shows all modified fields
- [ ] Test single field changes
- [ ] Test multiple field changes
- [ ] Check change descriptions are user-friendly

~~~~~

## CHUNK 32: Refactor active days calculation in HostProposalsPage/types.js

**File:** app/src/islands/pages/HostProposalsPage/types.js
**Line:** 253-254, 342-423
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - while loop with push, and sort operations
**Severity:** High

**Expected Affected Pages:** /host-proposals

**Current Code:**
```javascript
// Generate active days from check-in to check-out
while (current !== checkOutIndex) {
  activeDays.push(dayNames[current]);
  current = (current + 1) % 7;
}

// Later:
const sorted = [...dayIndices].sort((a, b) => a - b);
for (let i = 1; i < sorted.length; i++) {
  // contiguity check
}
```

**Refactored Code:**
```javascript
// Generate active days from check-in to check-out
const numDays = ((checkOutIndex - checkInIndex + 7) % 7) || 7;
const activeDays = Array.from(
  { length: numDays },
  (_, i) => dayNames[(checkInIndex + i) % 7]
);

// Contiguity check:
const sorted = [...dayIndices].toSorted((a, b) => a - b);
const isContiguous = sorted.every((curr, i) => {
  if (i === 0) return true;
  const prev = sorted[i - 1];
  return (curr - prev + 7) % 7 === 1;
});
```

**Why This Matters:**
Array.from with modular arithmetic cleanly handles week wrapping. The contiguity check uses every() for clarity.

**Testing:**
- [ ] Verify active days display correctly
- [ ] Test week-wrapping scenarios (Fri-Sun)
- [ ] Check contiguity detection
- [ ] Verify proposal cards show correct schedules

~~~~~

## CHUNK 33: Refactor fetchPromises building in useHostOverviewPageLogic.js

**File:** app/src/islands/pages/HostOverviewPage/useHostOverviewPageLogic.js
**Line:** 154-198
**Violation:** MUTATING_METHOD - Conditional push for fetch promises
**Severity:** High

**Expected Affected Pages:** /host-overview

**Current Code:**
```javascript
const fetchPromises = [];
if (shouldFetchListings) {
  fetchPromises.push(
    fetchListings(userId).then(data => ({ type: 'listings', data }))
  );
}
if (shouldFetchProposals) {
  fetchPromises.push(
    fetchProposals(userId).then(data => ({ type: 'proposals', data }))
  );
}
if (shouldFetchMessages) {
  fetchPromises.push(
    fetchMessages(userId).then(data => ({ type: 'messages', data }))
  );
}
```

**Refactored Code:**
```javascript
const fetchPromises = [
  shouldFetchListings && fetchListings(userId).then(data => ({ type: 'listings', data })),
  shouldFetchProposals && fetchProposals(userId).then(data => ({ type: 'proposals', data })),
  shouldFetchMessages && fetchMessages(userId).then(data => ({ type: 'messages', data }))
].filter(Boolean);
```

**Why This Matters:**
All conditional fetches visible at once. Easy to add or remove data sources.

**Testing:**
- [ ] Verify all data sources load correctly
- [ ] Test with some data sources disabled
- [ ] Check loading states
- [ ] Verify error handling for failed fetches

~~~~~

## CHUNK 34: Refactor bedroom/bathroom formatting in FavoriteListingsPage/formatters.js

**File:** app/src/islands/pages/FavoriteListingsPage/formatters.js
**Line:** 66-117
**Violation:** MUTATING_METHOD - Conditional push for parts array
**Severity:** High

**Expected Affected Pages:** /favorite-listings

**Current Code:**
```javascript
const parts = [];
if (bedrooms === 1) {
  parts.push('1 bedroom');
} else if (bedrooms > 1) {
  parts.push(`${bedrooms} bedrooms`);
}
if (bathroomDisplay) {
  parts.push(bathroomDisplay);
}
if (kitchenType) {
  parts.push(kitchenType);
}
// Location parts:
if (borough) parts.push(borough);
if (hood) parts.push(hood);
if (city) parts.push(city);
```

**Refactored Code:**
```javascript
const bedroomText = bedrooms === 1 ? '1 bedroom' : bedrooms > 1 ? `${bedrooms} bedrooms` : null;

const parts = [
  bedroomText,
  bathroomDisplay,
  kitchenType
].filter(Boolean);

const locationParts = [borough, hood, city].filter(Boolean);
```

**Why This Matters:**
Separating bedroom text logic makes the array construction cleaner. Location parts are clearly grouped.

**Testing:**
- [ ] Verify bedroom text pluralization
- [ ] Check all parts display correctly
- [ ] Test with missing optional fields
- [ ] Verify location display format

~~~~~

## Priority 9: UI State Classes

~~~~~

## CHUNK 35: Refactor class building in ScheduleCohost.jsx

**File:** app/src/islands/shared/ScheduleCohost/ScheduleCohost.jsx
**Line:** 709-713
**Violation:** MUTATING_METHOD - Conditional push for CSS classes
**Severity:** High

**Expected Affected Pages:** /schedule-cohost

**Current Code:**
```javascript
const classNames = ['schedule-cohost-calendar-day'];
if (isOtherMonth) classNames.push('schedule-cohost-calendar-day--other');
if (isPast) classNames.push('schedule-cohost-calendar-day--past');
if (isActive) classNames.push('schedule-cohost-calendar-day--selected');
if (hasSlots) classNames.push('schedule-cohost-calendar-day--has-slots');
if (isTodayDate) classNames.push('schedule-cohost-calendar-day--today');
```

**Refactored Code:**
```javascript
const classNames = [
  'schedule-cohost-calendar-day',
  isOtherMonth && 'schedule-cohost-calendar-day--other',
  isPast && 'schedule-cohost-calendar-day--past',
  isActive && 'schedule-cohost-calendar-day--selected',
  hasSlots && 'schedule-cohost-calendar-day--has-slots',
  isTodayDate && 'schedule-cohost-calendar-day--today'
].filter(Boolean).join(' ');
```

**Why This Matters:**
Standard React pattern for conditional class names. All possible states visible at once.

**Testing:**
- [ ] Verify correct classes applied to calendar days
- [ ] Check today highlighting
- [ ] Test selected state styling
- [ ] Verify past date dimming

~~~~~

## CHUNK 36: Refactor class building in SimpleHostScheduleSelector.jsx

**File:** app/src/islands/shared/HostScheduleSelector/SimpleHostScheduleSelector.jsx
**Line:** 145-149
**Violation:** MUTATING_METHOD - Conditional push for classes
**Severity:** High

**Expected Affected Pages:** /edit-listing, /listing-dashboard

**Current Code:**
```javascript
const classes = ['shss-night'];
if (isSelected) classes.push('shss-selected');
if (disabled) classes.push('shss-disabled');
```

**Refactored Code:**
```javascript
const classes = [
  'shss-night',
  isSelected && 'shss-selected',
  disabled && 'shss-disabled'
].filter(Boolean).join(' ');
```

**Why This Matters:**
Consistent pattern across schedule selector components.

**Testing:**
- [ ] Verify selected night styling
- [ ] Check disabled state appearance
- [ ] Test toggle behavior

~~~~~

## CHUNK 37: Refactor class building in HostEditingProposal/ScheduleSelector.jsx

**File:** app/src/islands/shared/HostEditingProposal/ScheduleSelector.jsx
**Line:** 119-121
**Violation:** MUTATING_METHOD - Conditional push for classes
**Severity:** High

**Expected Affected Pages:** /host-proposals

**Current Code:**
```javascript
const classes = ['hss-day'];
if (isSelected) classes.push('hss-selected');
if (!isAvailable) classes.push('hss-unavailable');
if (disabled) classes.push('hss-disabled');
```

**Refactored Code:**
```javascript
const classes = [
  'hss-day',
  isSelected && 'hss-selected',
  !isAvailable && 'hss-unavailable',
  disabled && 'hss-disabled'
].filter(Boolean).join(' ');
```

**Why This Matters:**
Consistent class building pattern for all schedule selectors.

**Testing:**
- [ ] Verify proposal editing schedule display
- [ ] Check unavailable day styling
- [ ] Test disabled interactions

~~~~~

## CHUNK 38: Refactor class building in BookTimeSlot.jsx

**File:** app/src/islands/shared/VirtualMeetingManager/BookTimeSlot.jsx
**Line:** 155-159
**Violation:** MUTATING_METHOD - Conditional push for classes
**Severity:** High

**Expected Affected Pages:** /virtual-meeting (booking flow)

**Current Code:**
```javascript
const classes = ['vm-date-button'];
if (isActive) classes.push('vm-date-button-active');
if (hasSlots) classes.push('vm-date-button-has-slots');
```

**Refactored Code:**
```javascript
const classes = [
  'vm-date-button',
  isActive && 'vm-date-button-active',
  hasSlots && 'vm-date-button-has-slots'
].filter(Boolean).join(' ');
```

**Why This Matters:**
Consistent pattern for all date/time selector components.

**Testing:**
- [ ] Verify active date styling
- [ ] Check dates with available slots
- [ ] Test date selection behavior

~~~~~

## Priority 10: Remaining High-Impact Items

~~~~~

## CHUNK 39: Refactor contiguity detection in DaysSelectionSection.jsx

**File:** app/src/islands/shared/CreateProposalFlowV2Components/DaysSelectionSection.jsx
**Line:** 63-72
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP - sort and loop
**Severity:** High

**Expected Affected Pages:** /view-split-lease (proposal flow)

**Current Code:**
```javascript
const sorted = [...dayNumbers].sort((a, b) => a - b);
// ...
for (let i = 0; i < sorted.length - 1; i++) {
  // gap detection
}
```

**Refactored Code:**
```javascript
const sorted = [...dayNumbers].toSorted((a, b) => a - b);

const isContiguous = sorted.every((curr, i) => {
  if (i === 0) return true;
  const prev = sorted[i - 1];
  return (curr - prev + 7) % 7 === 1;
});
```

**Why This Matters:**
Consistent contiguity detection pattern used throughout the proposal flow.

**Testing:**
- [ ] Verify day selection validation
- [ ] Test contiguous selections pass
- [ ] Test non-contiguous selections fail
- [ ] Check error message displays

~~~~~

## CHUNK 40: Refactor wizard step completion in useRentalApplicationWizardLogic.js

**File:** app/src/islands/shared/RentalApplicationWizardModal/useRentalApplicationWizardLogic.js
**Line:** 267-269
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with push
**Severity:** High

**Expected Affected Pages:** /view-split-lease (rental application modal)

**Current Code:**
```javascript
const newCompleted = [];
for (let step = 1; step <= TOTAL_STEPS; step++) {
  if (isStepComplete(step)) {
    newCompleted.push(step);
  }
}
```

**Refactored Code:**
```javascript
const newCompleted = Array.from(
  { length: TOTAL_STEPS },
  (_, i) => i + 1
).filter(step => isStepComplete(step));
```

**Why This Matters:**
Array.from with filter is the declarative way to build a filtered sequence.

**Testing:**
- [ ] Verify completed steps tracking
- [ ] Test step completion validation
- [ ] Check progress indicator updates

~~~~~

## CHUNK 41: Refactor nightly price generation in NightlyPriceSlider.tsx

**File:** app/src/islands/pages/SelfListingPage/components/NightlyPriceSlider.tsx
**Line:** 70-71
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with push
**Severity:** High

**Expected Affected Pages:** /self-listing

**Current Code:**
```typescript
const prices = [basePrice];
for (let i = 1; i < N; i++) {
  prices.push(roundUp(prices[i - 1] * decay));
}
```

**Refactored Code:**
```typescript
const prices = Array.from({ length: N }, (_, i) => {
  if (i === 0) return basePrice;
  // Use reduce to calculate cumulative decay
  return roundUp(basePrice * Math.pow(decay, i));
});
```

**Why This Matters:**
Using Array.from eliminates mutation. Each price is calculated independently based on the base price and decay factor.

**Testing:**
- [ ] Verify price decay is calculated correctly
- [ ] Test slider adjustments update prices
- [ ] Check UI displays all price tiers

~~~~~

## CHUNK 42: Refactor completed steps in rentalApplicationFieldMapper.ts

**File:** app/src/islands/pages/RentalApplicationPage/utils/rentalApplicationFieldMapper.ts
**Line:** 401-403
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with push
**Severity:** High

**Expected Affected Pages:** /rental-application

**Current Code:**
```typescript
const completed: number[] = [];
for (let step = 1; step <= 7; step++) {
  if (isStepComplete(formData, step)) {
    completed.push(step);
  }
}
```

**Refactored Code:**
```typescript
const completed = [1, 2, 3, 4, 5, 6, 7].filter(step =>
  isStepComplete(formData, step)
);
```

**Why This Matters:**
Using filter on a static array is cleaner and more readable than a loop with push.

**Testing:**
- [ ] Verify step completion detection
- [ ] Test progress through all 7 steps
- [ ] Check completed steps are highlighted

~~~~~

---

## Implementation Notes

### Execution Order

1. **Start with Priority 1** (I/O in Core) - These are the most critical FP violations
2. **Proceed through priorities in order** - Each priority level builds on the previous
3. **Test after each chunk** - Don't batch too many changes without testing

### Common Patterns Used

| Pattern | Before | After |
|---------|--------|-------|
| Conditional push | `if (x) arr.push(y)` | `[x && y].filter(Boolean)` |
| Mutable sort | `arr.sort()` | `arr.toSorted()` |
| Loop with push | `for (...) { arr.push(...) }` | `arr.map(...).filter(...)` |
| Gap detection loop | `for (i=1; i<len; i++)` | `arr.some((x,i) => ...)` |
| Sequence generation | `for (let i=0; i<n; i++)` | `Array.from({length: n}, (_, i) => ...)` |

### Browser Compatibility Note

`.toSorted()` requires:
- Chrome 110+
- Firefox 115+
- Safari 16+
- Node.js 20+

If supporting older browsers, use `[...arr].sort()` pattern instead (already immutable due to spread).

---

## References

- **Violations JSON:** `agents/20260111113933_fp_audit_violations.json`
- **FP Guide:** `.claude/skills/functional-code/functional-code.md`
- **Full FP Reference:** `.claude/Documentation/Architecture/The Functional Programming Bible.md`

---

## Chunk Count: 42 chunks

**Estimated Implementation Time:** 5-10 minutes per chunk = ~3.5-7 hours total

**Recommended Approach:** Implement 5-10 chunks per session, test thoroughly, commit, then continue.
