# Functional Programming Refactoring Plan

Date: 2026-01-13
Target: agents/20260113180607_fp_audit_violations.json
Severity Filter: high

~~~~~

## CHUNK 1: Replace imperative loop in isContiguousSelection

**File:** lib/availabilityValidation.js
**Line:** 38
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  // Check for standard contiguous sequence (no wrap around)
  let isStandardContiguous = true;
  for (let i = 1; i < sorted.length; i++) {
    if (sorted[i] !== sorted[i - 1] + 1) {
      isStandardContiguous = false;
      break;
    }
  }
```

**Refactored Code:**
```javascript
  // Check for standard contiguous sequence (no wrap around)
  const isStandardContiguous = sorted.every((day, i) => i === 0 || day === sorted[i - 1] + 1);
```

**Why This Matters:**
Imperative loops with mutable flags (`isStandardContiguous`) are harder to reason about and test. `every()` clearly communicates the intent: "ensure every element satisfies the contiguous condition".

**Testing:**
- [ ] Run unit tests for `isContiguousSelection`
- [ ] Verify standard contiguous sequences (e.g., [1, 2, 3]) return true
- [ ] Verify non-contiguous sequences (e.g., [1, 3]) return false

~~~~~

## CHUNK 2: Replace imperative loop in expectedNotSelected generation

**File:** lib/availabilityValidation.js
**Line:** 65
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = [];
    for (let i = minNotSelected; i <= maxNotSelected; i++) {
      expectedNotSelected.push(i);
    }
```

**Refactored Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = Array.from(
      { length: maxNotSelected - minNotSelected + 1 },
      (_, i) => minNotSelected + i
    );
```

**Why This Matters:**
Declarative array generation is cleaner and avoids the mutation of `expectedNotSelected`. `Array.from` is the standard functional way to generate sequences.

**Testing:**
- [ ] Run unit tests for `isContiguousSelection`
- [ ] Verify wrap-around logic works (e.g., [6, 0, 1]) where not-selected days are contiguous

~~~~~

## CHUNK 3: Use toSorted() instead of [...].sort()

**File:** lib/availabilityValidation.js
**Line:** 97
**Violation:** MUTATING_METHOD - Using mutating array sort/reverse
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
  const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
`toSorted()` is the modern, immutable standard for sorting arrays. While `[...arr].sort()` is also immutable (by copying), `toSorted()` is more expressive and efficient.

**Testing:**
- [ ] Verify `calculateCheckInOutDays` returns correct check-in/out
- [ ] Ensure original `selectedDays` array is not mutated

~~~~~

## CHUNK 4: Replace imperative loop in gap detection

**File:** lib/availabilityValidation.js
**Line:** 106
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
    // Find gap to determine actual start/end
    let gapIndex = -1;
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] !== sorted[i - 1] + 1) {
        gapIndex = i;
        break;
      }
    }
```

**Refactored Code:**
```javascript
    // Find gap to determine actual start/end
    const gapIndex = sorted.findIndex((day, i) => i > 0 && day !== sorted[i - 1] + 1);
```

**Why This Matters:**
`findIndex` is a declarative method specifically designed for this purpose. It eliminates the need for a mutable `gapIndex` variable and manual `break`.

**Testing:**
- [ ] Verify `calculateCheckInOutDays` handles wrap-around cases correctly
- [ ] Check gap detection for non-contiguous days

~~~~~

## CHUNK 5: Replace mutating push in validateScheduleSelection (Errors)

**File:** lib/availabilityValidation.js
**Line:** 166
**Violation:** MUTATING_METHOD - Using mutating array method
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  // Check if days are selected
  if (!selectedDays || selectedDays.length === 0) {
    result.valid = false;
    result.errors.push('Please select at least one day');
    return result;
  }
```

**Refactored Code:**
```javascript
  // Check if days are selected
  if (!selectedDays || selectedDays.length === 0) {
    return {
      ...result,
      valid: false,
      errors: [...result.errors, 'Please select at least one day']
    };
  }
```

**Why This Matters:**
Avoids mutating the `result` object's `errors` array. Returning a new object with the updated errors array adheres to immutability principles.

**Testing:**
- [ ] Call `validateScheduleSelection` with empty `selectedDays`
- [ ] Verify it returns valid=false and the correct error message

~~~~~

## CHUNK 6: Replace imperative loop in mapAvailableNightsToNames

**File:** lib/listingService.js
**Line:** 766
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  const result = [];
  // Maintain proper day order
  const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

  for (const day of dayOrder) {
    if (availableNights[day] && dayNameMapping[day]) {
      result.push(dayNameMapping[day]);
    }
  }

  return result;
```

**Refactored Code:**
```javascript
  // Maintain proper day order
  const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

  return dayOrder
    .filter(day => availableNights[day] && dayNameMapping[day])
    .map(day => dayNameMapping[day]);
```

**Why This Matters:**
Chainable array methods `filter` and `map` clearly express the transformation pipeline: "select valid days" -> "transform to display names". This avoids manual array mutation.

**Testing:**
- [ ] Verify `mapAvailableNightsToNames` returns correct list of day names
- [ ] Ensure order matches `dayOrder`

~~~~~

## CHUNK 7: Replace imperative loop in mapAvailableNightsToArray

**File:** lib/listingService.js
**Line:** 1076
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  const result = [];
  for (const [day, isSelected] of Object.entries(availableNights)) {
    if (isSelected && dayMapping[day] !== undefined) {
      result.push(dayMapping[day]);
    }
  }

  return result.sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
  return Object.entries(availableNights)
    .filter(([day, isSelected]) => isSelected && dayMapping[day] !== undefined)
    .map(([day]) => dayMapping[day])
    .sort((a, b) => a - b);
```

**Why This Matters:**
Replaces imperative iteration and pushing with a functional pipeline. `filter` selects the days, `map` transforms them to indices, and `sort` orders them.

**Testing:**
- [ ] Verify `mapAvailableNightsToArray` returns sorted array of integers
- [ ] Check mapping correctness (sunday=0, etc.)

~~~~~

## CHUNK 8: Replace imperative loop in mapArrayToAvailableNights

**File:** lib/listingService.js
**Line:** 1240
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
  const result = {
    sunday: false,
    monday: false,
    tuesday: false,
    wednesday: false,
    thursday: false,
    friday: false,
    saturday: false,
  };

  if (Array.isArray(daysArray)) {
    for (const dayNum of daysArray) {
      const dayName = dayMapping[dayNum];
      if (dayName) {
        result[dayName] = true;
      }
    }
  }

  return result;
```

**Refactored Code:**
```javascript
  const baseResult = {
    sunday: false,
    monday: false,
    tuesday: false,
    wednesday: false,
    thursday: false,
    friday: false,
    saturday: false,
  };

  if (!Array.isArray(daysArray)) return baseResult;

  return daysArray.reduce((acc, dayNum) => {
    const dayName = dayMapping[dayNum];
    if (dayName) {
      return { ...acc, [dayName]: true };
    }
    return acc;
  }, baseResult);
```

**Why This Matters:**
`reduce` is the functional tool for transforming a list into a single object (or another shape). It avoids mutating the `result` object in place, instead building it up immutably.

**Testing:**
- [ ] Verify `mapArrayToAvailableNights` correctly marks days as true
- [ ] Verify it handles empty or invalid input gracefully
