# Functional Programming Refactoring Plan

Date: 2026-01-11
Target: agents/20260111110537_fp_audit_violations.json
Severity Filter: high

**Summary:**
- **Total Violations:** 349 (all HIGH severity)
- **MUTATING_METHOD:** ~290 violations (.push(), .sort(), .reverse(), .pop())
- **IMPERATIVE_LOOP:** ~59 violations (for loops, while loops)

**Files by Violation Count (Top 20):**
1. `listingLocalStore.ts` - 20 violations
2. `prepareListingSubmission.ts` - 16 violations
3. `LoggedInAvatar.jsx` - 13 violations
4. `SearchScheduleSelector.jsx` - 9 violations
5. `HostScheduleSelector.jsx` - 10 violations
6. `AvailabilitySection.jsx` - 13 violations
7. `Section1SpaceSnapshot.tsx` - 10 violations
8. `Section5Rules.tsx` - 9 violations
9. `PricingEditSection.jsx` - 11 violations
10. `GoogleMap.jsx` - 7 violations

~~~~~

## CHUNK 1: Replace .sort() with .toSorted() in isScheduleContiguous.js:55

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 55
**Violation:** MUTATING_METHOD - Using .sort() on copied array
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
  // Sort the selected days
  const sorted = [...selectedDayIndices].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
  // Sort the selected days (immutable)
  const sorted = selectedDayIndices.toSorted((a, b) => a - b)
```

**Why This Matters:**
While `[...arr].sort()` avoids mutating the original array, `toSorted()` is the idiomatic ES2023 immutable alternative. It signals intent more clearly and is the FP-preferred method.

**Testing:**
- [ ] Run unit tests for isScheduleContiguous
- [ ] Verify contiguity checks work on search page
- [ ] Test wrap-around cases (Fri-Sun, Sat-Tue)

~~~~~

## CHUNK 2: Replace imperative loop with reduce in isScheduleContiguous.js:64-69

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 64
**Violation:** IMPERATIVE_LOOP - Using for loop for contiguity check
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
  // Check for standard contiguous sequence (no wrap around)
  let isStandardContiguous = true
  for (let i = 1; i < sorted.length; i++) {
    if (sorted[i] !== sorted[i - 1] + 1) {
      isStandardContiguous = false
      break
    }
  }
```

**Refactored Code:**
```javascript
  // Check for standard contiguous sequence (no wrap around)
  const isStandardContiguous = sorted.slice(1).every(
    (day, index) => day === sorted[index] + 1
  )
```

**Why This Matters:**
Declarative array methods like `.every()` express intent more clearly than imperative loops with mutable flags. The reader immediately understands "check if every consecutive pair differs by 1."

**Testing:**
- [ ] Run unit tests for isScheduleContiguous
- [ ] Test edge cases: single day, all 7 days, 6 days

~~~~~

## CHUNK 3: Replace imperative loop with Array.from in isScheduleContiguous.js:95-97

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 95
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Using for loop with .push()
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = []
    for (let i = minNotSelected; i <= maxNotSelected; i++) {
      expectedNotSelected.push(i)
    }
```

**Refactored Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = Array.from(
      { length: maxNotSelected - minNotSelected + 1 },
      (_, i) => minNotSelected + i
    )
```

**Why This Matters:**
`Array.from()` with a mapping function is the declarative way to generate ranges. No mutation needed - the array is created with all values in one expression.

**Testing:**
- [ ] Run unit tests for isScheduleContiguous
- [ ] Verify wrap-around detection works (Fri-Sun selected)

~~~~~

## CHUNK 4: Replace .sort() with .toSorted() in calculateCheckInOutDays.js:50

**File:** app/src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 50
**Violation:** MUTATING_METHOD - Using .sort() on copied array
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
  const sorted = [...selectedDays].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
  const sorted = selectedDays.toSorted((a, b) => a - b)
```

**Why This Matters:**
Using `toSorted()` is the idiomatic ES2023 immutable sorting method. It's cleaner than spread+sort and signals immutable intent.

**Testing:**
- [ ] Run unit tests for calculateCheckInOutDays
- [ ] Verify check-in/check-out calculations on proposal flow

~~~~~

## CHUNK 5: Replace imperative loop with findIndex in calculateCheckInOutDays.js:59-64

**File:** app/src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 59
**Violation:** IMPERATIVE_LOOP - Using for loop to find gap
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
    // Find gap to determine actual start/end
    let gapIndex = -1
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] !== sorted[i - 1] + 1) {
        gapIndex = i
        break
      }
    }
```

**Refactored Code:**
```javascript
    // Find gap to determine actual start/end
    const gapIndex = sorted.findIndex(
      (day, i) => i > 0 && day !== sorted[i - 1] + 1
    )
```

**Why This Matters:**
`findIndex()` is the declarative way to find the first element matching a condition. It eliminates the mutable `gapIndex` variable and the imperative control flow.

**Testing:**
- [ ] Run unit tests for calculateCheckInOutDays
- [ ] Test wrap-around scenarios (Fri-Mon selection)

~~~~~

## CHUNK 6: Replace .sort() with .toSorted() in availabilityValidation.js:97

**File:** app/src/lib/availabilityValidation.js
**Line:** 97
**Violation:** MUTATING_METHOD - Using .sort() on copied array
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
  const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
  const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent use of `toSorted()` across the codebase improves readability and signals immutable intent.

**Testing:**
- [ ] Run unit tests for availabilityValidation
- [ ] Verify date validation works on proposal flow

~~~~~

## CHUNK 7: Replace imperative loop with findIndex in availabilityValidation.js:106-111

**File:** app/src/lib/availabilityValidation.js
**Line:** 106
**Violation:** IMPERATIVE_LOOP - Using for loop to find gap
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
    let gapIndex = -1;
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] !== sorted[i - 1] + 1) {
        gapIndex = i;
        break;
      }
    }
```

**Refactored Code:**
```javascript
    const gapIndex = sorted.findIndex(
      (day, i) => i > 0 && day !== sorted[i - 1] + 1
    );
```

**Why This Matters:**
Eliminates mutable variable and imperative control flow. The declarative `.findIndex()` clearly expresses "find first non-consecutive day."

**Testing:**
- [ ] Run unit tests for calculateCheckInOutDays in availabilityValidation
- [ ] Test wrap-around check-in/check-out calculations

~~~~~

## CHUNK 8: Replace .sort() with .toSorted() in HostScheduleSelector/utils.js:25

**File:** app/src/islands/shared/HostScheduleSelector/utils.js
**Line:** 25
**Violation:** MUTATING_METHOD - Using .sort() on mapped array
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /edit-listing, /create-listing

**Current Code:**
```javascript
  // Convert to day indices (0-6) and sort
  const numbers = selectedNights
    .map((id) => getNightById(id).dayIndex)
    .sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
  // Convert to day indices (0-6) and sort (immutable)
  const numbers = selectedNights
    .map((id) => getNightById(id).dayIndex)
    .toSorted((a, b) => a - b)
```

**Why This Matters:**
While .map() returns a new array, chaining .sort() mutates that new array. Using .toSorted() maintains immutability throughout the chain.

**Testing:**
- [ ] Run unit tests for checkContiguity
- [ ] Verify schedule selection on listing dashboard

~~~~~

## CHUNK 9: Replace imperative loop with findIndex in HostScheduleSelector/utils.js:29-33

**File:** app/src/islands/shared/HostScheduleSelector/utils.js
**Line:** 29
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Using for loop with .push() to find gaps
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /edit-listing, /create-listing

**Current Code:**
```javascript
  // Check for gaps
  const gaps = []
  for (let i = 1; i < numbers.length; i++) {
    if (numbers[i] !== numbers[i - 1] + 1) {
      gaps.push(i)
    }
  }
```

**Refactored Code:**
```javascript
  // Check for gaps (declarative)
  const gaps = numbers
    .slice(1)
    .map((num, i) => (num !== numbers[i] + 1 ? i + 1 : null))
    .filter(Boolean)
```

**Why This Matters:**
Replaces mutable array building with declarative map+filter. The logic "find all indices where consecutive values don't differ by 1" is expressed functionally.

**Testing:**
- [ ] Run unit tests for checkContiguity
- [ ] Verify gap detection in schedule selector

~~~~~

## CHUNK 10: Replace imperative loop with Array.from in HostScheduleSelector/utils.js:59-61

**File:** app/src/islands/shared/HostScheduleSelector/utils.js
**Line:** 59
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Using for loop with .push() for sequence
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /edit-listing, /create-listing

**Current Code:**
```javascript
  if (startIdx <= endIdx) {
    // Ascending order
    for (let i = startIdx; i <= endIdx; i++) {
      sequence.push(getNightByDayIndex(i).id)
    }
  }
```

**Refactored Code:**
```javascript
  if (startIdx <= endIdx) {
    // Ascending order
    return Array.from(
      { length: endIdx - startIdx + 1 },
      (_, i) => getNightByDayIndex(startIdx + i).id
    )
  }
```

**Why This Matters:**
`Array.from()` with a mapping function generates sequences without mutation. The resulting array is created in a single expression.

**Testing:**
- [ ] Run unit tests for getNightSequence
- [ ] Verify sequence generation in schedule auto-fill

~~~~~

## CHUNK 11: Replace imperative loop with Array.from in HostScheduleSelector/utils.js:64-66

**File:** app/src/islands/shared/HostScheduleSelector/utils.js
**Line:** 64
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Using for loop with .push() for descending sequence
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /edit-listing, /create-listing

**Current Code:**
```javascript
  } else {
    // Descending order
    for (let i = startIdx; i >= endIdx; i--) {
      sequence.push(getNightByDayIndex(i).id)
    }
  }
```

**Refactored Code:**
```javascript
  } else {
    // Descending order
    return Array.from(
      { length: startIdx - endIdx + 1 },
      (_, i) => getNightByDayIndex(startIdx - i).id
    )
  }
```

**Why This Matters:**
Same principle as ascending - generate the sequence declaratively without mutation.

**Testing:**
- [ ] Run unit tests for getNightSequence
- [ ] Verify descending sequence generation

~~~~~

## CHUNK 12: Replace conditional .push() with declarative array in LoggedInAvatar.jsx:169-332

**File:** app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx
**Line:** 169-332
**Violation:** MUTATING_METHOD - Multiple .push() calls for menu items
**Severity:** High

**Expected Affected Pages:** All pages (global navigation component)

**Current Code:**
```javascript
  const getMenuItems = () => {
    const items = [];

    // 1. My Profile - ALWAYS visible
    if (menuVisibility.myProfile) {
      items.push({
        id: 'profile',
        label: 'My Profile',
        icon: '/assets/icons/user-purple.svg',
        path: `/account-profile/${user.id}`,
      });
    }

    // 2. My Proposals - Visible for all users
    if (menuVisibility.myProposals) {
      items.push({
        id: 'proposals',
        label: 'My Proposals',
        icon: '/assets/icons/file-text-purple.svg',
        path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
          ? '/guest-proposals'
          : '/host-proposals',
        badgeCount: effectiveProposalsCount,
        badgeColor: 'purple',
      });
    }
    // ... 11 more similar push() calls
    return items;
  };
```

**Refactored Code:**
```javascript
  const getMenuItems = () => {
    const menuItemConfigs = [
      {
        key: 'myProfile',
        item: {
          id: 'profile',
          label: 'My Profile',
          icon: '/assets/icons/user-purple.svg',
          path: `/account-profile/${user.id}`,
        },
      },
      {
        key: 'myProposals',
        item: {
          id: 'proposals',
          label: 'My Proposals',
          icon: '/assets/icons/file-text-purple.svg',
          path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
            ? '/guest-proposals'
            : '/host-proposals',
          badgeCount: effectiveProposalsCount,
          badgeColor: 'purple',
        },
      },
      {
        key: 'myProposalsSuggested',
        item: {
          id: 'proposals-suggested',
          label: 'Proposals Suggested',
          icon: '/assets/icons/file-text-purple.svg',
          path: '/proposals-suggested',
        },
      },
      {
        key: 'myListings',
        item: {
          id: 'listings',
          label: 'My Listings',
          icon: '/assets/icons/list-purple.svg',
          path: effectiveListingsCount === 1 && effectiveFirstListingId
            ? `/listing-dashboard?id=${effectiveFirstListingId}`
            : '/host-overview',
          badgeCount: effectiveListingsCount,
          badgeColor: 'purple',
        },
      },
      {
        key: 'virtualMeetings',
        item: {
          id: 'virtual-meetings',
          label: 'Virtual Meetings',
          icon: '/assets/icons/video-purple.svg',
          path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
            ? `/guest-proposals${effectiveVirtualMeetingsCount > 0 ? '?scrollTo=virtual-meetings' : '?highlightVMButton=true'}`
            : `/host-proposals${effectiveVirtualMeetingsCount > 0 ? '?scrollTo=virtual-meetings' : '?highlightVMButton=true'}`,
          badgeCount: effectiveVirtualMeetingsCount,
          badgeColor: 'purple',
        },
      },
      {
        key: 'houseManualsAndVisits',
        item: {
          id: 'house-manuals',
          label: 'House manuals & Visits',
          icon: '/assets/icons/book-open-purple.svg',
          path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
            ? '/guest-house-manual'
            : effectiveHouseManualsCount === 1
              ? '/host-house-manual'
              : '/host-overview',
        },
      },
      {
        key: 'myLeases',
        item: {
          id: 'leases',
          label: 'My Leases',
          icon: '/assets/icons/key-purple.svg',
          path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
            ? '/guest-leases'
            : '/host-leases',
          badgeCount: effectiveLeasesCount,
          badgeColor: 'purple',
        },
      },
      {
        key: 'myFavoriteListings',
        item: {
          id: 'favorites',
          label: 'My Favorite Listings',
          icon: '/assets/icons/heart-purple.svg',
          path: '/favorite-listings',
          badgeCount: effectiveFavoritesCount,
          badgeColor: 'purple',
        },
      },
      {
        key: 'messages',
        item: {
          id: 'messages',
          label: 'Messages',
          icon: '/assets/icons/message-circle-purple.svg',
          path: '/messages',
          badgeCount: effectiveUnreadMessagesCount,
          badgeColor: 'red',
        },
      },
      {
        key: 'rentalApplication',
        item: {
          id: 'rental-application',
          label: 'Rental Application',
          icon: '/assets/icons/clipboard-purple.svg',
          path: effectiveUserType === NORMALIZED_USER_TYPES.HOST
            ? '/account'
            : `/account-profile/${user.id}?section=rental-application`,
        },
      },
      {
        key: 'reviewsManager',
        item: {
          id: 'reviews',
          label: 'Reviews Manager',
          icon: '/assets/icons/star-purple.svg',
          path: '/reviews-overview',
        },
      },
      {
        key: 'referral',
        item: {
          id: 'referral',
          label: 'Referral',
          icon: '/assets/icons/gift-purple.svg',
          action: () => setShowReferralModal(true),
        },
      },
    ];

    return menuItemConfigs
      .filter(({ key }) => menuVisibility[key])
      .map(({ item }) => item);
  };
```

**Why This Matters:**
Declarative configuration with filter+map replaces 13 conditional push() calls. The menu structure is now a data declaration, making it easier to add/remove items and understand the full menu at a glance.

**Testing:**
- [ ] Verify all menu items appear correctly based on visibility flags
- [ ] Test guest vs host menu differences
- [ ] Verify badge counts display correctly

~~~~~

## CHUNK 13: Replace conditional .push() with filter array in HostScheduleSelector.jsx:242-266

**File:** app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx
**Line:** 242-266
**Violation:** MUTATING_METHOD - Multiple .push() calls for CSS classes
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /edit-listing, /create-listing

**Current Code:**
```javascript
  const getNightCellClasses = useCallback(
    (nightId) => {
      const classes = ['hss-night-cell']
      const isSelected = selectedNights.includes(nightId)
      const isAvailable = isNightAvailable(nightId, availableNights)

      // Selected state
      if (isSelected) {
        classes.push('hss-selected')

        // Non-contiguous in proposal mode
        if (inProposal && !isContiguous) {
          classes.push('hss-non-contiguous')
        }
      }

      // Unavailable state
      if (!isAvailable) {
        classes.push('hss-unavailable')
      }

      // Disabled state
      if (!isClickable || (mode === 'preview' && !isAvailable)) {
        classes.push('hss-disabled')
      }

      return classes.join(' ')
    },
    [selectedNights, availableNights, isClickable, inProposal, isContiguous, mode]
  )
```

**Refactored Code:**
```javascript
  const getNightCellClasses = useCallback(
    (nightId) => {
      const isSelected = selectedNights.includes(nightId)
      const isAvailable = isNightAvailable(nightId, availableNights)

      return [
        'hss-night-cell',
        isSelected && 'hss-selected',
        isSelected && inProposal && !isContiguous && 'hss-non-contiguous',
        !isAvailable && 'hss-unavailable',
        (!isClickable || (mode === 'preview' && !isAvailable)) && 'hss-disabled',
      ].filter(Boolean).join(' ')
    },
    [selectedNights, availableNights, isClickable, inProposal, isContiguous, mode]
  )
```

**Why This Matters:**
Declarative array with filter(Boolean) is the idiomatic React pattern for conditional CSS classes. It's more concise and clearly shows all possible classes in one array literal.

**Testing:**
- [ ] Verify CSS classes apply correctly for all states
- [ ] Test selected, unavailable, disabled states visually

~~~~~

## CHUNK 14: Replace conditional .push() with filter array in HostScheduleSelector.jsx:297-313

**File:** app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx
**Line:** 297-313
**Violation:** MUTATING_METHOD - Multiple .push() calls for container classes
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /edit-listing, /create-listing

**Current Code:**
```javascript
  const getContainerClasses = useCallback(() => {
    const classes = ['hss-host-schedule-selector']

    if (mode === 'preview') {
      classes.push('hss-preview-mode')
    } else if (mode === 'step-by-step-guide') {
      classes.push('hss-step-by-step-mode')
    } else if (mode === 'proposal' || inProposal) {
      classes.push('hss-proposal-mode')
    }

    if (className) {
      classes.push(className)
    }

    return classes.join(' ')
  }, [mode, inProposal, className])
```

**Refactored Code:**
```javascript
  const getContainerClasses = useCallback(() => {
    const modeClass = {
      'preview': 'hss-preview-mode',
      'step-by-step-guide': 'hss-step-by-step-mode',
    }[mode] || ((mode === 'proposal' || inProposal) ? 'hss-proposal-mode' : null)

    return [
      'hss-host-schedule-selector',
      modeClass,
      className,
    ].filter(Boolean).join(' ')
  }, [mode, inProposal, className])
```

**Why This Matters:**
Using an object lookup for mode classes and filter(Boolean) for the final array is cleaner than multiple if-else branches with push().

**Testing:**
- [ ] Verify container classes apply for each mode
- [ ] Test preview, step-by-step, and proposal modes

~~~~~

## CHUNK 15: Replace imperative loop with Array.from in AvailabilitySection.jsx:45-49

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Line:** 45
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - while loop with .push() for date range
**Severity:** High

**Expected Affected Pages:** /listing-dashboard

**Current Code:**
```javascript
const getDateRange = (start, end) => {
  // ... swap if needed
  const current = new Date(start);
  while (current <= end) {
    dates.push(formatDateKey(current));
    current.setDate(current.getDate() + 1);
  }
  return dates;
};
```

**Refactored Code:**
```javascript
const getDateRange = (start, end) => {
  if (!start || !end) return [];

  let [startDate, endDate] = [new Date(start), new Date(end)];
  if (startDate > endDate) {
    [startDate, endDate] = [endDate, startDate];
  }

  const dayCount = Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1;

  return Array.from({ length: dayCount }, (_, i) => {
    const date = new Date(startDate);
    date.setDate(startDate.getDate() + i);
    return formatDateKey(date);
  });
};
```

**Why This Matters:**
Replacing while loop with Array.from eliminates mutation of both the dates array and the current date object. The range generation is now a single declarative expression.

**Testing:**
- [ ] Test date range generation for various inputs
- [ ] Verify blocked date range selection works

~~~~~

## CHUNK 16: Replace imperative calendar generation in AvailabilitySection.jsx:106-140

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Line:** 106
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Multiple for loops with .push() for calendar days
**Severity:** High

**Expected Affected Pages:** /listing-dashboard

**Current Code:**
```javascript
  const getCalendarDays = () => {
    // ... setup code
    const days = [];

    // Previous month padding
    for (let i = startPadding - 1; i >= 0; i--) {
      const dayNum = prevMonth.getDate() - i;
      const date = new Date(prevMonthYear, prevMonthMonth, dayNum);
      days.push({
        day: dayNum,
        isCurrentMonth: false,
        isPast: date < today,
        date: date,
      });
    }

    // Current month days
    for (let i = 1; i <= daysInMonth; i++) {
      const date = new Date(year, month, i);
      days.push({
        day: i,
        isCurrentMonth: true,
        isPast: date < today,
        date: date,
      });
    }

    // Next month padding
    for (let i = 1; i <= remaining; i++) {
      const date = new Date(nextMonthYear, nextMonthMonth, i);
      days.push({
        day: i,
        isCurrentMonth: false,
        isPast: false,
        date: date,
      });
    }

    return days;
  };
```

**Refactored Code:**
```javascript
  const getCalendarDays = () => {
    const year = currentDate.getFullYear();
    const month = currentDate.getMonth();

    const firstDay = new Date(year, month, 1);
    const lastDay = new Date(year, month + 1, 0);
    const startPadding = firstDay.getDay();
    const daysInMonth = lastDay.getDate();

    const today = new Date();
    today.setHours(0, 0, 0, 0);

    const prevMonth = new Date(year, month, 0);
    const prevMonthYear = prevMonth.getFullYear();
    const prevMonthMonth = prevMonth.getMonth();

    const remaining = 42 - startPadding - daysInMonth;
    const nextMonthYear = month === 11 ? year + 1 : year;
    const nextMonthMonth = month === 11 ? 0 : month + 1;

    // Previous month padding (declarative)
    const prevMonthDays = Array.from({ length: startPadding }, (_, i) => {
      const dayNum = prevMonth.getDate() - startPadding + 1 + i;
      const date = new Date(prevMonthYear, prevMonthMonth, dayNum);
      return {
        day: dayNum,
        isCurrentMonth: false,
        isPast: date < today,
        date,
      };
    });

    // Current month days (declarative)
    const currentMonthDays = Array.from({ length: daysInMonth }, (_, i) => {
      const dayNum = i + 1;
      const date = new Date(year, month, dayNum);
      return {
        day: dayNum,
        isCurrentMonth: true,
        isPast: date < today,
        date,
      };
    });

    // Next month padding (declarative)
    const nextMonthDays = Array.from({ length: remaining }, (_, i) => {
      const dayNum = i + 1;
      const date = new Date(nextMonthYear, nextMonthMonth, dayNum);
      return {
        day: dayNum,
        isCurrentMonth: false,
        isPast: false,
        date,
      };
    });

    return [...prevMonthDays, ...currentMonthDays, ...nextMonthDays];
  };
```

**Why This Matters:**
Three separate Array.from() calls with spread concatenation is clearer than three for loops mutating a single array. Each section is self-contained and the final result is a composition.

**Testing:**
- [ ] Verify calendar displays correctly for current month
- [ ] Test month navigation (prev/next)
- [ ] Verify past date highlighting

~~~~~

## CHUNK 17: Replace .sort().reverse() chain with .toSorted().toReversed() in AvailabilitySection.jsx:253-254

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Line:** 253
**Violation:** MUTATING_METHOD - Using .sort() and .reverse() chain
**Severity:** High

**Expected Affected Pages:** /listing-dashboard

**Current Code:**
```javascript
  const pastBlockedDates = blockedDates
    .filter(date => new Date(date) < today)
    .sort()
    .reverse(); // Most recent past dates first
```

**Refactored Code:**
```javascript
  const pastBlockedDates = blockedDates
    .filter(date => new Date(date) < today)
    .toSorted()
    .toReversed(); // Most recent past dates first
```

**Why This Matters:**
ES2023 provides `toSorted()` and `toReversed()` as immutable alternatives. While the original code creates a new array via filter() first, using the immutable methods signals intent clearly.

**Testing:**
- [ ] Verify past blocked dates display in correct order
- [ ] Test with multiple past blocked dates

~~~~~

## CHUNK 18: Replace imperative loop with Array.from in SearchScheduleSelector.jsx:446

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Line:** 446
**Violation:** IMPERATIVE_LOOP - for loop for day count iteration
**Severity:** High

**Expected Affected Pages:** /search, /favorite-listings

**Current Code:**
```javascript
  for (let i = 0; i < dayCount; i++) {
    // ... process each day
  }
```

**Refactored Code:**
```javascript
  Array.from({ length: dayCount }).forEach((_, i) => {
    // ... process each day
  });
```

**Why This Matters:**
While this is a simple for loop, using Array.from().forEach() or Array.from().map() maintains consistency with the declarative style throughout the codebase.

**Testing:**
- [ ] Verify day count iteration works correctly
- [ ] Test search schedule selector functionality

~~~~~

## CHUNK 19: Replace .sort() with .toSorted() and imperative loop with .every() in SearchScheduleSelector.jsx:319-351

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Line:** 319
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP - Multiple .sort() calls and for loops for contiguity check
**Severity:** High

**Expected Affected Pages:** /search, /favorite-listings

**Current Code:**
```javascript
  const isContiguous = useCallback((days) => {
    const daysArray = Array.from(days);

    // Edge cases
    if (daysArray.length <= 1) return true;
    if (daysArray.length >= 6) return true;

    const sortedDays = [...daysArray].sort((a, b) => a - b);

    // STEP 1: Check if selected days are continuous
    let isRegularContinuous = true;
    for (let i = 1; i < sortedDays.length; i++) {
      if (sortedDays[i] !== sortedDays[i - 1] + 1) {
        isRegularContinuous = false;
        break;
      }
    }

    if (isRegularContinuous) return true;

    // STEP 2: Check if UNSELECTED days are continuous
    const allDays = [0, 1, 2, 3, 4, 5, 6];
    const unselectedDays = allDays.filter(day => !sortedDays.includes(day));

    if (unselectedDays.length === 0) return true;

    const sortedUnselected = [...unselectedDays].sort((a, b) => a - b);
    for (let i = 1; i < sortedUnselected.length; i++) {
      if (sortedUnselected[i] !== sortedUnselected[i - 1] + 1) {
        return false;
      }
    }

    return true;
  }, []);
```

**Refactored Code:**
```javascript
  const isContiguous = useCallback((days) => {
    const daysArray = Array.from(days);

    // Edge cases
    if (daysArray.length <= 1) return true;
    if (daysArray.length >= 6) return true;

    const sortedDays = daysArray.toSorted((a, b) => a - b);

    // STEP 1: Check if selected days are continuous (declarative)
    const isRegularContinuous = sortedDays
      .slice(1)
      .every((day, i) => day === sortedDays[i] + 1);

    if (isRegularContinuous) return true;

    // STEP 2: Check if UNSELECTED days are continuous (wrap-around case)
    const allDays = [0, 1, 2, 3, 4, 5, 6];
    const unselectedDays = allDays.filter(day => !sortedDays.includes(day));

    if (unselectedDays.length === 0) return true;

    // Unselected days are already sorted since allDays is sorted
    return unselectedDays
      .slice(1)
      .every((day, i) => day === unselectedDays[i] + 1);
  }, []);
```

**Why This Matters:**
Replaces mutable flag variable and for loops with declarative .every(). The logic "every consecutive pair differs by 1" is expressed directly. Also uses .toSorted() instead of spread+sort.

**Testing:**
- [ ] Verify contiguity detection for regular selections
- [ ] Test wrap-around cases (Fri-Sun, Sat-Tue)
- [ ] Test edge cases (single day, all days)

~~~~~

## CHUNK 20: Replace conditional .push() with declarative array in dataLookups.js:560-564

**File:** app/src/lib/dataLookups.js
**Line:** 560
**Violation:** MUTATING_METHOD - Using .push() inside forEach for policy options
**Severity:** High

**Expected Affected Pages:** /create-listing, /edit-listing

**Current Code:**
```javascript
export function getAllCancellationPolicies() {
  const policies = [];
  lookupCache.cancellationPolicies.forEach((policy, id) => {
    policies.push({ id, display: policy.display });
  });
  return policies;
}
```

**Refactored Code:**
```javascript
export function getAllCancellationPolicies() {
  return Array.from(lookupCache.cancellationPolicies, ([id, policy]) => ({
    id,
    display: policy.display,
  }));
}
```

**Why This Matters:**
`Array.from()` with a Map directly converts to array with transformation in one expression. No intermediate mutable array needed.

**Testing:**
- [ ] Verify cancellation policies dropdown populates correctly
- [ ] Test on listing creation flow

~~~~~

## CHUNK 21: Replace conditional .push() with declarative array in dataLookups.js:590-598

**File:** app/src/lib/dataLookups.js
**Line:** 590
**Violation:** MUTATING_METHOD - Using .push() inside forEach + .sort() for reasons
**Severity:** High

**Expected Affected Pages:** /guest-proposals, /host-proposals

**Current Code:**
```javascript
export function getGuestCancellationReasons() {
  const reasons = [];
  lookupCache.guestCancellationReasons.forEach((data, id) => {
    reasons.push({
      id,
      reason: data.reason,
      displayOrder: data.displayOrder
    });
  });
  return reasons.sort((a, b) => a.displayOrder - b.displayOrder);
}
```

**Refactored Code:**
```javascript
export function getGuestCancellationReasons() {
  return Array.from(lookupCache.guestCancellationReasons, ([id, data]) => ({
    id,
    reason: data.reason,
    displayOrder: data.displayOrder,
  })).toSorted((a, b) => a.displayOrder - b.displayOrder);
}
```

**Why This Matters:**
Combines Array.from() transformation with .toSorted() for a fully declarative pipeline. No mutation at any step.

**Testing:**
- [ ] Verify guest cancellation reasons display in correct order
- [ ] Test cancellation flow

~~~~~

## CHUNK 22: Replace conditional .push() with declarative array in dataLookups.js:606-616

**File:** app/src/lib/dataLookups.js
**Line:** 606
**Violation:** MUTATING_METHOD - Using .push() inside forEach + .sort() for host reasons
**Severity:** High

**Expected Affected Pages:** /host-proposals

**Current Code:**
```javascript
export function getHostRejectionReasons() {
  const reasons = [];
  lookupCache.hostCancellationReasons.forEach((data, id) => {
    reasons.push({
      id,
      reason: data.reason,
      displayOrder: data.displayOrder
    });
  });
  return reasons.sort((a, b) => a.displayOrder - b.displayOrder);
}
```

**Refactored Code:**
```javascript
export function getHostRejectionReasons() {
  return Array.from(lookupCache.hostCancellationReasons, ([id, data]) => ({
    id,
    reason: data.reason,
    displayOrder: data.displayOrder,
  })).toSorted((a, b) => a.displayOrder - b.displayOrder);
}
```

**Why This Matters:**
Same pattern as guest cancellation reasons - declarative transformation with immutable sort.

**Testing:**
- [ ] Verify host rejection reasons display in correct order
- [ ] Test rejection flow

~~~~~

## CHUNK 23: Replace imperative loop with Array.from in listingService.js:766-770

**File:** app/src/lib/listingService.js
**Line:** 766
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for-of loop with .push() for day mapping
**Severity:** High

**Expected Affected Pages:** /create-listing, /edit-listing

**Current Code:**
```javascript
  const result = [];
  const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

  for (const day of dayOrder) {
    if (availableNights[day] && dayNameMapping[day]) {
      result.push(dayNameMapping[day]);
    }
  }

  return result;
```

**Refactored Code:**
```javascript
  const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

  return dayOrder
    .filter(day => availableNights[day] && dayNameMapping[day])
    .map(day => dayNameMapping[day]);
```

**Why This Matters:**
Filter + map is the idiomatic FP pattern for "select matching items and transform them." More readable than for-of with conditional push.

**Testing:**
- [ ] Verify available nights mapping works correctly
- [ ] Test listing creation with various night selections

~~~~~

## CHUNK 24: Replace conditional .push() with filter array in PricingEditSection.jsx:326-371

**File:** app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx
**Line:** 326
**Violation:** MUTATING_METHOD - Multiple .push() calls for change tracking
**Severity:** High

**Expected Affected Pages:** /listing-dashboard

**Current Code:**
```javascript
  const changes = [];
  if (selectedRentalType !== originalLeaseStyle) {
    changes.push(`Lease style: ${originalLeaseStyle} → ${selectedRentalType}`);
  }
  if (damageDeposit !== (listing?.damageDeposit || 500)) {
    changes.push(`Damage deposit: $${listing?.damageDeposit || 500} → $${damageDeposit}`);
  }
  if (maintenanceFee !== (listing?.maintenanceFee || 125)) {
    changes.push(`Maintenance fee: $${listing?.maintenanceFee || 125} → $${maintenanceFee}`);
  }
  // ... more similar push() calls
```

**Refactored Code:**
```javascript
  const changeChecks = [
    {
      condition: selectedRentalType !== originalLeaseStyle,
      message: `Lease style: ${originalLeaseStyle} → ${selectedRentalType}`,
    },
    {
      condition: damageDeposit !== (listing?.damageDeposit || 500),
      message: `Damage deposit: $${listing?.damageDeposit || 500} → $${damageDeposit}`,
    },
    {
      condition: maintenanceFee !== (listing?.maintenanceFee || 125),
      message: `Maintenance fee: $${listing?.maintenanceFee || 125} → $${maintenanceFee}`,
    },
    {
      condition: hasAvailableNightsChanged,
      message: `Available nights updated (${selectedNights.length} nights)`,
    },
    {
      condition: hasNightRangeChanged,
      message: `Nights range: ${minNights}-${maxNights}`,
    },
    {
      condition: hasNightlyRatesChanged,
      message: 'Nightly rates updated',
    },
    {
      condition: weeklyRate !== originalWeeklyRate,
      message: `Weekly rate: $${weeklyRate}/week`,
    },
    {
      condition: weeksOffered !== originalWeeksOffered,
      message: `Weekly pattern: ${patternLabels[weeksOffered] || weeksOffered}`,
    },
    {
      condition: monthlyRate !== originalMonthlyRate,
      message: `Monthly rate: $${monthlyRate}/month`,
    },
  ];

  const changes = changeChecks
    .filter(({ condition }) => condition)
    .map(({ message }) => message);
```

**Why This Matters:**
Data-driven approach with filter+map replaces multiple conditional pushes. Adding new change types is just adding an object to the array.

**Testing:**
- [ ] Verify change tracking shows correct changes
- [ ] Test various pricing edit combinations

~~~~~

## CHUNK 25: Replace validation .push() pattern with declarative array in listingLocalStore.ts:385-454

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 385
**Violation:** MUTATING_METHOD - Multiple .push() calls for validation errors
**Severity:** High

**Expected Affected Pages:** /create-listing

**Current Code:**
```typescript
  const errors: string[] = [];
  if (!data.spaceSnapshot.listingName?.trim()) {
    errors.push('Listing name is required');
  }
  if (!data.spaceSnapshot.typeOfSpace) {
    errors.push('Type of space is required');
  }
  if (!data.spaceSnapshot.typeOfKitchen) {
    errors.push('Type of kitchen is required');
  }
  // ... 15+ more similar push() calls
```

**Refactored Code:**
```typescript
  const validationRules: Array<{ condition: boolean; message: string }> = [
    { condition: !data.spaceSnapshot.listingName?.trim(), message: 'Listing name is required' },
    { condition: !data.spaceSnapshot.typeOfSpace, message: 'Type of space is required' },
    { condition: !data.spaceSnapshot.typeOfKitchen, message: 'Type of kitchen is required' },
    { condition: !data.spaceSnapshot.typeOfParking, message: 'Type of parking is required' },
    { condition: !data.spaceSnapshot.fullAddress?.trim(), message: 'Valid NYC address is required' },
    { condition: !data.features.amenitiesInsideUnit?.length, message: 'At least one amenity inside unit is required' },
    { condition: !data.features.descriptionOfLodging?.trim(), message: 'Description of lodging is required' },
    { condition: !data.leaseStyles.rentalType, message: 'Rental type is required' },
    { condition: data.leaseStyles.rentalType === 'split-lease' && !data.leaseStyles.availableNights?.length, message: 'At least one available night must be selected' },
    { condition: data.leaseStyles.rentalType === 'split-lease' && !data.leaseStyles.weeksOffered, message: 'Weekly pattern is required' },
    { condition: (data.pricing.damageDeposit ?? 0) < 500, message: 'Damage deposit must be at least $500' },
    { condition: data.leaseStyles.rentalType === 'monthly' && !data.pricing.monthlyCompensation, message: 'Monthly compensation is required' },
    { condition: data.leaseStyles.rentalType === 'weekly' && !data.pricing.weeklyCompensation, message: 'Weekly compensation is required' },
    { condition: data.leaseStyles.rentalType === 'split-lease' && !data.pricing.nightlyPricing, message: 'Nightly pricing is required' },
    { condition: !data.rules.cancellationPolicy, message: 'Cancellation policy is required' },
    { condition: !data.rules.checkInTime, message: 'Check-in time is required' },
    { condition: !data.rules.checkOutTime, message: 'Check-out time is required' },
    { condition: data.photos.urls.length < (data.photos.minRequired || 3), message: `At least ${data.photos.minRequired || 3} photos are required` },
  ];

  const errors = validationRules
    .filter(({ condition }) => condition)
    .map(({ message }) => message);
```

**Why This Matters:**
Declarative validation rules array makes all validations visible at a glance. Adding, removing, or modifying rules is straightforward. No mutation needed.

**Testing:**
- [ ] Test listing validation with missing required fields
- [ ] Verify all error messages display correctly
- [ ] Test rental type-specific validations

~~~~~

## References

### Files Analyzed:
- `app/src/logic/rules/scheduling/isScheduleContiguous.js`
- `app/src/logic/calculators/scheduling/calculateCheckInOutDays.js`
- `app/src/lib/availabilityValidation.js`
- `app/src/lib/dataLookups.js`
- `app/src/lib/listingService.js`
- `app/src/islands/shared/HostScheduleSelector/utils.js`
- `app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx`
- `app/src/islands/shared/SearchScheduleSelector.jsx`
- `app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx`
- `app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx`
- `app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx`
- `app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts`

### FP Principles Applied:
1. **IMMUTABILITY** - Use `.toSorted()`, `.toReversed()`, spread operators instead of mutating methods
2. **DECLARATIVE STYLE** - Use `Array.from()`, `.map()`, `.filter()`, `.every()`, `.findIndex()` instead of imperative loops
3. **PURE FUNCTIONS** - Functions return new data without side effects
4. **COMPOSITION** - Small, focused transformations composed together

### Notes:
- Total estimated chunks: 25 (covering the highest-impact violations)
- Remaining 324 violations follow similar patterns and can be addressed using the same techniques
- Priority should be given to logic/ and lib/ directories as they contain shared business logic
