# Functional Programming Refactoring Plan

**Date:** 2026-01-10
**Target:** agents/fp_audit_violations.json
**Severity Filter:** High
**Total Violations:** 356

---

## Summary by Violation Type

| Type | Count | Principle |
|------|-------|-----------|
| MUTATING_METHOD (.push(), .sort(), .reverse()) | 298 | IMMUTABILITY |
| IMPERATIVE_LOOP (for, while) | 58 | DECLARATIVE STYLE |

## Summary by File (Top 20 High-Impact Files)

| File | Violations |
|------|------------|
| src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx | 13 |
| src/islands/pages/SelfListingPage/store/listingLocalStore.ts | 19 |
| src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts | 16 |
| src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx | 11 |
| src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx | 11 |
| src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx | 10 |
| src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx | 11 |
| src/islands/shared/SearchScheduleSelector.jsx | 9 |
| src/lib/listingService.js | 8 |
| src/logic/workflows/proposals/counterofferWorkflow.js | 7 |

---

## ðŸ”´ CHUNK 1: Replace .push() with conditional array construction in counterofferWorkflow.js:156-198

**File:** app/src/logic/workflows/proposals/counterofferWorkflow.js
**Lines:** 153-198
**Violation:** MUTATING_METHOD - Using .push() to mutate array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Build list of changes
const changes = [];

if (originalTerms.totalPrice !== counterofferTerms.totalPrice) {
  changes.push({
    field: 'totalPrice',
    label: 'Total Price',
    original: originalTerms.totalPrice,
    modified: counterofferTerms.totalPrice
  });
}

if (originalTerms.nightlyPrice !== counterofferTerms.nightlyPrice) {
  changes.push({
    field: 'nightlyPrice',
    label: 'Nightly Rate',
    original: originalTerms.nightlyPrice,
    modified: counterofferTerms.nightlyPrice
  });
}

if (originalTerms.reservationWeeks !== counterofferTerms.reservationWeeks) {
  changes.push({
    field: 'reservationWeeks',
    label: 'Duration (Weeks)',
    original: originalTerms.reservationWeeks,
    modified: counterofferTerms.reservationWeeks
  });
}

if (originalTerms.nightsPerWeek !== counterofferTerms.nightsPerWeek) {
  changes.push({
    field: 'nightsPerWeek',
    label: 'Nights per Week',
    original: originalTerms.nightsPerWeek,
    modified: counterofferTerms.nightsPerWeek
  });
}

if (JSON.stringify(originalTerms.daysSelected) !== JSON.stringify(counterofferTerms.daysSelected)) {
  changes.push({
    field: 'daysSelected',
    label: 'Weekly Schedule',
    original: originalTerms.daysSelected,
    modified: counterofferTerms.daysSelected
  });
}
```

**Refactored Code:**
```javascript
// Build list of changes declaratively
const changes = [
  originalTerms.totalPrice !== counterofferTerms.totalPrice && {
    field: 'totalPrice',
    label: 'Total Price',
    original: originalTerms.totalPrice,
    modified: counterofferTerms.totalPrice
  },
  originalTerms.nightlyPrice !== counterofferTerms.nightlyPrice && {
    field: 'nightlyPrice',
    label: 'Nightly Rate',
    original: originalTerms.nightlyPrice,
    modified: counterofferTerms.nightlyPrice
  },
  originalTerms.reservationWeeks !== counterofferTerms.reservationWeeks && {
    field: 'reservationWeeks',
    label: 'Duration (Weeks)',
    original: originalTerms.reservationWeeks,
    modified: counterofferTerms.reservationWeeks
  },
  originalTerms.nightsPerWeek !== counterofferTerms.nightsPerWeek && {
    field: 'nightsPerWeek',
    label: 'Nights per Week',
    original: originalTerms.nightsPerWeek,
    modified: counterofferTerms.nightsPerWeek
  },
  JSON.stringify(originalTerms.daysSelected) !== JSON.stringify(counterofferTerms.daysSelected) && {
    field: 'daysSelected',
    label: 'Weekly Schedule',
    original: originalTerms.daysSelected,
    modified: counterofferTerms.daysSelected
  }
].filter(Boolean);
```

**Why This Matters:**
Declarative array construction shows all possible values at a glance. The pattern `condition && value` combined with `.filter(Boolean)` is idiomatic FP JavaScript that eliminates mutation while remaining readable.

**Testing:**
- [ ] Run unit tests for counteroffer workflow
- [ ] Verify proposal changes are tracked correctly
- [ ] Check edge case where no changes occur (empty array)

---

## ðŸ”´ CHUNK 2: Replace imperative loop with reduce in availabilityValidation.js:64-67

**File:** app/src/lib/availabilityValidation.js
**Lines:** 64-67
**Violation:** IMPERATIVE_LOOP - Using for loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Generate expected contiguous range for not-selected days
const expectedNotSelected = [];
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i);
}
```

**Refactored Code:**
```javascript
// Generate expected contiguous range for not-selected days
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
`Array.from` with a mapping function generates sequences declaratively without mutation. This pattern is clearer for numeric ranges and eliminates the mutable `push()` pattern.

**Testing:**
- [ ] Run tests for isContiguousSelection function
- [ ] Verify wrap-around cases (Fri-Sun, Sat-Tue)
- [ ] Check edge case: all 7 days selected

---

## ðŸ”´ CHUNK 3: Replace imperative loop with reduce in availabilityValidation.js:38-43

**File:** app/src/lib/availabilityValidation.js
**Lines:** 38-43
**Violation:** IMPERATIVE_LOOP - Using for loop for contiguity check
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Check for standard contiguous sequence (no wrap around)
let isStandardContiguous = true;
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    isStandardContiguous = false;
    break;
  }
}
```

**Refactored Code:**
```javascript
// Check for standard contiguous sequence (no wrap around)
const isStandardContiguous = sorted.slice(1).every(
  (day, i) => day === sorted[i] + 1
);
```

**Why This Matters:**
The `.every()` method is the declarative way to check if all elements satisfy a condition. It short-circuits on the first false value, matching the break behavior of the original loop.

**Testing:**
- [ ] Run tests for isContiguousSelection function
- [ ] Verify Mon-Fri returns true
- [ ] Verify Mon, Wed, Fri returns false

---

## ðŸ”´ CHUNK 4: Replace .push() loop in listingService.js:766-770

**File:** app/src/lib/listingService.js
**Lines:** 762-772
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for-of with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const result = [];
// Maintain proper day order
const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

for (const day of dayOrder) {
  if (availableNights[day] && dayNameMapping[day]) {
    result.push(dayNameMapping[day]);
  }
}

return result;
```

**Refactored Code:**
```javascript
// Maintain proper day order
const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

return dayOrder
  .filter(day => availableNights[day] && dayNameMapping[day])
  .map(day => dayNameMapping[day]);
```

**Why This Matters:**
Filter + map is the canonical FP pattern for selecting and transforming elements. It's more expressive than a for-of loop with conditional push.

**Testing:**
- [ ] Run tests for mapAvailableNightsToDayNames function
- [ ] Verify correct day ordering is maintained
- [ ] Check with empty availableNights object

---

## ðŸ”´ CHUNK 5: Replace imperative loop with every() in HostScheduleSelector/utils.js:28-33

**File:** app/src/islands/shared/HostScheduleSelector/utils.js
**Lines:** 28-33
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with .push() for gap detection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Check for gaps
const gaps = []
for (let i = 1; i < numbers.length; i++) {
  if (numbers[i] !== numbers[i - 1] + 1) {
    gaps.push(i)
  }
}
```

**Refactored Code:**
```javascript
// Check for gaps using reduce to collect indices
const gaps = numbers.slice(1).reduce((acc, num, i) =>
  num !== numbers[i] + 1 ? [...acc, i + 1] : acc
, []);
```

**Why This Matters:**
Reduce is the appropriate declarative method when you need to accumulate results based on comparisons with adjacent elements. The spread operator ensures immutability.

**Testing:**
- [ ] Run tests for checkContiguity function
- [ ] Verify [1,2,3] has no gaps
- [ ] Verify [1,3,5] correctly identifies gaps at indices 1 and 2

---

## ðŸ”´ CHUNK 6: Replace imperative sequence generation in HostScheduleSelector/utils.js:55-70

**File:** app/src/islands/shared/HostScheduleSelector/utils.js
**Lines:** 55-70
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sequence = []

if (startIdx <= endIdx) {
  // Ascending order
  for (let i = startIdx; i <= endIdx; i++) {
    sequence.push(getNightByDayIndex(i).id)
  }
} else {
  // Descending order
  for (let i = startIdx; i >= endIdx; i--) {
    sequence.push(getNightByDayIndex(i).id)
  }
}

return sequence
```

**Refactored Code:**
```javascript
const length = Math.abs(endIdx - startIdx) + 1;
const step = startIdx <= endIdx ? 1 : -1;

return Array.from({ length }, (_, i) =>
  getNightByDayIndex(startIdx + i * step).id
);
```

**Why This Matters:**
Array.from with a length and mapping function is the declarative alternative to loops that build up arrays incrementally. The direction is handled via the step multiplier.

**Testing:**
- [ ] Run tests for getNightSequence function
- [ ] Verify ascending sequence (Mon to Fri)
- [ ] Verify descending sequence (Fri to Mon)

---

## ðŸ”´ CHUNK 7: Replace .sort() with toSorted() in availabilityValidation.js:31

**File:** app/src/lib/availabilityValidation.js
**Line:** 31
**Violation:** MUTATING_METHOD - Using .sort() which mutates
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Sort the selected days
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
// Sort the selected days immutably
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
While `[...arr].sort()` creates a copy first, `toSorted()` is the ES2023 method specifically designed for immutable sorting. It's more intentional and doesn't require the spread-then-sort pattern.

**Testing:**
- [ ] Verify isContiguousSelection still works
- [ ] Check that original selectedDays array is unchanged
- [ ] Run full test suite for availabilityValidation

---

## ðŸ”´ CHUNK 8: Replace .sort() with toSorted() in availabilityValidation.js:97

**File:** app/src/lib/availabilityValidation.js
**Line:** 97
**Violation:** MUTATING_METHOD - Using .sort() which mutates
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistency with CHUNK 7. Using toSorted() throughout the file maintains a uniform immutable style.

**Testing:**
- [ ] Run tests for calculateCheckInOutDays function
- [ ] Verify check-in/check-out calculation is correct
- [ ] Check wrap-around day scenarios

---

## ðŸ”´ CHUNK 9: Replace .push() accumulation in LoggedInAvatar.jsx:174-323

**File:** app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx
**Lines:** 174-323
**Violation:** MUTATING_METHOD - 13 separate .push() calls for menu items
**Severity:** ðŸ”´ High

**Current Code (pattern):**
```javascript
const items = [];

// Host-specific items
if (isHost) {
  items.push({
    label: 'My Listings',
    href: '/my-listings',
    icon: HomeIcon
  });
}

if (isHost && hasActiveProposals) {
  items.push({
    label: 'Proposals',
    href: '/proposals',
    icon: DocumentIcon
  });
}
// ... 11 more conditional pushes
```

**Refactored Code:**
```javascript
const items = [
  isHost && {
    label: 'My Listings',
    href: '/my-listings',
    icon: HomeIcon
  },
  isHost && hasActiveProposals && {
    label: 'Proposals',
    href: '/proposals',
    icon: DocumentIcon
  },
  // ... all other conditional items
].filter(Boolean);
```

**Why This Matters:**
Menu item construction is a classic case for declarative array building. All possible items are visible at once, and the conditions are inline with the items they guard.

**Testing:**
- [ ] Verify menu renders correctly for host users
- [ ] Verify menu renders correctly for guest users
- [ ] Check all permission combinations

---

## ðŸ”´ CHUNK 10: Replace .push() class building in HostScheduleSelector.jsx:248-309

**File:** app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx
**Lines:** 248-309
**Violation:** MUTATING_METHOD - Multiple .push() for CSS class building
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const classes = ['hss-day-button']

if (isSelected) classes.push('hss-selected')

if (!isContiguousWithSelected) {
  classes.push('hss-non-contiguous')
}

if (!isAvailable) {
  classes.push('hss-unavailable')
}

if (disabled) {
  classes.push('hss-disabled')
}
```

**Refactored Code:**
```javascript
const classes = [
  'hss-day-button',
  isSelected && 'hss-selected',
  !isContiguousWithSelected && 'hss-non-contiguous',
  !isAvailable && 'hss-unavailable',
  disabled && 'hss-disabled'
].filter(Boolean).join(' ');
```

**Why This Matters:**
CSS class building is extremely common in React. The declarative array pattern eliminates mutation and produces a class string directly.

**Testing:**
- [ ] Verify schedule selector renders correct classes
- [ ] Test all state combinations (selected, disabled, unavailable)
- [ ] Visual regression test the component

---

## ðŸ”´ CHUNK 11: Replace .push() class building in ScheduleCohost.jsx:709-713

**File:** app/src/islands/shared/ScheduleCohost/ScheduleCohost.jsx
**Lines:** 709-713
**Violation:** MUTATING_METHOD - Multiple .push() for CSS class building
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const classNames = ['schedule-cohost-calendar-day'];
if (isOtherMonth) classNames.push('schedule-cohost-calendar-day--other');
if (isPast) classNames.push('schedule-cohost-calendar-day--past');
if (isActive) classNames.push('schedule-cohost-calendar-day--selected');
if (hasSlots) classNames.push('schedule-cohost-calendar-day--has-slots');
if (isTodayDate) classNames.push('schedule-cohost-calendar-day--today');
```

**Refactored Code:**
```javascript
const classNames = [
  'schedule-cohost-calendar-day',
  isOtherMonth && 'schedule-cohost-calendar-day--other',
  isPast && 'schedule-cohost-calendar-day--past',
  isActive && 'schedule-cohost-calendar-day--selected',
  hasSlots && 'schedule-cohost-calendar-day--has-slots',
  isTodayDate && 'schedule-cohost-calendar-day--today'
].filter(Boolean).join(' ');
```

**Why This Matters:**
Identical pattern to CHUNK 10. Consistent use of declarative class building across components.

**Testing:**
- [ ] Verify calendar day rendering
- [ ] Test all date state combinations
- [ ] Check styling matches expected behavior

---

## ðŸ”´ CHUNK 12: Replace imperative loop + .push() in AvailabilitySection.jsx:45-48

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Lines:** 43-49
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - while loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const getDatesInRange = (start, end) => {
  const dates = [];
  const current = new Date(start);
  while (current <= end) {
    dates.push(formatDateKey(current));
    current.setDate(current.getDate() + 1);
  }
  return dates;
};
```

**Refactored Code:**
```javascript
const getDatesInRange = (start, end) => {
  const dayCount = Math.floor((end - start) / (1000 * 60 * 60 * 24)) + 1;
  return Array.from({ length: dayCount }, (_, i) => {
    const date = new Date(start);
    date.setDate(date.getDate() + i);
    return formatDateKey(date);
  });
};
```

**Why This Matters:**
Date range generation is a common pattern. Array.from with calculated length is cleaner than while loops with mutation.

**Testing:**
- [ ] Run tests for getDatesInRange function
- [ ] Verify date range includes start and end dates
- [ ] Check single-day range (start === end)

---

## ðŸ”´ CHUNK 13: Replace calendar generation loops in AvailabilitySection.jsx:106-140

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Lines:** 106-140
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Multiple for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const days = [];

// Add padding for days before the 1st
for (let i = startPadding - 1; i >= 0; i--) {
  const prevDate = new Date(year, month, -i);
  days.push({
    date: prevDate,
    isCurrentMonth: false,
    // ...
  });
}

// Add days of the current month
for (let i = 1; i <= daysInMonth; i++) {
  days.push({
    date: new Date(year, month, i),
    isCurrentMonth: true,
    // ...
  });
}

// Add days after the month to fill the grid
for (let i = 1; i <= remaining; i++) {
  days.push({
    date: new Date(year, month + 1, i),
    isCurrentMonth: false,
    // ...
  });
}
```

**Refactored Code:**
```javascript
// Generate all calendar days declaratively
const days = [
  // Padding days before the 1st
  ...Array.from({ length: startPadding }, (_, i) => ({
    date: new Date(year, month, -(startPadding - 1 - i)),
    isCurrentMonth: false,
    // ...
  })),
  // Days of the current month
  ...Array.from({ length: daysInMonth }, (_, i) => ({
    date: new Date(year, month, i + 1),
    isCurrentMonth: true,
    // ...
  })),
  // Days after the month to fill the grid
  ...Array.from({ length: remaining }, (_, i) => ({
    date: new Date(year, month + 1, i + 1),
    isCurrentMonth: false,
    // ...
  }))
];
```

**Why This Matters:**
Calendar grid generation benefits from seeing all three segments (before, current, after) as a single declarative expression. The structure mirrors the visual layout.

**Testing:**
- [ ] Verify calendar renders correctly for all months
- [ ] Check February edge cases (28/29 days)
- [ ] Verify padding is correct for different starting days

---

## ðŸ”´ CHUNK 14: Replace .push() with spread in PricingEditSection.jsx:326-371

**File:** app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx
**Lines:** 326-371
**Violation:** MUTATING_METHOD - Multiple .push() for change tracking
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const changes = [];
if (originalLeaseStyle !== selectedRentalType) {
  changes.push(`Lease style: ${originalLeaseStyle} â†’ ${selectedRentalType}`);
}
if (damageDeposit !== (listing?.damageDeposit || 500)) {
  changes.push(`Damage deposit: $${listing?.damageDeposit || 500} â†’ $${damageDeposit}`);
}
// ... more conditional pushes
```

**Refactored Code:**
```javascript
const changes = [
  originalLeaseStyle !== selectedRentalType &&
    `Lease style: ${originalLeaseStyle} â†’ ${selectedRentalType}`,
  damageDeposit !== (listing?.damageDeposit || 500) &&
    `Damage deposit: $${listing?.damageDeposit || 500} â†’ $${damageDeposit}`,
  // ... more conditional items
].filter(Boolean);
```

**Why This Matters:**
Change tracking arrays are perfect for the conditional-spread pattern. All possible changes are visible in one place.

**Testing:**
- [ ] Verify change summary displays correctly
- [ ] Test with no changes (empty array)
- [ ] Test with all fields changed

---

## ðŸ”´ CHUNK 15: Replace .sort() with toSorted() in PricingEditSection.jsx:408

**File:** app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx
**Line:** 408
**Violation:** MUTATING_METHOD - Using .sort() on mapped array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const dayIndices = selectedNights.map((n) => nightMap[n]).sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const dayIndices = selectedNights.map((n) => nightMap[n]).toSorted((a, b) => a - b);
```

**Why This Matters:**
The map() result is a new array, but using toSorted() makes the immutable intent explicit.

**Testing:**
- [ ] Verify day indices are correctly sorted
- [ ] Check pricing calculations use correct order

---

## ðŸ”´ CHUNK 16: Replace .sort().reverse() chain in AvailabilitySection.jsx:253-254

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Lines:** 253-254
**Violation:** MUTATING_METHOD - .sort() followed by .reverse()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sortedDates = filteredDates
  .sort()
  .reverse(); // Most recent past dates first
```

**Refactored Code:**
```javascript
const sortedDates = filteredDates.toSorted().toReversed(); // Most recent past dates first
```

**Why This Matters:**
ES2023's toSorted() and toReversed() are designed to be chained without mutation.

**Testing:**
- [ ] Verify past dates are sorted most recent first
- [ ] Check availability display order

---

## ðŸ”´ CHUNK 17: Replace imperative loop in NightlyPricingLegend.jsx:26-28

**File:** app/src/islands/pages/ListingDashboardPage/components/NightlyPricingLegend.jsx
**Lines:** 26-28
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const nightsRange = [];
for (let i = nightsPerWeekMin; i <= nightsPerWeekMax; i++) {
  nightsRange.push(i);
}
```

**Refactored Code:**
```javascript
const nightsRange = Array.from(
  { length: nightsPerWeekMax - nightsPerWeekMin + 1 },
  (_, i) => nightsPerWeekMin + i
);
```

**Why This Matters:**
Numeric range generation is a fundamental FP pattern. Array.from with calculated length and index mapping is the standard approach.

**Testing:**
- [ ] Verify pricing legend shows all nights in range
- [ ] Check edge case: min === max

---

## ðŸ”´ CHUNK 18: Replace validation error accumulation in listingLocalStore.ts:387-454

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Lines:** 387-454
**Violation:** MUTATING_METHOD - Multiple .push() for error collection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errors = [];
if (!data.space?.listingName) {
  errors.push('Listing name is required');
}
if (!data.space?.typeOfSpace) {
  errors.push('Type of space is required');
}
if (!data.space?.typeOfKitchen) {
  errors.push('Type of kitchen is required');
}
// ... 15+ more conditional pushes
```

**Refactored Code:**
```javascript
const errors = [
  !data.space?.listingName && 'Listing name is required',
  !data.space?.typeOfSpace && 'Type of space is required',
  !data.space?.typeOfKitchen && 'Type of kitchen is required',
  // ... all other validation conditions
].filter(Boolean);
```

**Why This Matters:**
Validation error collection is a textbook case for declarative arrays. All validation rules are visible at once, making it easy to audit completeness.

**Testing:**
- [ ] Run full validation test suite
- [ ] Verify all error messages are collected
- [ ] Check empty submission catches all required fields

---

## ðŸ”´ CHUNK 19: Replace error accumulation in prepareListingSubmission.ts:270-288

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Lines:** 270-288
**Violation:** MUTATING_METHOD - Multiple .push() for validation errors
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errors = [];
if (!payload.Name) errors.push('Name is required');
if (!payload['Type of Space']) errors.push('Type of Space is required');
if (!payload.Address) errors.push('Address is required');
if (!payload['Rental Type']) errors.push('Rental Type is required');

if (payload['Rental Type'] === 'Monthly' && !payload['Monthly Compensation']) {
  errors.push('Monthly Compensation is required for Monthly rentals');
}
// ... more conditional pushes
```

**Refactored Code:**
```javascript
const errors = [
  !payload.Name && 'Name is required',
  !payload['Type of Space'] && 'Type of Space is required',
  !payload.Address && 'Address is required',
  !payload['Rental Type'] && 'Rental Type is required',
  payload['Rental Type'] === 'Monthly' && !payload['Monthly Compensation'] &&
    'Monthly Compensation is required for Monthly rentals',
  // ... all other conditions
].filter(Boolean);
```

**Why This Matters:**
Same pattern as CHUNK 18. Consistent validation error handling across the codebase.

**Testing:**
- [ ] Run submission validation tests
- [ ] Verify rental type-specific validations
- [ ] Check all required fields are validated

---

## ðŸ”´ CHUNK 20: Replace night conversion with filter in prepareListingSubmission.ts:93-99

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Lines:** 91-100
**Violation:** MUTATING_METHOD - Multiple .push() for day conversion
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const result = [];
if (nights.sunday) result.push('sunday');
if (nights.monday) result.push('monday');
if (nights.tuesday) result.push('tuesday');
if (nights.wednesday) result.push('wednesday');
if (nights.thursday) result.push('thursday');
if (nights.friday) result.push('friday');
if (nights.saturday) result.push('saturday');
return result;
```

**Refactored Code:**
```javascript
const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
return dayOrder.filter(day => nights[day]);
```

**Why This Matters:**
Object-to-array conversion with filtering is exactly what filter() is designed for. The day order is explicit and the logic is a single line.

**Testing:**
- [ ] Verify night conversion produces correct array
- [ ] Test with all nights selected
- [ ] Test with no nights selected

---

## ðŸ”´ CHUNK 21: Replace .sort() in ViewSplitLeasePage.jsx at multiple locations

**File:** app/src/islands/pages/ViewSplitLeasePage.jsx
**Lines:** 637, 798, 1256
**Violation:** MUTATING_METHOD - Using .sort() on spread arrays
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Line 637
return [...prev, dayIndex].sort((a, b) => a - b);

// Line 798
const sortedDays = [...selectedDayNumbers].sort((a, b) => a - b);

// Line 1256
const sortedJsDays = [...daysInJsFormat].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
// Line 637
return [...prev, dayIndex].toSorted((a, b) => a - b);

// Line 798
const sortedDays = selectedDayNumbers.toSorted((a, b) => a - b);

// Line 1256
const sortedJsDays = daysInJsFormat.toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistency in using toSorted() across the codebase. In React state updates, immutable operations are especially important.

**Testing:**
- [ ] Run ViewSplitLeasePage component tests
- [ ] Verify day selection ordering
- [ ] Check state update behavior

---

## ðŸ”´ CHUNK 22: Replace imperative loop in ViewSplitLeasePage.jsx:1268

**File:** app/src/islands/pages/ViewSplitLeasePage.jsx
**Line:** 1268
**Violation:** IMPERATIVE_LOOP - for loop for gap detection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (let i = 0; i < sortedJsDays.length - 1; i++) {
  if (sortedJsDays[i + 1] - sortedJsDays[i] > 1) {
    // Gap found logic
  }
}
```

**Refactored Code:**
```javascript
const hasGap = sortedJsDays.slice(0, -1).some(
  (day, i) => sortedJsDays[i + 1] - day > 1
);
```

**Why This Matters:**
Gap detection is a comparison between adjacent elements. `.some()` with slice is the declarative equivalent.

**Testing:**
- [ ] Verify gap detection works correctly
- [ ] Test contiguous selections return false
- [ ] Test non-contiguous selections return true

---

## ðŸ”´ CHUNK 23: Replace .push() in WhySplitLeasePage.jsx:129

**File:** app/src/islands/pages/WhySplitLeasePage.jsx
**Line:** 129
**Violation:** MUTATING_METHOD - .push() for photo ID collection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const legacyPhotoIds = [];
// ... some logic
legacyPhotoIds.push(firstPhoto);
```

**Refactored Code:**
```javascript
const legacyPhotoIds = firstPhoto ? [firstPhoto] : [];
```

**Why This Matters:**
When building an array with a single conditional item, use a ternary directly in the array literal.

**Testing:**
- [ ] Verify photo ID handling
- [ ] Check with and without firstPhoto

---

## ðŸ”´ CHUNK 24: Replace reduce accumulator mutation in ExternalReviews.jsx:60

**File:** app/src/islands/shared/ExternalReviews.jsx
**Line:** 60
**Violation:** MUTATING_METHOD - .push() inside reduce callback
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const grouped = reviews.reduce((acc, review) => {
  if (!acc[review.platform]) {
    acc[review.platform] = [];
  }
  acc[review.platform].push(review);
  return acc;
}, {});
```

**Refactored Code:**
```javascript
const grouped = reviews.reduce((acc, review) => ({
  ...acc,
  [review.platform]: [...(acc[review.platform] || []), review]
}), {});
```

**Why This Matters:**
Reduce with mutation is a common anti-pattern. Spreading the accumulator ensures each iteration produces a new object.

**Testing:**
- [ ] Verify reviews are grouped by platform
- [ ] Test with multiple platforms
- [ ] Test with single platform

---

## ðŸ”´ CHUNK 25: Replace .push() in GoogleMap.jsx:612, 643, 705, 733

**File:** app/src/islands/shared/GoogleMap.jsx
**Lines:** 612, 643, 705, 733
**Violation:** MUTATING_METHOD - Multiple .push() for marker and coordinate tracking
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Tracking skipped coordinates
skippedInvalidCoordinates.push({
  listing,
  reason: 'invalid'
});

// Tracking markers
markersRef.current.push(marker);
```

**Refactored Code:**
```javascript
// For skipped coordinates - collect declaratively
const skippedInvalidCoordinates = listings
  .filter(listing => !isValidCoordinate(listing))
  .map(listing => ({ listing, reason: 'invalid' }));

// For marker refs - this is React-specific, use state update
setMarkers(prev => [...prev, marker]);
```

**Why This Matters:**
Coordinate validation and collection can be done in a single filter+map chain. Marker tracking should use React state patterns.

**Testing:**
- [ ] Verify map renders with valid listings
- [ ] Check invalid coordinates are logged
- [ ] Verify marker cleanup on unmount

---

## ðŸ”´ CHUNK 26: Replace .sort() in SearchScheduleSelector.jsx at multiple locations

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Lines:** 319, 344, 546, 617
**Violation:** MUTATING_METHOD - Multiple .sort() calls
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sortedDays = [...daysArray].sort((a, b) => a - b);
const sortedUnselected = [...unselectedDays].sort((a, b) => a - b);
const sortedDays = [...selectedDaysArray].sort((a, b) => a - b);
const selectedDaysArray = Array.from(selectedDays).sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sortedDays = daysArray.toSorted((a, b) => a - b);
const sortedUnselected = unselectedDays.toSorted((a, b) => a - b);
const sortedDays = selectedDaysArray.toSorted((a, b) => a - b);
const selectedDaysArray = Array.from(selectedDays).toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent use of toSorted() throughout the schedule selector component.

**Testing:**
- [ ] Run SearchScheduleSelector tests
- [ ] Verify day ordering in all scenarios
- [ ] Check wrap-around handling

---

## ðŸ”´ CHUNK 27: Replace imperative loops in SearchScheduleSelector.jsx:323, 345, 446, 557

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Lines:** 323, 345, 446, 557
**Violation:** IMPERATIVE_LOOP - Multiple for loops
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Line 323 - Gap detection
for (let i = 1; i < sortedDays.length; i++) {
  if (sortedDays[i] - sortedDays[i - 1] > 1) {
    // gap logic
  }
}
```

**Refactored Code:**
```javascript
// Gap detection with some()
const hasGap = sortedDays.slice(1).some(
  (day, i) => day - sortedDays[i] > 1
);
```

**Why This Matters:**
All gap detection loops can use the same pattern from CHUNK 22.

**Testing:**
- [ ] Test gap detection for all scenarios
- [ ] Verify contiguity validation works
- [ ] Check day count iteration

---

## ðŸ”´ CHUNK 28: Replace .pop() usage in SearchScheduleSelector.jsx:585

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Line:** 585
**Violation:** MUTATING_METHOD - Using .pop() (via filter().pop())
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
checkoutDayIndex = sortedDays.filter(day => day < gapStart).pop();
```

**Refactored Code:**
```javascript
const daysBeforeGap = sortedDays.filter(day => day < gapStart);
checkoutDayIndex = daysBeforeGap.at(-1);
```

**Why This Matters:**
`.at(-1)` is the immutable way to get the last element. Note: The original code using filter().pop() is actually safe since filter creates a new array, but .at(-1) is more intentional.

**Testing:**
- [ ] Verify checkout day calculation
- [ ] Test with gap at various positions

---

## ðŸ”´ CHUNK 29: Replace .sort() in CreateProposalFlowV2.jsx:257

**File:** app/src/islands/shared/CreateProposalFlowV2.jsx
**Line:** 257
**Violation:** MUTATING_METHOD - .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...dayObjs].sort((a, b) => a.dayOfWeek - b.dayOfWeek);
```

**Refactored Code:**
```javascript
const sorted = dayObjs.toSorted((a, b) => a.dayOfWeek - b.dayOfWeek);
```

**Why This Matters:**
Consistency with toSorted() pattern.

**Testing:**
- [ ] Run CreateProposalFlowV2 tests
- [ ] Verify day object sorting

---

## ðŸ”´ CHUNK 30: Replace imperative loop in CreateProposalFlowV2.jsx:267

**File:** app/src/islands/shared/CreateProposalFlowV2.jsx
**Line:** 267
**Violation:** IMPERATIVE_LOOP - for loop for gap detection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (let i = 0; i < dayNumbers.length - 1; i++) {
  if (dayNumbers[i + 1] - dayNumbers[i] !== 1) {
    // non-contiguous logic
  }
}
```

**Refactored Code:**
```javascript
const isContiguous = dayNumbers.slice(0, -1).every(
  (day, i) => dayNumbers[i + 1] - day === 1
);
```

**Why This Matters:**
Same pattern as gap detection in other components.

**Testing:**
- [ ] Verify contiguity check in proposal flow
- [ ] Test with contiguous and non-contiguous days

---

## ðŸ”´ CHUNK 31: Replace .push() class building in HostEditingProposal/ScheduleSelector.jsx:119-121

**File:** app/src/islands/shared/HostEditingProposal/ScheduleSelector.jsx
**Lines:** 119-121
**Violation:** MUTATING_METHOD - .push() for CSS classes
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const classes = ['hss-day-button'];
if (isSelected) classes.push('hss-selected')
if (!isAvailable) classes.push('hss-unavailable')
if (disabled) classes.push('hss-disabled')
```

**Refactored Code:**
```javascript
const classes = [
  'hss-day-button',
  isSelected && 'hss-selected',
  !isAvailable && 'hss-unavailable',
  disabled && 'hss-disabled'
].filter(Boolean).join(' ');
```

**Why This Matters:**
Same pattern as CHUNK 10 and 11. CSS class building should be consistent.

**Testing:**
- [ ] Verify schedule selector styling
- [ ] Test all state combinations

---

## ðŸ”´ CHUNK 32: Replace .push() class building in SimpleHostScheduleSelector.jsx:145-149

**File:** app/src/islands/shared/HostScheduleSelector/SimpleHostScheduleSelector.jsx
**Lines:** 145-149
**Violation:** MUTATING_METHOD - .push() for CSS classes
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const classes = ['shss-night-button'];
if (isSelected) classes.push('shss-selected')
if (isDisabled) classes.push('shss-disabled')
```

**Refactored Code:**
```javascript
const classes = [
  'shss-night-button',
  isSelected && 'shss-selected',
  isDisabled && 'shss-disabled'
].filter(Boolean).join(' ');
```

**Why This Matters:**
Consistent CSS class building pattern.

**Testing:**
- [ ] Verify simple schedule selector styling
- [ ] Test selected and disabled states

---

## ðŸ”´ CHUNK 33: Replace .sort() in SimpleHostScheduleSelector.jsx:117

**File:** app/src/islands/shared/HostScheduleSelector/SimpleHostScheduleSelector.jsx
**Line:** 117
**Violation:** MUTATING_METHOD - .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const newSelection = [...selectedNights, nightId].sort((a, b) => {
  // sorting logic
});
```

**Refactored Code:**
```javascript
const newSelection = [...selectedNights, nightId].toSorted((a, b) => {
  // sorting logic
});
```

**Why This Matters:**
Consistent use of toSorted().

**Testing:**
- [ ] Verify night selection ordering
- [ ] Test selection behavior

---

## ðŸ”´ CHUNK 34: Replace .push() in BookTimeSlot.jsx:155-159

**File:** app/src/islands/shared/VirtualMeetingManager/BookTimeSlot.jsx
**Lines:** 155-159
**Violation:** MUTATING_METHOD - .push() for CSS classes
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const classes = ['vm-date-button'];
if (isActive) classes.push('vm-date-button-active');
if (hasSlots) classes.push('vm-date-button-has-slots');
```

**Refactored Code:**
```javascript
const classes = [
  'vm-date-button',
  isActive && 'vm-date-button-active',
  hasSlots && 'vm-date-button-has-slots'
].filter(Boolean).join(' ');
```

**Why This Matters:**
Consistent CSS class building pattern.

**Testing:**
- [ ] Verify date button styling in meeting manager
- [ ] Test active and has-slots states

---

## ðŸ”´ CHUNK 35: Replace .push() location building in FavoriteListingsPage.jsx:529-530

**File:** app/src/islands/pages/FavoriteListingsPage/FavoriteListingsPage.jsx
**Lines:** 529-530
**Violation:** MUTATING_METHOD - .push() for location parts
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const locationParts = [];
if (neighborhoodName) locationParts.push(neighborhoodName);
if (boroughName) locationParts.push(boroughName);
```

**Refactored Code:**
```javascript
const locationParts = [neighborhoodName, boroughName].filter(Boolean);
```

**Why This Matters:**
String part collection for joining is a perfect filter(Boolean) case.

**Testing:**
- [ ] Verify location display format
- [ ] Test with missing neighborhood or borough

---

## ðŸ”´ CHUNK 36: Replace .sort() in FavoriteListingsPage.jsx:1022

**File:** app/src/islands/pages/FavoriteListingsPage/FavoriteListingsPage.jsx
**Line:** 1022
**Violation:** MUTATING_METHOD - .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sortedJsDays = [...daysInJsFormat].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sortedJsDays = daysInJsFormat.toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent toSorted() usage.

**Testing:**
- [ ] Verify day sorting in favorites page

---

## ðŸ”´ CHUNK 37: Replace .push() for React roots in FavoriteListingsPage.jsx:1248-1254

**File:** app/src/islands/pages/FavoriteListingsPage/FavoriteListingsPage.jsx
**Lines:** 1248-1254
**Violation:** MUTATING_METHOD - .push() for React root collection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const roots = [];
// ...
roots.push(rootDesktop);
// ...
roots.push(rootMobile);
```

**Refactored Code:**
```javascript
const roots = [rootDesktop, rootMobile].filter(Boolean);
```

**Why This Matters:**
React root collection can be done declaratively.

**Testing:**
- [ ] Verify both desktop and mobile roots are created
- [ ] Check cleanup function works

---

## ðŸ”´ CHUNK 38: Replace .sort() and loop in ProposalCard.jsx:121-130

**File:** app/src/islands/pages/proposals/ProposalCard.jsx
**Lines:** 121-130
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP - .sort() and for loop
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...dayIndices].sort((a, b) => a - b);
// Check contiguity
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    // non-contiguous
  }
}
```

**Refactored Code:**
```javascript
const sorted = dayIndices.toSorted((a, b) => a - b);
const isContiguous = sorted.slice(1).every(
  (day, i) => day === sorted[i] + 1
);
```

**Why This Matters:**
Combined toSorted() and every() pattern.

**Testing:**
- [ ] Verify proposal card day display
- [ ] Test contiguity indication

---

## ðŸ”´ CHUNK 39: Replace .push() in MapView.jsx:83, 126

**File:** app/src/islands/pages/FavoriteListingsPage/components/MapView.jsx
**Lines:** 83, 126
**Violation:** MUTATING_METHOD - .push() for bounds and markers
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
bounds.push(position);
// ...
markersRef.current.push(marker);
```

**Refactored Code:**
```javascript
// For bounds - use map to collect positions
const bounds = validListings.map(listing => getPosition(listing));

// For markers - use React state pattern
setMarkers(prev => [...prev, marker]);
```

**Why This Matters:**
Position collection should be done with map(). Marker tracking should use state.

**Testing:**
- [ ] Verify map bounds calculation
- [ ] Check marker rendering

---

## ðŸ”´ CHUNK 40: Replace .push() and loop in SplitScheduleSelector.jsx:49-55

**File:** app/src/islands/pages/FavoriteListingsPage/components/SplitScheduleSelector.jsx
**Lines:** 49-55
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - while loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const days = [];
while (current < checkOut) {
  days.push(current.getDay());
  current.setDate(current.getDate() + 1);
}
const uniqueDays = Array.from(new Set(days)).sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const dayCount = Math.ceil((checkOut - current) / (1000 * 60 * 60 * 24));
const days = Array.from({ length: dayCount }, (_, i) => {
  const date = new Date(current);
  date.setDate(date.getDate() + i);
  return date.getDay();
});
const uniqueDays = [...new Set(days)].toSorted((a, b) => a - b);
```

**Why This Matters:**
Date iteration should use Array.from with calculated length.

**Testing:**
- [ ] Verify day collection for date range
- [ ] Check unique day extraction
- [ ] Test across week boundaries

---

## ðŸ”´ CHUNK 41: Replace .sort() in SplitScheduleSelector.jsx:77

**File:** app/src/islands/pages/FavoriteListingsPage/components/SplitScheduleSelector.jsx
**Line:** 77
**Violation:** MUTATING_METHOD - .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
newSelectedDays = [...selectedDays, dayIndex].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
newSelectedDays = [...selectedDays, dayIndex].toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent toSorted() usage.

**Testing:**
- [ ] Verify day selection in split schedule

---

## ðŸ”´ CHUNK 42: Replace .sort() in ListingsCard.jsx:18

**File:** app/src/islands/pages/AccountProfilePage/components/cards/ListingsCard.jsx
**Line:** 18
**Violation:** MUTATING_METHOD - .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sortedPhotos = [...photos].sort((a, b) => (a.Order || 0) - (b.Order || 0));
```

**Refactored Code:**
```javascript
const sortedPhotos = photos.toSorted((a, b) => (a.Order || 0) - (b.Order || 0));
```

**Why This Matters:**
Consistent toSorted() usage.

**Testing:**
- [ ] Verify photo ordering in listings card

---

## ðŸ”´ CHUNK 43: Replace .sort() in ScheduleCommuteCard.jsx:38

**File:** app/src/islands/pages/AccountProfilePage/components/cards/ScheduleCommuteCard.jsx
**Line:** 38
**Violation:** MUTATING_METHOD - .sort() in chain
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
.sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
.toSorted((a, b) => a - b)
```

**Why This Matters:**
Consistent toSorted() usage.

**Testing:**
- [ ] Verify commute schedule display

---

## ðŸ”´ CHUNK 44: Replace .sort() in listingLocalStore.ts:198

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 198
**Violation:** MUTATING_METHOD - .sort() on Array.from
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
this.state.data.completedSections = Array.from(completedSections).sort();
```

**Refactored Code:**
```javascript
this.state.data.completedSections = Array.from(completedSections).toSorted();
```

**Why This Matters:**
Consistent toSorted() usage in store.

**Testing:**
- [ ] Verify completed sections tracking

---

## ðŸ”´ CHUNK 45: Replace error accumulation pattern in Section1SpaceSnapshot.tsx

**File:** app/src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx
**Lines:** 291-334
**Violation:** MUTATING_METHOD - Multiple .push() for error fields
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errorOrder = [];
if (!listingName) errorOrder.push('listingName');
if (listingName && listingName.length < 3) errorOrder.push('listingName');
if (!typeOfSpace) errorOrder.push('typeOfSpace');
// ... more conditional pushes
```

**Refactored Code:**
```javascript
const errorOrder = [
  !listingName && 'listingName',
  listingName && listingName.length < 3 && 'listingName',
  !typeOfSpace && 'typeOfSpace',
  // ... all conditions
].filter(Boolean);
```

**Why This Matters:**
Form validation error ordering should be declarative.

**Testing:**
- [ ] Run Section1 validation tests
- [ ] Verify error field ordering

---

## ðŸ”´ CHUNK 46: Replace error accumulation in Section2Features.tsx

**File:** app/src/islands/pages/SelfListingPage/sections/Section2Features.tsx
**Lines:** 207-212
**Violation:** MUTATING_METHOD - .push() for error fields
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errorOrder = [];
if (!hasAmenities) errorOrder.push('amenitiesInsideUnit');
if (!descriptionOfLodging) errorOrder.push('descriptionOfLodging');
```

**Refactored Code:**
```javascript
const errorOrder = [
  !hasAmenities && 'amenitiesInsideUnit',
  !descriptionOfLodging && 'descriptionOfLodging'
].filter(Boolean);
```

**Why This Matters:**
Consistent error handling pattern.

**Testing:**
- [ ] Run Section2 validation tests

---

## ðŸ”´ CHUNK 47: Replace error accumulation in Section3LeaseStyles.tsx

**File:** app/src/islands/pages/SelfListingPage/sections/Section3LeaseStyles.tsx
**Lines:** 132-137
**Violation:** MUTATING_METHOD - .push() for error fields
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errorOrder = [];
if (!weeklyPattern) errorOrder.push('weeklyPattern');
if (!subsidyAgreement) errorOrder.push('subsidyAgreement');
```

**Refactored Code:**
```javascript
const errorOrder = [
  !weeklyPattern && 'weeklyPattern',
  !subsidyAgreement && 'subsidyAgreement'
].filter(Boolean);
```

**Why This Matters:**
Consistent error handling pattern.

**Testing:**
- [ ] Run Section3 validation tests

---

## ðŸ”´ CHUNK 48: Replace error accumulation in Section4Pricing.tsx

**File:** app/src/islands/pages/SelfListingPage/sections/Section4Pricing.tsx
**Lines:** 50-67
**Violation:** MUTATING_METHOD - .push() for error fields
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errorOrder = [];
if (!monthlyCompensation) errorOrder.push('monthlyCompensation');
if (!weeklyCompensation) errorOrder.push('weeklyCompensation');
if (!nightlyPricing) errorOrder.push('nightlyPricing');
if (damageDeposit < 500) errorOrder.push('damageDeposit');
```

**Refactored Code:**
```javascript
const errorOrder = [
  !monthlyCompensation && 'monthlyCompensation',
  !weeklyCompensation && 'weeklyCompensation',
  !nightlyPricing && 'nightlyPricing',
  damageDeposit < 500 && 'damageDeposit'
].filter(Boolean);
```

**Why This Matters:**
Consistent error handling pattern.

**Testing:**
- [ ] Run Section4 validation tests

---

## ðŸ”´ CHUNK 49: Replace date generation loops in Section5Rules.tsx

**File:** app/src/islands/pages/SelfListingPage/sections/Section5Rules.tsx
**Lines:** 103-147
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Multiple while/for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Generate dates in range
const dates = [];
while (current <= end) {
  dates.push(new Date(current));
  current.setDate(current.getDate() + 1);
}

// Generate calendar days
const days = [];
for (let i = 0; i < startingDayOfWeek; i++) {
  days.push(null);
}
for (let d = 1; d <= daysInMonth; d++) {
  days.push(new Date(year, month, d));
}
```

**Refactored Code:**
```javascript
// Generate dates in range
const dayCount = Math.ceil((end - current) / (1000 * 60 * 60 * 24)) + 1;
const dates = Array.from({ length: dayCount }, (_, i) => {
  const date = new Date(current);
  date.setDate(date.getDate() + i);
  return date;
});

// Generate calendar days
const days = [
  ...Array(startingDayOfWeek).fill(null),
  ...Array.from({ length: daysInMonth }, (_, i) => new Date(year, month, i + 1))
];
```

**Why This Matters:**
Calendar and date generation is cleaner with Array.from and spread.

**Testing:**
- [ ] Run Section5 calendar tests
- [ ] Verify date range generation
- [ ] Check calendar padding

---

## ðŸ”´ CHUNK 50: Replace error accumulation in Section5Rules.tsx

**File:** app/src/islands/pages/SelfListingPage/sections/Section5Rules.tsx
**Lines:** 178-194
**Violation:** MUTATING_METHOD - .push() for error fields
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errorOrder = [];
if (!cancellationPolicy) errorOrder.push('cancellationPolicy');
if (!idealMinDuration) errorOrder.push('idealMinDuration');
if (!idealMaxDuration) errorOrder.push('idealMaxDuration');
if (minDuration > maxDuration) errorOrder.push('idealMaxDuration');
```

**Refactored Code:**
```javascript
const errorOrder = [
  !cancellationPolicy && 'cancellationPolicy',
  !idealMinDuration && 'idealMinDuration',
  !idealMaxDuration && 'idealMaxDuration',
  minDuration > maxDuration && 'idealMaxDuration'
].filter(Boolean);
```

**Why This Matters:**
Consistent error handling pattern.

**Testing:**
- [ ] Run Section5 validation tests

---

## ðŸ”´ CHUNK 51: Replace error accumulation in Section6Photos.tsx

**File:** app/src/islands/pages/SelfListingPage/sections/Section6Photos.tsx
**Line:** 266
**Violation:** MUTATING_METHOD - .push() for error fields
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errorOrder = [];
if (photos.length < minRequired) errorOrder.push('photos');
```

**Refactored Code:**
```javascript
const errorOrder = [
  photos.length < minRequired && 'photos'
].filter(Boolean);
```

**Why This Matters:**
Consistent error handling pattern.

**Testing:**
- [ ] Run Section6 validation tests

---

## ðŸ”´ CHUNK 52: Replace imperative loop in NightlyPriceSlider.tsx:70-72

**File:** app/src/islands/pages/SelfListingPage/components/NightlyPriceSlider.tsx
**Lines:** 70-72
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const prices = [basePrice];
for (let i = 1; i < N; i++) {
  prices.push(roundUp(prices[i - 1] * decay));
}
```

**Refactored Code:**
```javascript
const prices = Array.from({ length: N }, (_, i) =>
  i === 0 ? basePrice : roundUp(prices[i - 1] * decay)
);
// Note: This won't work as-is because prices[i-1] doesn't exist yet.
// Use reduce instead:
const prices = Array.from({ length: N }).reduce((acc, _, i) =>
  i === 0
    ? [basePrice]
    : [...acc, roundUp(acc[i - 1] * decay)]
, []);
```

**Why This Matters:**
Price decay generation with dependency on previous values requires reduce pattern.

**Testing:**
- [ ] Verify price decay calculation
- [ ] Test with various decay values

---

## ðŸ”´ CHUNK 53: Replace imperative loops in SelfListingPageV2.tsx:518-526

**File:** app/src/islands/pages/SelfListingPageV2/SelfListingPageV2.tsx
**Lines:** 518-526
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const prices = [basePrice];
for (let i = 1; i < 7; i++) {
  prices.push(Math.ceil(prices[i - 1] * clampedDecay));
}

let total = 0;
for (let i = 0; i < numNights && i < prices.length; i++) {
  total += prices[i];
}
```

**Refactored Code:**
```javascript
const prices = Array.from({ length: 7 }).reduce((acc, _, i) =>
  i === 0
    ? [basePrice]
    : [...acc, Math.ceil(acc[i - 1] * clampedDecay)]
, []);

const total = prices.slice(0, numNights).reduce((sum, price) => sum + price, 0);
```

**Why This Matters:**
Price calculation and summation should use reduce.

**Testing:**
- [ ] Verify price array generation
- [ ] Test total calculation for various numNights

---

## ðŸ”´ CHUNK 54: Replace imperative loop in rentalApplicationFieldMapper.ts:401-404

**File:** app/src/islands/pages/RentalApplicationPage/utils/rentalApplicationFieldMapper.ts
**Lines:** 401-404
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const completed = [];
for (let step = 1; step <= 7; step++) {
  if (isStepComplete(step)) {
    completed.push(step);
  }
}
```

**Refactored Code:**
```javascript
const completed = Array.from({ length: 7 }, (_, i) => i + 1)
  .filter(step => isStepComplete(step));
```

**Why This Matters:**
Step filtering is cleaner with Array.from + filter.

**Testing:**
- [ ] Verify step completion tracking
- [ ] Test with various completion states

---

## ðŸ”´ CHUNK 55: Replace imperative loops in AiSignupMarketReport.jsx

**File:** app/src/islands/shared/AiSignupMarketReport/AiSignupMarketReport.jsx
**Lines:** 47, 111, 123, 680-683
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for-of loops with pattern matching
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
// Pattern matching loops
for (const pattern of namePatterns) {
  const match = text.match(pattern);
  if (match) return match[1];
}

// Topic detection
const detectedTopics = [];
for (const topic of FREEFORM_TOPICS) {
  if (text.includes(topic.keyword)) {
    detectedTopics.push(topic.id);
  }
}
```

**Refactored Code:**
```javascript
// Pattern matching with find
const nameMatch = namePatterns
  .map(pattern => text.match(pattern))
  .find(match => match);
const name = nameMatch?.[1];

// Topic detection with filter + map
const detectedTopics = FREEFORM_TOPICS
  .filter(topic => text.includes(topic.keyword))
  .map(topic => topic.id);
```

**Why This Matters:**
Pattern matching with early return can use find(). Topic detection is filter + map.

**Testing:**
- [ ] Run AI market report tests
- [ ] Verify pattern matching
- [ ] Check topic detection

---

## ðŸ”´ CHUNK 56: Replace .sort() in DaysSelectionSection.jsx:63

**File:** app/src/islands/shared/CreateProposalFlowV2Components/DaysSelectionSection.jsx
**Line:** 63
**Violation:** MUTATING_METHOD - .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...dayNumbers].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = dayNumbers.toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent toSorted() usage.

**Testing:**
- [ ] Verify days selection sorting

---

## ðŸ”´ CHUNK 57: Replace imperative loop in DaysSelectionSection.jsx:72

**File:** app/src/islands/shared/CreateProposalFlowV2Components/DaysSelectionSection.jsx
**Line:** 72
**Violation:** IMPERATIVE_LOOP - for loop for contiguity check
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (let i = 0; i < sorted.length - 1; i++) {
  if (sorted[i + 1] - sorted[i] !== 1) {
    return false;
  }
}
```

**Refactored Code:**
```javascript
return sorted.slice(0, -1).every(
  (day, i) => sorted[i + 1] - day === 1
);
```

**Why This Matters:**
Same contiguity check pattern as other chunks.

**Testing:**
- [ ] Verify contiguity check in days selection

---

---

## Implementation Priority

### Phase 1: Core Logic (Chunks 1-8)
High-impact pure logic functions that affect data flow across the app.

### Phase 2: Component Patterns (Chunks 9-15)
CSS class building and menu construction patterns that appear in multiple components.

### Phase 3: Schedule Components (Chunks 21-43)
Day/schedule-related sorting and loops that appear across schedule selectors.

### Phase 4: Form Validation (Chunks 18-20, 45-51)
Validation error accumulation patterns in the SelfListingPage.

### Phase 5: Remaining Components (Chunks 52-57)
Lower-frequency patterns in specialized components.

---

## References

- **FP Audit JSON**: `agents/fp_audit_violations.json`
- **FP Guide**: `.claude/skills/functional-code/README.md`
- **FP Bible**: `.claude/Documentation/Architecture/The Functional Programming Bible A Practical Reference for Writing Pure, Functional Code.md`

---

## Notes

1. **Browser Compatibility**: `toSorted()` and `toReversed()` require ES2023. Ensure build targets support this or use polyfills.

2. **React State Updates**: Some `.push()` patterns are inside React state updates. These should use the spread pattern: `setState(prev => [...prev, newItem])`.

3. **Performance**: For very large arrays, the spread-based immutable patterns may have performance implications. Profile if needed.

4. **Testing Strategy**: Each chunk should be tested in isolation before moving to the next. Run the full test suite after completing each phase.
