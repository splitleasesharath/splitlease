# Functional Programming Refactoring Plan

**Date:** 2026-01-10
**Target:** agents/fp_audit_violations.json
**Severity Filter:** high
**Total Violations:** 238 (high severity)

---

## Summary by Violation Type

| Type | Count | Principle |
|------|-------|-----------|
| MUTATING_METHOD (.push/.sort/.unshift/.pop) | 189 | IMMUTABILITY |
| IMPERATIVE_LOOP (for/while) | 49 | DECLARATIVE STYLE |

## Summary by File (Sorted by Violation Count)

| File | Violations |
|------|------------|
| LoggedInAvatar.jsx | 12 |
| listingLocalStore.ts | 21 |
| prepareListingSubmission.ts | 18 |
| Section1SpaceSnapshot.tsx | 10 |
| HostScheduleSelector.jsx | 10 |
| PricingEditSection.jsx | 10 |
| SearchPage.jsx | 9 |
| AvailabilitySection.jsx | 12 |
| Section5Rules.tsx | 10 |
| cohostService.js | 5 |
| useAccountProfilePageLogic.js | 8 |
| FavoriteListingsPage formatters.js | 8 |

---

## CHUNKS BY FILE

---

# FILE: cohostService.js
**Path:** app/src/islands/shared/ScheduleCohost/cohostService.js

---

## ðŸ”´ CHUNK 1: Replace imperative loop in generateCalendarDays

**File:** app/src/islands/shared/ScheduleCohost/cohostService.js
**Line:** 40
**Violation:** IMPERATIVE_LOOP - Imperative for loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const days = [];
for (let i = 0; i < totalDays; i++) {
  const date = new Date(startDate);
  date.setDate(startDate.getDate() + i);
  days.push(date);
}

return days;
```

**Refactored Code:**
```javascript
const days = Array.from({ length: totalDays }, (_, i) => {
  const date = new Date(startDate);
  date.setDate(startDate.getDate() + i);
  return date;
});

return days;
```

**Why This Matters:**
`Array.from` with a mapping function is declarative - it clearly shows "create N items, each derived from its index." The imperative loop hides intent behind control flow mechanics.

**Testing:**
- [ ] Verify calendar grid renders correctly for months with 5 weeks
- [ ] Verify calendar grid renders correctly for months with 6 weeks
- [ ] Check padding days from previous/next month appear correctly

---

## ðŸ”´ CHUNK 2: Replace nested imperative loops in generateTimeSlots

**File:** app/src/islands/shared/ScheduleCohost/cohostService.js
**Lines:** 61-66
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Nested for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const slots = [];
const date = new Date(selectedDate);

for (let hour = startHour; hour < endHour; hour++) {
  for (let minutes = 0; minutes < 60; minutes += intervalMinutes) {
    const slotTime = new Date(date);
    slotTime.setHours(hour, minutes, 0, 0);

    slots.push({
      id: `slot_${slotTime.getTime()}`,
      dateTime: slotTime,
      formattedTime: formatTimeOnly(slotTime),
      displayTime: formatDateTime(slotTime),
    });
  }
}

return slots;
```

**Refactored Code:**
```javascript
const date = new Date(selectedDate);
const hours = Array.from({ length: endHour - startHour }, (_, i) => startHour + i);
const minuteIntervals = Array.from({ length: Math.ceil(60 / intervalMinutes) }, (_, i) => i * intervalMinutes);

const slots = hours.flatMap(hour =>
  minuteIntervals
    .filter(minutes => minutes < 60)
    .map(minutes => {
      const slotTime = new Date(date);
      slotTime.setHours(hour, minutes, 0, 0);
      return {
        id: `slot_${slotTime.getTime()}`,
        dateTime: slotTime,
        formattedTime: formatTimeOnly(slotTime),
        displayTime: formatDateTime(slotTime),
      };
    })
);

return slots;
```

**Why This Matters:**
Nested loops obscure the relationship between hours and minutes. `flatMap` + `map` clearly shows "for each hour, generate slots for each minute interval."

**Testing:**
- [ ] Verify time slots generate from 11 AM to 10 PM (default)
- [ ] Verify custom start/end hours work
- [ ] Verify 30-minute intervals generate correct slots

---

# FILE: useAccountProfilePageLogic.js
**Path:** app/src/islands/pages/AccountProfilePage/useAccountProfilePageLogic.js

---

## ðŸ”´ CHUNK 3: Replace conditional .push() in generateNextActions

**File:** app/src/islands/pages/AccountProfilePage/useAccountProfilePageLogic.js
**Lines:** 96-137
**Violation:** MUTATING_METHOD - Multiple .push() calls with conditionals
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
function generateNextActions(profileData, verifications) {
  const actions = [];

  if (!profileData?.profilePhoto) {
    actions.push({
      id: 'photo',
      text: 'Add a profile photo',
      points: 20,
      icon: 'camera'
    });
  }
  if (!verifications?.govId) {
    actions.push({
      id: 'govId',
      text: 'Verify your identity',
      points: 15,
      icon: 'shield'
    });
  }
  if (!verifications?.linkedin) {
    actions.push({
      id: 'linkedin',
      text: 'Connect your LinkedIn',
      points: 15,
      icon: 'linkedin'
    });
  }
  if (!profileData?.bio || profileData.bio.trim().length === 0) {
    actions.push({
      id: 'bio',
      text: 'Write a short bio',
      points: 15,
      icon: 'edit'
    });
  }
  if (!verifications?.phone) {
    actions.push({
      id: 'phone',
      text: 'Verify your phone number',
      points: 10,
      icon: 'phone'
    });
  }

  return actions.slice(0, 3);
}
```

**Refactored Code:**
```javascript
function generateNextActions(profileData, verifications) {
  const allActions = [
    !profileData?.profilePhoto && {
      id: 'photo',
      text: 'Add a profile photo',
      points: 20,
      icon: 'camera'
    },
    !verifications?.govId && {
      id: 'govId',
      text: 'Verify your identity',
      points: 15,
      icon: 'shield'
    },
    !verifications?.linkedin && {
      id: 'linkedin',
      text: 'Connect your LinkedIn',
      points: 15,
      icon: 'linkedin'
    },
    (!profileData?.bio || profileData.bio.trim().length === 0) && {
      id: 'bio',
      text: 'Write a short bio',
      points: 15,
      icon: 'edit'
    },
    !verifications?.phone && {
      id: 'phone',
      text: 'Verify your phone number',
      points: 10,
      icon: 'phone'
    },
  ].filter(Boolean);

  return allActions.slice(0, 3);
}
```

**Why This Matters:**
Declarative array construction shows all possible actions upfront. The reader immediately sees every potential action without tracing through conditionals. `.filter(Boolean)` is an FP idiom for removing falsy values.

**Testing:**
- [ ] Verify actions show when profile photo missing
- [ ] Verify actions show for unverified identity
- [ ] Verify maximum of 3 actions returned
- [ ] Verify empty profile returns top 3 priority actions

---

## ðŸ”´ CHUNK 4: Replace .sort() with toSorted() in day selection

**File:** app/src/islands/pages/AccountProfilePage/useAccountProfilePageLogic.js
**Line:** 718
**Violation:** MUTATING_METHOD - Using .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
: [...currentDays, dayIndex].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
: [...currentDays, dayIndex].toSorted((a, b) => a - b);
```

**Why This Matters:**
While spreading before sort prevents mutation of the original, `toSorted()` (ES2023) is the idiomatic immutable approach. It's clearer intent and removes any ambiguity about mutation.

**Testing:**
- [ ] Verify day selection adds days in sorted order
- [ ] Verify existing day selection is not mutated

---

# FILE: formatters.js (FavoriteListingsPage)
**Path:** app/src/islands/pages/FavoriteListingsPage/formatters.js

---

## ðŸ”´ CHUNK 5: Replace .push() in formatBedroomsBathroomsKitchen

**File:** app/src/islands/pages/FavoriteListingsPage/formatters.js
**Lines:** 64-82
**Violation:** MUTATING_METHOD - Multiple conditional .push() calls
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const parts = [];

// CONDITIONAL 1: When bedrooms = 1
if (bedrooms === 1) {
  parts.push('1 bedroom');
}
// CONDITIONAL 3: When bedrooms > 1
else if (bedrooms > 1) {
  parts.push(`${bedrooms} bedrooms`);
}

// Add bathroom information (if > 0)
if (bathrooms > 0) {
  const bathroomDisplay = getBathroomDisplay(bathrooms);
  parts.push(bathroomDisplay);
}

// CONDITIONAL 4: Add kitchen type only if provided
if (kitchenType && kitchenType !== '') {
  parts.push(kitchenType);
}

return parts.length > 0 ? 'â€¢ ' + parts.join(' â€¢ ') : '';
```

**Refactored Code:**
```javascript
const bedroomText = bedrooms === 1
  ? '1 bedroom'
  : bedrooms > 1
    ? `${bedrooms} bedrooms`
    : null;

const bathroomText = bathrooms > 0 ? getBathroomDisplay(bathrooms) : null;

const kitchenText = kitchenType && kitchenType !== '' ? kitchenType : null;

const parts = [bedroomText, bathroomText, kitchenText].filter(Boolean);

return parts.length > 0 ? 'â€¢ ' + parts.join(' â€¢ ') : '';
```

**Why This Matters:**
Each value is computed independently and then combined. This is more testable (each computation can be unit tested) and easier to reason about.

**Testing:**
- [ ] Verify "1 bedroom" displays for single bedroom
- [ ] Verify "X bedrooms" plural for multiple
- [ ] Verify bathroom display formatting
- [ ] Verify kitchen type appears when provided

---

## ðŸ”´ CHUNK 6: Replace .push() in formatLocation

**File:** app/src/islands/pages/FavoriteListingsPage/formatters.js
**Lines:** 112-120
**Violation:** MUTATING_METHOD - Multiple conditional .push() calls
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
export const formatLocation = (borough, hood, city) => {
  const parts = [];

  if (borough) parts.push(borough);
  if (hood) parts.push(hood);
  if (city) parts.push(city);

  return parts.join(', ');
};
```

**Refactored Code:**
```javascript
export const formatLocation = (borough, hood, city) => {
  return [borough, hood, city].filter(Boolean).join(', ');
};
```

**Why This Matters:**
Single expression clearly shows: "take these three values, keep truthy ones, join with commas." This is a common FP pattern for building strings from optional parts.

**Testing:**
- [ ] Verify full location "Brooklyn, Williamsburg, New York"
- [ ] Verify partial location "Brooklyn, New York" (no hood)
- [ ] Verify single location "Brooklyn"
- [ ] Verify empty string when all null/undefined

---

# FILE: HostScheduleSelector.jsx
**Path:** app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx

---

## ðŸ”´ CHUNK 7: Replace .push() in getNightCellClasses

**File:** app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx
**Lines:** 242-266
**Violation:** MUTATING_METHOD - Multiple conditional .push() for CSS classes
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const getNightCellClasses = useCallback(
  (nightId) => {
    const classes = ['hss-night-cell']
    const isSelected = selectedNights.includes(nightId)
    const isAvailable = isNightAvailable(nightId, availableNights)

    // Selected state
    if (isSelected) {
      classes.push('hss-selected')

      // Non-contiguous in proposal mode
      if (inProposal && !isContiguous) {
        classes.push('hss-non-contiguous')
      }
    }

    // Unavailable state
    if (!isAvailable) {
      classes.push('hss-unavailable')
    }

    // Disabled state
    if (!isClickable || (mode === 'preview' && !isAvailable)) {
      classes.push('hss-disabled')
    }

    return classes.join(' ')
  },
  [selectedNights, availableNights, isClickable, inProposal, isContiguous, mode]
)
```

**Refactored Code:**
```javascript
const getNightCellClasses = useCallback(
  (nightId) => {
    const isSelected = selectedNights.includes(nightId)
    const isAvailable = isNightAvailable(nightId, availableNights)
    const isDisabled = !isClickable || (mode === 'preview' && !isAvailable)

    const classes = [
      'hss-night-cell',
      isSelected && 'hss-selected',
      isSelected && inProposal && !isContiguous && 'hss-non-contiguous',
      !isAvailable && 'hss-unavailable',
      isDisabled && 'hss-disabled',
    ].filter(Boolean)

    return classes.join(' ')
  },
  [selectedNights, availableNights, isClickable, inProposal, isContiguous, mode]
)
```

**Why This Matters:**
All class conditions are visible at once. The pattern `condition && 'className'` + `.filter(Boolean)` is the idiomatic React pattern for conditional classes.

**Testing:**
- [ ] Verify selected nights get 'hss-selected' class
- [ ] Verify unavailable nights get 'hss-unavailable' class
- [ ] Verify non-contiguous warning in proposal mode
- [ ] Verify disabled state applies correctly

---

## ðŸ”´ CHUNK 8: Replace .push() in getContainerClasses

**File:** app/src/islands/shared/HostScheduleSelector/HostScheduleSelector.jsx
**Lines:** 297-313
**Violation:** MUTATING_METHOD - Multiple conditional .push() for container classes
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const getContainerClasses = useCallback(() => {
  const classes = ['hss-host-schedule-selector']

  if (mode === 'preview') {
    classes.push('hss-preview-mode')
  } else if (mode === 'step-by-step-guide') {
    classes.push('hss-step-by-step-mode')
  } else if (mode === 'proposal' || inProposal) {
    classes.push('hss-proposal-mode')
  }

  if (className) {
    classes.push(className)
  }

  return classes.join(' ')
}, [mode, inProposal, className])
```

**Refactored Code:**
```javascript
const getContainerClasses = useCallback(() => {
  const modeClass = {
    'preview': 'hss-preview-mode',
    'step-by-step-guide': 'hss-step-by-step-mode',
  }[mode] ?? ((mode === 'proposal' || inProposal) ? 'hss-proposal-mode' : null);

  const classes = [
    'hss-host-schedule-selector',
    modeClass,
    className,
  ].filter(Boolean)

  return classes.join(' ')
}, [mode, inProposal, className])
```

**Why This Matters:**
Using an object lookup for mode-to-class mapping eliminates the if-else chain. This is more maintainable when adding new modes.

**Testing:**
- [ ] Verify preview mode adds 'hss-preview-mode'
- [ ] Verify step-by-step mode adds correct class
- [ ] Verify proposal mode detection
- [ ] Verify custom className is appended

---

# FILE: LoggedInAvatar.jsx
**Path:** app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx

---

## ðŸ”´ CHUNK 9: Replace .push() pattern in getMenuItems

**File:** app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx
**Lines:** 169-331
**Violation:** MUTATING_METHOD - 12 conditional .push() calls for menu items
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const getMenuItems = () => {
  const items = [];

  // 1. My Profile - ALWAYS visible
  if (menuVisibility.myProfile) {
    items.push({
      id: 'profile',
      label: 'My Profile',
      icon: '/assets/icons/user-purple.svg',
      path: `/account-profile/${user.id}`,
    });
  }

  // 2. My Proposals - Visible for all users
  if (menuVisibility.myProposals) {
    items.push({
      id: 'proposals',
      label: 'My Proposals',
      icon: '/assets/icons/file-text-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? '/guest-proposals'
        : '/host-proposals',
      badgeCount: effectiveProposalsCount,
      badgeColor: 'purple',
    });
  }

  // ... 10 more similar blocks

  return items;
};
```

**Refactored Code:**
```javascript
const getMenuItems = () => {
  const listingsPath = effectiveListingsCount === 1 && effectiveFirstListingId
    ? `/listing-dashboard?id=${effectiveFirstListingId}`
    : '/host-overview';

  const vmQueryParam = effectiveVirtualMeetingsCount > 0
    ? '?scrollTo=virtual-meetings'
    : '?highlightVMButton=true';

  const menuItemConfigs = [
    menuVisibility.myProfile && {
      id: 'profile',
      label: 'My Profile',
      icon: '/assets/icons/user-purple.svg',
      path: `/account-profile/${user.id}`,
    },
    menuVisibility.myProposals && {
      id: 'proposals',
      label: 'My Proposals',
      icon: '/assets/icons/file-text-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? '/guest-proposals'
        : '/host-proposals',
      badgeCount: effectiveProposalsCount,
      badgeColor: 'purple',
    },
    menuVisibility.myProposalsSuggested && {
      id: 'proposals-suggested',
      label: 'Proposals Suggested',
      icon: '/assets/icons/file-text-purple.svg',
      path: '/proposals-suggested',
    },
    menuVisibility.myListings && {
      id: 'listings',
      label: 'My Listings',
      icon: '/assets/icons/list-purple.svg',
      path: listingsPath,
      badgeCount: effectiveListingsCount,
      badgeColor: 'purple',
    },
    menuVisibility.virtualMeetings && {
      id: 'virtual-meetings',
      label: 'Virtual Meetings',
      icon: '/assets/icons/video-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? `/guest-proposals${vmQueryParam}`
        : `/host-proposals${vmQueryParam}`,
      badgeCount: effectiveVirtualMeetingsCount,
      badgeColor: 'purple',
    },
    menuVisibility.houseManualsAndVisits && {
      id: 'house-manuals',
      label: 'House manuals & Visits',
      icon: '/assets/icons/book-open-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? '/guest-house-manual'
        : effectiveHouseManualsCount === 1
          ? '/host-house-manual'
          : '/host-overview',
    },
    menuVisibility.myLeases && {
      id: 'leases',
      label: 'My Leases',
      icon: '/assets/icons/key-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? '/guest-leases'
        : '/host-leases',
      badgeCount: effectiveLeasesCount,
      badgeColor: 'purple',
    },
    menuVisibility.myFavoriteListings && {
      id: 'favorites',
      label: 'My Favorite Listings',
      icon: '/assets/icons/heart-purple.svg',
      path: '/favorite-listings',
      badgeCount: effectiveFavoritesCount,
      badgeColor: 'purple',
    },
    menuVisibility.messages && {
      id: 'messages',
      label: 'Messages',
      icon: '/assets/icons/message-circle-purple.svg',
      path: '/messages',
      badgeCount: effectiveUnreadMessagesCount,
      badgeColor: 'red',
    },
    menuVisibility.rentalApplication && {
      id: 'rental-application',
      label: 'Rental Application',
      icon: '/assets/icons/clipboard-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.HOST
        ? '/account'
        : `/account-profile/${user.id}?section=rental-application`,
    },
    menuVisibility.reviewsManager && {
      id: 'reviews',
      label: 'Reviews Manager',
      icon: '/assets/icons/star-purple.svg',
      path: '/reviews-overview',
    },
    menuVisibility.referral && {
      id: 'referral',
      label: 'Referral',
      icon: '/assets/icons/gift-purple.svg',
      action: () => setShowReferralModal(true),
    },
  ];

  return menuItemConfigs.filter(Boolean);
};
```

**Why This Matters:**
All menu items are defined in a single array literal. Visibility conditions are co-located with their items. Adding/removing/reordering items is trivial. The entire menu structure is visible at a glance.

**Testing:**
- [ ] Verify all menu items appear for appropriate user types
- [ ] Verify badge counts display correctly
- [ ] Verify menu item ordering is preserved
- [ ] Verify referral modal opens on click

---

# FILE: SearchPage.jsx
**Path:** app/src/islands/pages/SearchPage.jsx

---

## ðŸ”´ CHUNK 10: Replace .sort() with toSorted() in day sorting

**File:** app/src/islands/pages/SearchPage.jsx
**Line:** 89
**Violation:** MUTATING_METHOD - .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sortedDays = [...selectedDaysArray].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sortedDays = selectedDaysArray.toSorted((a, b) => a - b);
```

**Why This Matters:**
`toSorted()` returns a new sorted array without mutation. Clearer intent and one less array copy operation.

**Testing:**
- [ ] Verify days sort correctly (0-6 order)
- [ ] Verify original array is not mutated

---

## ðŸ”´ CHUNK 11: Replace imperative gap-finding loop

**File:** app/src/islands/pages/SearchPage.jsx
**Lines:** 99-104
**Violation:** IMPERATIVE_LOOP - for loop to find gap in sorted days
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
let gapIndex = -1;
for (let i = 1; i < sortedDays.length; i++) {
  if (sortedDays[i] - sortedDays[i - 1] > 1) {
    gapIndex = i;
    break;
  }
}
```

**Refactored Code:**
```javascript
const gapIndex = sortedDays.findIndex((day, i) =>
  i > 0 && day - sortedDays[i - 1] > 1
);
```

**Why This Matters:**
`findIndex` is declarative - it says "find the index where this condition is true." The imperative loop hides this intent behind loop mechanics.

**Testing:**
- [ ] Verify gap detection for Mon-Tue-Thu (gap at Thu)
- [ ] Verify no gap detection for continuous days
- [ ] Verify wrap-around detection (Sat-Sun with gap)

---

## ðŸ”´ CHUNK 12: Replace .push() for locationParts

**File:** app/src/islands/pages/SearchPage.jsx
**Lines:** 1979-1980
**Violation:** MUTATING_METHOD - Conditional .push() for location parts
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const locationParts = [];
if (neighborhoodName) locationParts.push(neighborhoodName);
if (boroughName) locationParts.push(boroughName);
```

**Refactored Code:**
```javascript
const locationParts = [neighborhoodName, boroughName].filter(Boolean);
```

**Why This Matters:**
Single expression shows all location components. Filter removes empty/null values.

**Testing:**
- [ ] Verify location displays correctly with both parts
- [ ] Verify location displays correctly with only borough
- [ ] Verify empty array when both null

---

## ðŸ”´ CHUNK 13: Replace .push() for React roots array

**File:** app/src/islands/pages/SearchPage.jsx
**Lines:** 2632-2638
**Violation:** MUTATING_METHOD - Conditional .push() for React roots
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const roots = [];
if (desktopContainer) {
  const rootDesktop = createRoot(desktopContainer);
  roots.push(rootDesktop);
}
if (mobileContainer) {
  const rootMobile = createRoot(mobileContainer);
  roots.push(rootMobile);
}
```

**Refactored Code:**
```javascript
const containers = [
  desktopContainer && { container: desktopContainer },
  mobileContainer && { container: mobileContainer },
].filter(Boolean);

const roots = containers.map(({ container }) => createRoot(container));
```

**Why This Matters:**
Separates the "what containers exist" decision from the "create roots" action. More testable and easier to add additional containers.

**Testing:**
- [ ] Verify desktop root created when container exists
- [ ] Verify mobile root created when container exists
- [ ] Verify both roots created when both containers exist
- [ ] Verify empty array when no containers

---

# FILE: listingLocalStore.ts
**Path:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts

---

## ðŸ”´ CHUNK 14: Replace .push() pattern in validation errors

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Lines:** 387-454
**Violation:** MUTATING_METHOD - 18 conditional .push() calls for validation errors
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errors: string[] = [];

if (!data.listingName?.trim()) {
  errors.push('Listing name is required');
}
if (!data.typeOfSpace) {
  errors.push('Type of space is required');
}
if (!data.typeOfKitchen) {
  errors.push('Type of kitchen is required');
}
// ... 15 more similar patterns
```

**Refactored Code:**
```javascript
const validationRules = [
  [!data.listingName?.trim(), 'Listing name is required'],
  [!data.typeOfSpace, 'Type of space is required'],
  [!data.typeOfKitchen, 'Type of kitchen is required'],
  [!data.typeOfParking, 'Type of parking is required'],
  [!data.fullAddress?.trim() || !data.isValidNYCAddress, 'Valid NYC address is required'],
  [!data.amenitiesInsideUnit?.length, 'At least one amenity inside unit is required'],
  [!data.descriptionOfLodging?.trim(), 'Description of lodging is required'],
  [!data.rentalType, 'Rental type is required'],
  [data.rentalType === 'nightly' && !data.availableNights?.length, 'At least one available night must be selected'],
  [data.rentalType === 'weekly' && !data.weeklyPattern, 'Weekly pattern is required'],
  [typeof data.damageDeposit === 'number' && data.damageDeposit < 500, 'Damage deposit must be at least $500'],
  [data.rentalType === 'monthly' && !data.monthlyCompensation, 'Monthly compensation is required'],
  [data.rentalType === 'weekly' && !data.weeklyCompensation, 'Weekly compensation is required'],
  [data.rentalType === 'nightly' && !data.nightlyPricing, 'Nightly pricing is required'],
  [!data.cancellationPolicy, 'Cancellation policy is required'],
  [!data.checkInTime, 'Check-in time is required'],
  [!data.checkOutTime, 'Check-out time is required'],
  [data.photos.items.length < data.photos.minRequired, `At least ${data.photos.minRequired} photos are required`],
] as const;

const errors = validationRules
  .filter(([condition]) => condition)
  .map(([, message]) => message);
```

**Why This Matters:**
Validation rules are data, not code. This pattern makes it trivial to add/remove/reorder rules. Each rule is a tuple of [condition, message], making the validation logic table-driven.

**Testing:**
- [ ] Verify all required field validations trigger
- [ ] Verify conditional validations (nightly pricing only for nightly type)
- [ ] Verify error messages are correctly associated
- [ ] Verify empty errors array when all valid

---

## ðŸ”´ CHUNK 15: Replace .sort() with toSorted() for completedSections

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 198
**Violation:** MUTATING_METHOD - .sort() mutates Array.from result
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
this.state.data.completedSections = Array.from(completedSections).sort();
```

**Refactored Code:**
```javascript
this.state.data.completedSections = [...completedSections].toSorted();
```

**Why This Matters:**
`toSorted()` is the immutable sorting method. Clearer intent about immutability.

**Testing:**
- [ ] Verify sections sort alphabetically
- [ ] Verify original Set is not affected

---

# FILE: prepareListingSubmission.ts
**Path:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts

---

## ðŸ”´ CHUNK 16: Replace .push() pattern in availableNights conversion

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Lines:** 93-99
**Violation:** MUTATING_METHOD - 7 conditional .push() calls for day names
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const result: string[] = [];
if (nights.sunday) result.push('sunday');
if (nights.monday) result.push('monday');
if (nights.tuesday) result.push('tuesday');
if (nights.wednesday) result.push('wednesday');
if (nights.thursday) result.push('thursday');
if (nights.friday) result.push('friday');
if (nights.saturday) result.push('saturday');
return result;
```

**Refactored Code:**
```javascript
const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'] as const;
return dayOrder.filter(day => nights[day]);
```

**Why This Matters:**
Declarative filtering replaces 7 conditional statements. Day order is explicit data, not implicit in code order.

**Testing:**
- [ ] Verify correct days returned when selected
- [ ] Verify order is Sunday through Saturday
- [ ] Verify empty array when no days selected

---

## ðŸ”´ CHUNK 17: Replace .push() pattern in payload validation

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Lines:** 270-288
**Violation:** MUTATING_METHOD - 8 conditional .push() calls for validation errors
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errors: string[] = [];
if (!payload.Name) errors.push('Name is required');
if (!payload['Type of Space']) errors.push('Type of Space is required');
if (!payload.Address) errors.push('Address is required');
if (!payload['Rental Type']) errors.push('Rental Type is required');

if (payload['Rental Type'] === 'Monthly' && !payload['Monthly Compensation']) {
  errors.push('Monthly Compensation is required for Monthly rentals');
}
if (payload['Rental Type'] === 'Weekly' && !payload['Weekly Compensation']) {
  errors.push('Weekly Compensation is required for Weekly rentals');
}
if (payload['Rental Type'] === 'Nightly' && !payload['Nightly Prices']) {
  errors.push('Nightly pricing is required for Nightly rentals');
}

if (payload['Damage Deposit'] && payload['Damage Deposit'] < 500) {
  errors.push('Damage Deposit must be at least $500');
}
```

**Refactored Code:**
```javascript
const validationRules = [
  [!payload.Name, 'Name is required'],
  [!payload['Type of Space'], 'Type of Space is required'],
  [!payload.Address, 'Address is required'],
  [!payload['Rental Type'], 'Rental Type is required'],
  [payload['Rental Type'] === 'Monthly' && !payload['Monthly Compensation'], 'Monthly Compensation is required for Monthly rentals'],
  [payload['Rental Type'] === 'Weekly' && !payload['Weekly Compensation'], 'Weekly Compensation is required for Weekly rentals'],
  [payload['Rental Type'] === 'Nightly' && !payload['Nightly Prices'], 'Nightly pricing is required for Nightly rentals'],
  [payload['Damage Deposit'] && payload['Damage Deposit'] < 500, 'Damage Deposit must be at least $500'],
] as const;

const errors = validationRules
  .filter(([condition]) => condition)
  .map(([, message]) => message);
```

**Why This Matters:**
Same table-driven validation pattern. Consistent with listingLocalStore.ts pattern for maintainability.

**Testing:**
- [ ] Verify required field validations
- [ ] Verify rental-type-specific validations
- [ ] Verify damage deposit minimum validation

---

# FILE: AvailabilitySection.jsx
**Path:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx

---

## ðŸ”´ CHUNK 18: Replace while loop in getDateRange

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Lines:** 45-47
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - while loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const dates = [];
while (current <= end) {
  dates.push(formatDateKey(current));
  current.setDate(current.getDate() + 1);
}
```

**Refactored Code:**
```javascript
const dayCount = Math.ceil((end - current) / (1000 * 60 * 60 * 24)) + 1;
const dates = Array.from({ length: dayCount }, (_, i) => {
  const date = new Date(current);
  date.setDate(current.getDate() + i);
  return formatDateKey(date);
});
```

**Why This Matters:**
Declarative date range generation. The length is computed upfront, making the iteration predictable and testable.

**Testing:**
- [ ] Verify correct date range for week (7 dates)
- [ ] Verify correct date range for month (28-31 dates)
- [ ] Verify inclusive of both start and end dates

---

## ðŸ”´ CHUNK 19: Replace for loops in calendar generation

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Lines:** 106-134
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Multiple for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const days = [];

// Previous month padding
for (let i = startPadding - 1; i >= 0; i--) {
  const prevDate = new Date(monthStart);
  prevDate.setDate(prevDate.getDate() - (i + 1));
  days.push({
    date: prevDate,
    isCurrentMonth: false,
  });
}

// Current month days
for (let i = 1; i <= daysInMonth; i++) {
  days.push({
    date: new Date(monthStart.getFullYear(), monthStart.getMonth(), i),
    isCurrentMonth: true,
  });
}

// Next month padding
for (let i = 1; i <= remaining; i++) {
  days.push({
    date: new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, i),
    isCurrentMonth: false,
  });
}
```

**Refactored Code:**
```javascript
const prevMonthDays = Array.from({ length: startPadding }, (_, i) => {
  const prevDate = new Date(monthStart);
  prevDate.setDate(prevDate.getDate() - (startPadding - i));
  return { date: prevDate, isCurrentMonth: false };
});

const currentMonthDays = Array.from({ length: daysInMonth }, (_, i) => ({
  date: new Date(monthStart.getFullYear(), monthStart.getMonth(), i + 1),
  isCurrentMonth: true,
}));

const nextMonthDays = Array.from({ length: remaining }, (_, i) => ({
  date: new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, i + 1),
  isCurrentMonth: false,
}));

const days = [...prevMonthDays, ...currentMonthDays, ...nextMonthDays];
```

**Why This Matters:**
Each section (prev, current, next month) is generated independently. This allows unit testing each generator. The final spread combination shows the calendar structure clearly.

**Testing:**
- [ ] Verify calendar displays 42 days (6 weeks)
- [ ] Verify padding days from previous month
- [ ] Verify padding days from next month
- [ ] Verify current month days marked correctly

---

## ðŸ”´ CHUNK 20: Replace .sort().reverse() chain

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Lines:** 253-254
**Violation:** MUTATING_METHOD - Chained .sort().reverse() mutates array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
.sort()
.reverse(); // Most recent past dates first
```

**Refactored Code:**
```javascript
.toSorted((a, b) => b.localeCompare(a)); // Most recent past dates first
```

**Why This Matters:**
`toSorted` with descending comparator achieves the same result without mutation and without the intermediate `.reverse()` call.

**Testing:**
- [ ] Verify dates sorted most recent first
- [ ] Verify original array not mutated

---

# FILE: PricingEditSection.jsx
**Path:** app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx

---

## ðŸ”´ CHUNK 21: Replace .push() pattern in changes summary

**File:** app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx
**Lines:** 326-371
**Violation:** MUTATING_METHOD - 10 conditional .push() calls for change summary
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const changes = [];

if (selectedRentalType !== originalLeaseStyle) {
  changes.push(`Lease style: ${originalLeaseStyle} â†’ ${selectedRentalType}`);
}

if (damageDeposit !== listing?.damageDeposit) {
  changes.push(`Damage deposit: $${listing?.damageDeposit || 500} â†’ $${damageDeposit}`);
}

if (maintenanceFee !== listing?.maintenanceFee) {
  changes.push(`Maintenance fee: $${listing?.maintenanceFee || 125} â†’ $${maintenanceFee}`);
}
// ... 7 more similar patterns
```

**Refactored Code:**
```javascript
const changeDescriptors = [
  [selectedRentalType !== originalLeaseStyle,
   `Lease style: ${originalLeaseStyle} â†’ ${selectedRentalType}`],
  [damageDeposit !== listing?.damageDeposit,
   `Damage deposit: $${listing?.damageDeposit || 500} â†’ $${damageDeposit}`],
  [maintenanceFee !== listing?.maintenanceFee,
   `Maintenance fee: $${listing?.maintenanceFee || 125} â†’ $${maintenanceFee}`],
  [nightsChanged,
   `Available nights updated (${selectedNights.length} nights)`],
  [minNights !== listing?.minNightsPerWeek || maxNights !== listing?.maxNightsPerWeek,
   `Nights range: ${minNights}-${maxNights}`],
  [ratesChanged,
   'Nightly rates updated'],
  [weeklyRate !== listing?.weeklyCompensation,
   `Weekly rate: $${weeklyRate}/week`],
  [weeksOffered !== listing?.weeksOffered,
   `Weekly pattern: ${patternLabels[weeksOffered] || weeksOffered}`],
  [monthlyRate !== listing?.monthlyCompensation,
   `Monthly rate: $${monthlyRate}/month`],
];

const changes = changeDescriptors
  .filter(([condition]) => condition)
  .map(([, description]) => description);
```

**Why This Matters:**
Table-driven change detection. All possible changes are visible in one place. Easy to add new tracked changes.

**Testing:**
- [ ] Verify change detection for each field
- [ ] Verify correct arrow notation in descriptions
- [ ] Verify empty array when no changes

---

## ðŸ”´ CHUNK 22: Replace .sort() in dayIndices calculation

**File:** app/src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx
**Line:** 408
**Violation:** MUTATING_METHOD - .sort() on mapped array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const dayIndices = selectedNights.map((n) => nightMap[n]).sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const dayIndices = selectedNights.map((n) => nightMap[n]).toSorted((a, b) => a - b);
```

**Why This Matters:**
`toSorted()` is the immutable alternative to `sort()`. While `.map()` already creates a new array, using `toSorted()` makes the intent explicit.

**Testing:**
- [ ] Verify day indices sorted correctly
- [ ] Verify original selectedNights array unchanged

---

# FILE: Section1SpaceSnapshot.tsx
**Path:** app/src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx

---

## ðŸ”´ CHUNK 23: Replace .push() pattern in errorOrder validation

**File:** app/src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx
**Lines:** 291-334
**Violation:** MUTATING_METHOD - 10 conditional .push() calls for error ordering
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const errorOrder: string[] = [];

if (!listingName?.trim()) {
  errorOrder.push('listingName');
}
if (listingName && listingName.length < 5) {
  errorOrder.push('listingName');
}
if (!typeOfSpace) {
  errorOrder.push('typeOfSpace');
}
// ... 7 more similar patterns
```

**Refactored Code:**
```javascript
const errorConditions = [
  [!listingName?.trim(), 'listingName'],
  [listingName && listingName.length < 5, 'listingName'],
  [!typeOfSpace, 'typeOfSpace'],
  [!bedrooms, 'bedrooms'],
  [!typeOfKitchen, 'typeOfKitchen'],
  [!typeOfParking, 'typeOfParking'],
  [!bathrooms, 'bathrooms'],
  [!fullAddress?.trim(), 'fullAddress'],
  [fullAddress && !isValidNYCAddress, 'fullAddress'],
  [!state, 'state'],
];

const errorOrder = errorConditions
  .filter(([condition]) => condition)
  .map(([, fieldName]) => fieldName);
```

**Why This Matters:**
Validation rules as data. The pattern matches other validation code in the codebase for consistency.

**Testing:**
- [ ] Verify all field validations detected
- [ ] Verify error order matches UI field order
- [ ] Verify duplicate field handling (listingName appears twice)

---

# FILE: Section5Rules.tsx
**Path:** app/src/islands/pages/SelfListingPage/sections/Section5Rules.tsx

---

## ðŸ”´ CHUNK 24: Replace while loop in getDateRange

**File:** app/src/islands/pages/SelfListingPage/sections/Section5Rules.tsx
**Lines:** 103-106
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - while loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const dates: Date[] = [];
while (current <= end) {
  dates.push(new Date(current));
  current.setDate(current.getDate() + 1);
}
```

**Refactored Code:**
```javascript
const dayCount = Math.ceil((end.getTime() - current.getTime()) / (1000 * 60 * 60 * 24)) + 1;
const dates = Array.from({ length: dayCount }, (_, i) => {
  const date = new Date(current);
  date.setDate(current.getDate() + i);
  return date;
});
```

**Why This Matters:**
Same pattern as AvailabilitySection.jsx chunk - consistency across codebase.

**Testing:**
- [ ] Verify date range generation
- [ ] Verify inclusive of start and end dates

---

## ðŸ”´ CHUNK 25: Replace for loops in calendar day generation

**File:** app/src/islands/pages/SelfListingPage/sections/Section5Rules.tsx
**Lines:** 141-147
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Two for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const days: (Date | null)[] = [];

// Padding for days before month starts
for (let i = 0; i < startingDayOfWeek; i++) {
  days.push(null);
}

// Add all days of the month
for (let d = 1; d <= daysInMonth; d++) {
  days.push(new Date(year, month, d));
}
```

**Refactored Code:**
```javascript
const paddingDays = Array.from({ length: startingDayOfWeek }, () => null);
const monthDays = Array.from({ length: daysInMonth }, (_, i) => new Date(year, month, i + 1));
const days: (Date | null)[] = [...paddingDays, ...monthDays];
```

**Why This Matters:**
Separates padding generation from date generation. Each can be tested independently.

**Testing:**
- [ ] Verify correct number of null padding days
- [ ] Verify all month days present
- [ ] Verify combined array structure

---

# FILE: NightlyPriceSlider.tsx
**Path:** app/src/islands/pages/SelfListingPage/components/NightlyPriceSlider.tsx

---

## ðŸ”´ CHUNK 26: Replace for loop in price generation

**File:** app/src/islands/pages/SelfListingPage/components/NightlyPriceSlider.tsx
**Lines:** 70-72
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop with .push() for price calculation
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const prices = [basePrice];
for (let i = 1; i < N; i++) {
  prices.push(roundUp(prices[i - 1] * decay));
}
```

**Refactored Code:**
```javascript
const prices = Array.from({ length: N }, (_, i) => {
  if (i === 0) return basePrice;
  // Need to calculate cumulatively since each price depends on previous
  let price = basePrice;
  for (let j = 1; j <= i; j++) {
    price = roundUp(price * decay);
  }
  return price;
});

// Alternative using reduce for truly functional approach:
const pricesAlt = Array.from({ length: N }).reduce<number[]>((acc, _, i) => {
  if (i === 0) return [basePrice];
  return [...acc, roundUp(acc[i - 1] * decay)];
}, []);
```

**Why This Matters:**
While this is a case where the imperative version is clearer due to the dependency chain, the functional alternative shows how to handle cumulative calculations. Consider which is more maintainable for your team.

**Testing:**
- [ ] Verify base price at index 0
- [ ] Verify decay applied correctly
- [ ] Verify roundUp applied to each subsequent price

---

# FILE: VirtualMeetingManager dateUtils.js
**Path:** app/src/islands/shared/VirtualMeetingManager/dateUtils.js

---

## ðŸ”´ CHUNK 27: Replace nested for loops in generateTimeSlots

**File:** app/src/islands/shared/VirtualMeetingManager/dateUtils.js
**Lines:** 71-75
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Nested for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (let hour = startHour; hour < endHour; hour++) {
  for (let minute = 0; minute < 60; minute += interval) {
    const slotTime = new Date(date);
    slotTime.setHours(hour, minute, 0, 0);
    slots.push(slotTime);
  }
}
```

**Refactored Code:**
```javascript
const hours = Array.from({ length: endHour - startHour }, (_, i) => startHour + i);
const minutes = Array.from({ length: Math.ceil(60 / interval) }, (_, i) => i * interval)
  .filter(m => m < 60);

const slots = hours.flatMap(hour =>
  minutes.map(minute => {
    const slotTime = new Date(date);
    slotTime.setHours(hour, minute, 0, 0);
    return slotTime;
  })
);
```

**Why This Matters:**
Same pattern as cohostService.js CHUNK 2 - consistency across similar functionality.

**Testing:**
- [ ] Verify time slots generation
- [ ] Verify custom intervals work correctly

---

## ðŸ”´ CHUNK 28: Replace for loops in getCalendarDays

**File:** app/src/islands/shared/VirtualMeetingManager/dateUtils.js
**Lines:** 95-101
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Two for loops with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const days = [];

for (let i = 0; i < startingDayOfWeek; i++) {
  days.push(null);
}

for (let day = 1; day <= daysInMonth; day++) {
  days.push(new Date(currentMonth.getFullYear(), currentMonth.getMonth(), day));
}
```

**Refactored Code:**
```javascript
const paddingDays = Array.from({ length: startingDayOfWeek }, () => null);
const monthDays = Array.from({ length: daysInMonth }, (_, i) =>
  new Date(currentMonth.getFullYear(), currentMonth.getMonth(), i + 1)
);
const days = [...paddingDays, ...monthDays];
```

**Why This Matters:**
Same pattern as Section5Rules.tsx CHUNK 25 - consistency across codebase.

**Testing:**
- [ ] Verify padding days
- [ ] Verify month days
- [ ] Verify combined array

---

# FILE: GoogleMap.jsx
**Path:** app/src/islands/shared/GoogleMap.jsx

---

## ðŸ”´ CHUNK 29: Replace .push() for markersRef mutation

**File:** app/src/islands/shared/GoogleMap.jsx
**Lines:** 643, 733
**Violation:** MUTATING_METHOD - .push() on React ref array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
markersRef.current.push(marker);
```

**Refactored Code:**
```javascript
markersRef.current = [...markersRef.current, marker];
```

**Why This Matters:**
While refs are inherently mutable in React, using spread creates a new array reference which can help with debugging and consistency. However, for performance-critical marker management, mutation may be acceptable - document the decision.

**Testing:**
- [ ] Verify markers added to map
- [ ] Verify markers array contains all markers
- [ ] Verify cleanup removes markers correctly

---

## ðŸ”´ CHUNK 30: Replace .push() for skippedInvalidCoordinates

**File:** app/src/islands/shared/GoogleMap.jsx
**Lines:** 612, 705
**Violation:** MUTATING_METHOD - .push() for debug logging array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
skippedInvalidCoordinates.push({
  listing: listing.Name || listing.id,
  lat: listing.lat,
  lng: listing.lng
});
```

**Refactored Code:**
```javascript
// Use functional accumulator pattern in the map/forEach
const { validListings, skippedCoordinates } = listings.reduce(
  (acc, listing) => {
    if (isValidCoordinate(listing)) {
      return { ...acc, validListings: [...acc.validListings, listing] };
    }
    return {
      ...acc,
      skippedCoordinates: [...acc.skippedCoordinates, {
        listing: listing.Name || listing.id,
        lat: listing.lat,
        lng: listing.lng
      }]
    };
  },
  { validListings: [], skippedCoordinates: [] }
);
```

**Why This Matters:**
Separates valid and invalid listings in a single pass. More testable than mutation-based filtering.

**Testing:**
- [ ] Verify valid coordinates processed
- [ ] Verify invalid coordinates logged
- [ ] Verify console warning for skipped items

---

# FILE: SearchScheduleSelector.jsx
**Path:** app/src/islands/shared/SearchScheduleSelector.jsx

---

## ðŸ”´ CHUNK 31: Replace .sort() with toSorted()

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Lines:** 319, 344, 546, 617
**Violation:** MUTATING_METHOD - Multiple .sort() calls on spread arrays
**Severity:** ðŸ”´ High

**Current Code (4 instances):**
```javascript
const sortedDays = [...daysArray].sort((a, b) => a - b);
const sortedUnselected = [...unselectedDays].sort((a, b) => a - b);
const sortedDays = [...selectedDaysArray].sort((a, b) => a - b);
const selectedDaysArray = Array.from(selectedDays).sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sortedDays = daysArray.toSorted((a, b) => a - b);
const sortedUnselected = unselectedDays.toSorted((a, b) => a - b);
const sortedDays = selectedDaysArray.toSorted((a, b) => a - b);
const selectedDaysArray = [...selectedDays].toSorted((a, b) => a - b);
```

**Why This Matters:**
`toSorted()` is the standard immutable sorting method. Clearer intent.

**Testing:**
- [ ] Verify day sorting works correctly
- [ ] Verify original arrays not mutated

---

## ðŸ”´ CHUNK 32: Replace .pop() with at(-1)

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Line:** 585
**Violation:** MUTATING_METHOD - .pop() to get last element
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
checkoutDayIndex = sortedDays.filter(day => day < gapStart).pop();
```

**Refactored Code:**
```javascript
checkoutDayIndex = sortedDays.filter(day => day < gapStart).at(-1);
```

**Why This Matters:**
`.pop()` mutates the array. `.at(-1)` returns the last element without mutation.

**Testing:**
- [ ] Verify correct checkout day returned
- [ ] Verify filtered array not mutated

---

## ðŸ”´ CHUNK 33: Replace for loops for gap detection

**File:** app/src/islands/shared/SearchScheduleSelector.jsx
**Lines:** 323, 345, 557
**Violation:** IMPERATIVE_LOOP - for loops for gap detection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (let i = 1; i < sortedDays.length; i++) {
  if (sortedDays[i] - sortedDays[i - 1] > 1) {
    hasGap = true;
    break;
  }
}
```

**Refactored Code:**
```javascript
const hasGap = sortedDays.some((day, i) =>
  i > 0 && day - sortedDays[i - 1] > 1
);
```

**Why This Matters:**
`.some()` is declarative - it says "check if any element matches this condition." The imperative loop hides this intent.

**Testing:**
- [ ] Verify gap detection for non-contiguous days
- [ ] Verify no gap for contiguous days
- [ ] Verify wrap-around handling

---

# FILE: CreateProposalFlowV2.jsx
**Path:** app/src/islands/shared/CreateProposalFlowV2.jsx

---

## ðŸ”´ CHUNK 34: Replace .sort() with toSorted()

**File:** app/src/islands/shared/CreateProposalFlowV2.jsx
**Line:** 257
**Violation:** MUTATING_METHOD - .sort() on spread array
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...dayObjs].sort((a, b) => a.dayOfWeek - b.dayOfWeek);
```

**Refactored Code:**
```javascript
const sorted = dayObjs.toSorted((a, b) => a.dayOfWeek - b.dayOfWeek);
```

**Why This Matters:**
`toSorted()` is the immutable alternative.

**Testing:**
- [ ] Verify days sorted by dayOfWeek
- [ ] Verify original array unchanged

---

## ðŸ”´ CHUNK 35: Replace for loop for gap detection

**File:** app/src/islands/shared/CreateProposalFlowV2.jsx
**Line:** 267
**Violation:** IMPERATIVE_LOOP - for loop for gap detection
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (let i = 0; i < dayNumbers.length - 1; i++) {
  // gap detection logic
}
```

**Refactored Code:**
```javascript
const hasGap = dayNumbers.slice(0, -1).some((day, i) =>
  dayNumbers[i + 1] - day > 1
);
```

**Why This Matters:**
`.some()` replaces the loop with declarative intent.

**Testing:**
- [ ] Verify gap detection works
- [ ] Verify edge cases handled

---

# FILE: FAQPage.jsx
**Path:** app/src/islands/pages/FAQPage.jsx

---

## ðŸ”´ CHUNK 36: Replace for-of loop with reduce for FAQ grouping

**File:** app/src/islands/pages/FAQPage.jsx
**Lines:** 77-80
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for-of loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (const [tabName, dbCategory] of Object.entries(categoryMapping)) {
  if (faq.Category === dbCategory) {
    grouped[tabName].push(faq);
  }
}
```

**Refactored Code:**
```javascript
const grouped = faqs.reduce((acc, faq) => {
  const tabEntry = Object.entries(categoryMapping).find(
    ([, dbCategory]) => faq.Category === dbCategory
  );
  if (tabEntry) {
    const [tabName] = tabEntry;
    return {
      ...acc,
      [tabName]: [...(acc[tabName] || []), faq]
    };
  }
  return acc;
}, initialGrouped);
```

**Why This Matters:**
`reduce` is the functional way to accumulate grouped data. Each iteration returns a new object rather than mutating.

**Testing:**
- [ ] Verify FAQs grouped by category
- [ ] Verify all tabs populated
- [ ] Verify uncategorized FAQs handled

---

# FILE: ExternalReviews.jsx
**Path:** app/src/islands/shared/ExternalReviews.jsx

---

## ðŸ”´ CHUNK 37: Replace .push() in reduce accumulator

**File:** app/src/islands/shared/ExternalReviews.jsx
**Line:** 60
**Violation:** MUTATING_METHOD - .push() inside reduce
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
reviews.reduce((acc, review) => {
  acc[review.platform].push(review);
  return acc;
}, initialAcc);
```

**Refactored Code:**
```javascript
reviews.reduce((acc, review) => ({
  ...acc,
  [review.platform]: [...acc[review.platform], review]
}), initialAcc);
```

**Why This Matters:**
Immutable reduce - each iteration creates a new accumulator object. Essential for predictable state management.

**Testing:**
- [ ] Verify reviews grouped by platform
- [ ] Verify original array unchanged

---

# FILE: AiSignupMarketReport.jsx
**Path:** app/src/islands/shared/AiSignupMarketReport/AiSignupMarketReport.jsx

---

## ðŸ”´ CHUNK 38: Replace for-of loops with .find() for pattern matching

**File:** app/src/islands/shared/AiSignupMarketReport/AiSignupMarketReport.jsx
**Lines:** 47, 111, 123
**Violation:** IMPERATIVE_LOOP - for-of loops for pattern matching
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (const pattern of namePatterns) {
  const match = text.match(pattern);
  if (match) {
    return match[1].trim();
  }
}
return null;
```

**Refactored Code:**
```javascript
const matchingPattern = namePatterns
  .map(pattern => text.match(pattern))
  .find(Boolean);

return matchingPattern ? matchingPattern[1].trim() : null;
```

**Why This Matters:**
`map` + `find` is declarative. Shows intent to find first matching pattern.

**Testing:**
- [ ] Verify pattern matching works
- [ ] Verify returns null when no match
- [ ] Verify first match takes precedence

---

## ðŸ”´ CHUNK 39: Replace for-of loop with filter for topic detection

**File:** app/src/islands/shared/AiSignupMarketReport/AiSignupMarketReport.jsx
**Lines:** 680-684
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for-of loop with .push()
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
for (const topic of FREEFORM_TOPICS) {
  if (matchesTopic(text, topic)) {
    detectedTopics.push(topic.id);
  }
}
```

**Refactored Code:**
```javascript
const detectedTopics = FREEFORM_TOPICS
  .filter(topic => matchesTopic(text, topic))
  .map(topic => topic.id);
```

**Why This Matters:**
`filter` + `map` chain clearly shows: filter matching topics, then extract IDs.

**Testing:**
- [ ] Verify topic detection
- [ ] Verify correct IDs extracted

---

# FILE: DaysSelectionSection.jsx
**Path:** app/src/islands/shared/CreateProposalFlowV2Components/DaysSelectionSection.jsx

---

## ðŸ”´ CHUNK 40: Replace .sort() with toSorted() and for loop with .some()

**File:** app/src/islands/shared/CreateProposalFlowV2Components/DaysSelectionSection.jsx
**Lines:** 63, 72
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...dayNumbers].sort((a, b) => a - b);
// ...
for (let i = 0; i < sorted.length - 1; i++) {
  if (sorted[i + 1] - sorted[i] > 1) {
    hasGap = true;
    break;
  }
}
```

**Refactored Code:**
```javascript
const sorted = dayNumbers.toSorted((a, b) => a - b);
// ...
const hasGap = sorted.slice(0, -1).some((day, i) => sorted[i + 1] - day > 1);
```

**Why This Matters:**
Consistent with other gap detection patterns in codebase.

**Testing:**
- [ ] Verify sorting
- [ ] Verify gap detection

---

# FILE: ViewSplitLeasePage.jsx (old and new)
**Path:** app/src/islands/pages/ViewSplitLeasePage.jsx and ViewSplitLeasePage-old.jsx

---

## ðŸ”´ CHUNK 41: Replace .push() in features array building

**File:** app/src/islands/pages/ViewSplitLeasePage-old.jsx
**Lines:** 250-266
**Violation:** MUTATING_METHOD - Multiple conditional .push() for features
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const features = [];
if (listing['Kitchen Type']) {
  features.push({ icon: 'chef-hat', text: listing['Kitchen Type'] });
}
if (bathrooms) {
  features.push({ icon: 'bath', text: `${count} ${text}` });
}
// ... more similar patterns
```

**Refactored Code:**
```javascript
const features = [
  listing['Kitchen Type'] && { icon: 'chef-hat', text: listing['Kitchen Type'] },
  bathrooms && { icon: 'bath', text: `${count} ${text}` },
  listing.resolvedTypeOfSpace && { icon: 'home', text: listing.resolvedTypeOfSpace },
  bedrooms && { icon: 'bed-double', text: `${count} ${text}` },
].filter(Boolean);
```

**Why This Matters:**
All features defined in single array literal. Easy to see all possible features.

**Testing:**
- [ ] Verify features array built correctly
- [ ] Verify conditional features included/excluded

---

## ðŸ”´ CHUNK 42: Replace .sort() with toSorted() for photos and days

**File:** app/src/islands/pages/ViewSplitLeasePage.jsx
**Lines:** 798, 1256
**File:** app/src/islands/pages/ViewSplitLeasePage-old.jsx
**Lines:** 1170, 1207
**Violation:** MUTATING_METHOD - .sort() on spread arrays
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sortedDays = [...selectedDayNumbers].sort((a, b) => a - b);
const sortedPhotos = (photosData || []).sort((a, b) => {...});
return [...prev, dayIndex].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sortedDays = selectedDayNumbers.toSorted((a, b) => a - b);
const sortedPhotos = [...(photosData || [])].toSorted((a, b) => {...});
return [...prev, dayIndex].toSorted((a, b) => a - b);
```

**Why This Matters:**
`toSorted()` is the standard immutable sort.

**Testing:**
- [ ] Verify sorting works
- [ ] Verify original arrays unchanged

---

# FILE: HostProposalsPage types.js
**Path:** app/src/islands/pages/HostProposalsPage/types.js

---

## ðŸ”´ CHUNK 43: Replace while loop and .push() in getActiveDays

**File:** app/src/islands/pages/HostProposalsPage/types.js
**Lines:** 253-255
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
while (current !== checkOutIndex) {
  activeDays.push(dayNames[current]);
  current = (current + 1) % 7;
}
```

**Refactored Code:**
```javascript
const getActiveDaysFromRange = (checkInIndex, checkOutIndex) => {
  const count = checkOutIndex >= checkInIndex
    ? checkOutIndex - checkInIndex
    : 7 - checkInIndex + checkOutIndex;

  return Array.from({ length: count }, (_, i) =>
    dayNames[(checkInIndex + i) % 7]
  );
};

const activeDays = getActiveDaysFromRange(current, checkOutIndex);
```

**Why This Matters:**
Declarative day range generation. The while loop with modulo is error-prone; the functional version clearly shows the wrap-around logic.

**Testing:**
- [ ] Verify day range calculation
- [ ] Verify wrap-around (Sat to Mon)

---

## ðŸ”´ CHUNK 44: Replace .sort() with toSorted() and for loop with reduce

**File:** app/src/islands/pages/HostProposalsPage/types.js
**Lines:** 342, 351, 411, 423
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP
**Severity:** ðŸ”´ High

**Current Code:**
```javascript
const sorted = [...dayIndices].sort((a, b) => a - b);
// ...
for (let i = 1; i < sorted.length; i++) {
  // contiguity checking
}
```

**Refactored Code:**
```javascript
const sorted = dayIndices.toSorted((a, b) => a - b);
// ...
const isContiguous = sorted.slice(1).every((day, i) => day - sorted[i] === 1);
```

**Why This Matters:**
`.every()` is declarative - checks if all adjacent pairs are contiguous.

**Testing:**
- [ ] Verify contiguity detection
- [ ] Verify non-contiguous detection

---

# REMAINING CHUNKS (Summary)

Due to the extensive number of violations, here are the remaining files with similar patterns to apply:

---

## Files with .push() â†’ filter(Boolean) pattern:

| File | Lines | Description |
|------|-------|-------------|
| Section2Features.tsx | 207, 212 | Error order validation |
| Section3LeaseStyles.tsx | 132, 137 | Error order validation |
| Section4Pricing.tsx | 50, 55, 60, 67 | Error order validation |
| Section6Photos.tsx | 266 | Error order validation |
| ScheduleCohost.jsx | 709-713 | CSS class building |
| BookTimeSlot.jsx | 155, 159 | CSS class building |
| SimpleHostScheduleSelector.jsx | 145, 149 | CSS class building |
| ScheduleSelector.jsx | 119-121 | CSS class building |
| MapView.jsx | 83, 126 | Bounds and markers |
| SplitScheduleSelector.jsx | 49-55, 77 | Day calculation |

---

## Files with .sort() â†’ toSorted() pattern:

| File | Lines |
|------|-------|
| ListingsCard.jsx | 18 |
| ScheduleCommuteCard.jsx | 38 |
| useHostProposalsPageLogic.js | 266 |
| ProposalCard.jsx | 121 |

---

## Files with for loop â†’ Array.from/map/filter pattern:

| File | Lines | Description |
|------|-------|-------------|
| ListWithUsPage.jsx | 27-28 | Price generation |
| SelfListingPageV2.tsx | 518-526 | Price generation |
| RentalApplicationFieldMapper.ts | 401-403 | Step completion |
| NightlyPricingLegend.jsx | 26-27 | Nights range |
| PreviewSplitLeasePage.jsx | 841 | Object.entries loop |
| ListingDashboardPage | 920, 1295, 1338 | Updates loop |
| virtualMeetingService.js | 312 | Retry loop (acceptable) |

---

## Files with special consideration:

### Retry loops (KEEP AS-IS)
**File:** virtualMeetingService.js:312
Retry loops with `break` on success are acceptable imperative patterns. The intent (retry N times) is clear.

### React refs (DOCUMENT DECISION)
**Files:** GoogleMap.jsx, FullscreenProposalMapModal.jsx
Marker ref mutations are performance-sensitive. Document that mutation is intentional for performance.

---

## Implementation Priority

### Phase 1: High-Impact Files (12 files, ~50 chunks)
1. LoggedInAvatar.jsx - Menu item generation
2. listingLocalStore.ts - Validation patterns
3. prepareListingSubmission.ts - Validation patterns
4. HostScheduleSelector.jsx - CSS class patterns
5. SearchPage.jsx - Day sorting/gap detection
6. cohostService.js - Calendar/slot generation

### Phase 2: Validation Sections (6 files, ~25 chunks)
1. Section1SpaceSnapshot.tsx
2. Section2Features.tsx
3. Section3LeaseStyles.tsx
4. Section4Pricing.tsx
5. Section5Rules.tsx
6. Section6Photos.tsx

### Phase 3: Shared Components (8 files, ~20 chunks)
1. SearchScheduleSelector.jsx
2. CreateProposalFlowV2.jsx
3. DaysSelectionSection.jsx
4. FAQPage.jsx
5. ExternalReviews.jsx
6. AiSignupMarketReport.jsx
7. formatters.js
8. AvailabilitySection.jsx

### Phase 4: Page-Specific (6 files, ~15 chunks)
1. ViewSplitLeasePage.jsx
2. ViewSplitLeasePage-old.jsx
3. HostProposalsPage/types.js
4. useHostProposalsPageLogic.js
5. FavoriteListingsPage.jsx
6. ProposalCard.jsx

---

## Key References

- **FP Guide:** .claude/skills/functional-code/skill.md
- **FP Bible:** .claude/Documentation/Architecture/The Functional Programming Bible.md
- **Violations JSON:** agents/fp_audit_violations.json

---

## Estimated Effort

- **Total Chunks:** ~110 discrete fixes
- **Average Time per Chunk:** 5-10 minutes
- **Total Estimated Time:** 9-18 hours
- **Recommended Approach:** Tackle by file, test after each file completion

---

*Generated by FP Audit Analysis - 2026-01-10*
