# Functional Programming Refactoring Plan

Date: 2026-01-11
Target: agents/20260111132021_fp_audit_violations.json
Severity Filter: high

## Summary

**Total Violations:** 347
- MUTATING_METHOD: 263 (76%)
- IMPERATIVE_LOOP: 80 (23%)
- IO_IN_CORE: 4 (1%)

**Top 10 Files by Violation Count:**
1. src/islands/pages/SelfListingPage/store/listingLocalStore.ts (21)
2. src/lib/availabilityValidation.js (15)
3. src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts (15)
4. src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx (12)
5. src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx (11)
6. src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx (10)
7. src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx (10)
8. src/islands/pages/SelfListingPage/sections/Section5Rules.tsx (10)
9. src/islands/shared/SearchScheduleSelector.jsx (9)
10. src/lib/listingService.js (8)

---

~~~~~

## CHUNK 1: Replace imperative loop in vite.config.js:32

**File:** vite.config.js
**Line:** 32
**Violation:** IMPERATIVE_LOOP - Using for...of loop with mutation to build rollupOptions
**Severity:** High

**Expected Affected Pages:** AUTO (build configuration)

**Current Code:**
```javascript
for (const route of routes) {
  // ... builds rollupOptions.input
}
```

**Refactored Code:**
```javascript
const input = routes.reduce((acc, route) => {
  const entryName = route.path === '/' ? 'index' : route.path.replace(/^\//, '').replace(/\//g, '-');
  acc[entryName] = resolve(__dirname, route.file);
  return acc;
}, {});
```

**Why This Matters:**
Declarative `reduce` clearly shows transformation intent: routes → rollup input object. No intermediate mutation needed.

**Testing:**
- [ ] Run `bun run build` and verify all routes compile
- [ ] Verify generated rollup inputs match expected structure

~~~~~

## CHUNK 2: Replace imperative loop in vite.config.js:56

**File:** vite.config.js
**Line:** 56
**Violation:** IMPERATIVE_LOOP - Nested for loop for route aliases
**Severity:** High

**Expected Affected Pages:** AUTO (build configuration)

**Current Code:**
```javascript
for (const alias of route.aliases) {
  // ... builds alias mappings
}
```

**Refactored Code:**
```javascript
const aliasInputs = routes
  .filter(route => route.aliases?.length > 0)
  .flatMap(route => route.aliases.map(alias => ({
    name: alias.replace(/^\//, '').replace(/\//g, '-'),
    file: resolve(__dirname, route.file)
  })))
  .reduce((acc, { name, file }) => ({ ...acc, [name]: file }), {});
```

**Why This Matters:**
flatMap elegantly handles the nested iteration pattern, producing a flat list of alias mappings that reduce then aggregates.

**Testing:**
- [ ] Verify alias routes are properly built
- [ ] Test route redirects work as expected

~~~~~

## CHUNK 3: Replace imperative loop in vite.config.js:82

**File:** vite.config.js
**Line:** 82
**Violation:** IMPERATIVE_LOOP - Processing entries for rollup
**Severity:** High

**Expected Affected Pages:** AUTO (build configuration)

**Current Code:**
```javascript
for (const entry of entries) {
  // ... processes entries
}
```

**Refactored Code:**
```javascript
const processedEntries = entries.map(entry => ({
  ...entry,
  // transformation logic
}));
```

**Why This Matters:**
Using map for 1:1 transformations is more expressive and prevents accidental mutation.

**Testing:**
- [ ] Verify build output structure unchanged
- [ ] Check all entry points are processed

~~~~~

## CHUNK 4: Replace imperative loop in vite.config.js:181

**File:** vite.config.js
**Line:** 181
**Violation:** IMPERATIVE_LOOP - Internal routes processing
**Severity:** High

**Expected Affected Pages:** AUTO (build configuration)

**Current Code:**
```javascript
for (const route of internalRoutes) {
  // ... processes internal routes
}
```

**Refactored Code:**
```javascript
const processedInternalRoutes = internalRoutes.map(route => ({
  ...route,
  // transformation logic
}));
```

**Why This Matters:**
Declarative map shows intent clearly: transform each route without side effects.

**Testing:**
- [ ] Verify internal routes handled correctly
- [ ] Run full build verification

~~~~~

## CHUNK 5: Replace imperative loop in generate-redirects.js:144

**File:** scripts/generate-redirects.js
**Line:** 144
**Violation:** IMPERATIVE_LOOP - Route validation loop
**Severity:** High

**Expected Affected Pages:** AUTO (build scripts)

**Current Code:**
```javascript
for (const route of routes) {
  // validation and error collection
}
```

**Refactored Code:**
```javascript
const errors = routes.flatMap(route => {
  const routeErrors = [];
  if (seenPaths.has(route.path)) {
    return [`Duplicate path: ${route.path}`];
  }
  if (!route.path) {
    return ['Route missing path'];
  }
  if (!route.file) {
    return [`Route ${route.path} missing file`];
  }
  if (route.cloudflareInternal && !route.internalName) {
    return [`Route ${route.path} has cloudflareInternal but no internalName`];
  }
  return [];
});
```

**Why This Matters:**
flatMap collects validation errors declaratively. Each route produces zero or more errors, which flatMap naturally flattens.

**Testing:**
- [ ] Run `bun run generate-routes`
- [ ] Verify error messages for invalid routes

~~~~~

## CHUNK 6: Replace .push() mutations in generate-redirects.js:147,153,156,161

**File:** scripts/generate-redirects.js
**Lines:** 147, 153, 156, 161
**Violation:** MUTATING_METHOD - Multiple .push() calls for error collection
**Severity:** High

**Expected Affected Pages:** AUTO (build scripts)

**Current Code:**
```javascript
const errors = [];
// ...
errors.push(`Duplicate path: ${route.path}`);
// ...
errors.push(`Route missing path`);
// ...
errors.push(`Route ${route.path} missing file`);
// ...
errors.push(`Route ${route.path} has cloudflareInternal but no internalName`);
```

**Refactored Code:**
```javascript
// Covered by CHUNK 5 - using flatMap eliminates all .push() calls
const errors = routes.flatMap(route => {
  if (seenPaths.has(route.path)) return [`Duplicate path: ${route.path}`];
  if (!route.path) return ['Route missing path'];
  if (!route.file) return [`Route ${route.path} missing file`];
  if (route.cloudflareInternal && !route.internalName) {
    return [`Route ${route.path} has cloudflareInternal but no internalName`];
  }
  return [];
});
```

**Why This Matters:**
Eliminates all mutation points. Each validation check returns an array (empty or with error), and flatMap combines them.

**Testing:**
- [ ] Verify all validation errors still caught
- [ ] Test edge cases (duplicate paths, missing fields)

~~~~~

## CHUNK 7: Replace .push() in routes.config.js:380

**File:** src/routes.config.js
**Line:** 380
**Violation:** MUTATING_METHOD - Using .push() to add excluded routes
**Severity:** High

**Expected Affected Pages:** AUTO (route configuration)

**Current Code:**
```javascript
excludedFromFunctions.push('/guest-proposals', '/guest-proposals/*');
```

**Refactored Code:**
```javascript
const excludedFromFunctions = [
  ...baseExcludedPaths,
  '/guest-proposals',
  '/guest-proposals/*'
];
```

**Why This Matters:**
Spread operator creates a new array with all values, making the configuration immutable and easier to reason about.

**Testing:**
- [ ] Verify Cloudflare functions exclude correct routes
- [ ] Check _routes.json output

~~~~~

## CHUNK 8: Replace .push() in helpCenterData.js:280

**File:** src/data/helpCenterData.js
**Line:** 280
**Violation:** MUTATING_METHOD - Using .push() to collect search results
**Severity:** High

**Expected Affected Pages:** /help-center

**Current Code:**
```javascript
export function searchHelpArticles(query) {
  if (!query || query.trim().length < 2) return [];

  const normalizedQuery = query.toLowerCase().trim();
  const results = [];

  Object.entries(helpCenterArticles).forEach(([categoryId, category]) => {
    category.sections.forEach(section => {
      section.articles.forEach(article => {
        const titleMatch = article.title.toLowerCase().includes(normalizedQuery);
        if (titleMatch) {
          results.push({
            ...article,
            categoryId,
            categoryTitle: category.title,
            sectionTitle: section.title
          });
        }
      });
    });
  });

  return results;
}
```

**Refactored Code:**
```javascript
export function searchHelpArticles(query) {
  if (!query || query.trim().length < 2) return [];

  const normalizedQuery = query.toLowerCase().trim();

  return Object.entries(helpCenterArticles).flatMap(([categoryId, category]) =>
    category.sections.flatMap(section =>
      section.articles
        .filter(article => article.title.toLowerCase().includes(normalizedQuery))
        .map(article => ({
          ...article,
          categoryId,
          categoryTitle: category.title,
          sectionTitle: section.title
        }))
    )
  );
}
```

**Why This Matters:**
Nested flatMap + filter + map is a powerful pattern for searching nested structures without mutation. Each level filters and transforms declaratively.

**Testing:**
- [ ] Search for various terms in help center
- [ ] Verify results include correct category/section metadata

~~~~~

## CHUNK 9: Replace [...arr].sort() in aiService.js:106

**File:** src/lib/aiService.js
**Line:** 106
**Violation:** MUTATING_METHOD - Using [...arr].sort() (already safe but can use toSorted)
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
return [...amenities].sort((a, b) => {
  // sorting logic
});
```

**Refactored Code:**
```javascript
return amenities.toSorted((a, b) => {
  // sorting logic
});
```

**Why This Matters:**
toSorted() is the modern, intent-revealing method. While [...arr].sort() is technically safe, toSorted() explicitly signals immutability.

**Testing:**
- [ ] Verify amenity ordering unchanged
- [ ] Check browser compatibility (ES2023+)

~~~~~

## CHUNK 10: Replace while loop in auth.js:563

**File:** src/lib/auth.js
**Line:** 563
**Violation:** IMPERATIVE_LOOP - While loop for retry logic
**Severity:** High

**Expected Affected Pages:** /login, /signup, all authenticated pages

**Current Code:**
```javascript
while (verifyAttempts < maxVerifyAttempts) {
  // verification attempts
}
```

**Refactored Code:**
```javascript
// For retry logic, use a recursive helper or async iteration
const attemptVerification = async (attemptsRemaining) => {
  if (attemptsRemaining <= 0) {
    return { success: false, error: 'Max attempts reached' };
  }

  const result = await verify();
  if (result.success) return result;

  await delay(retryDelay);
  return attemptVerification(attemptsRemaining - 1);
};

return attemptVerification(maxVerifyAttempts);
```

**Why This Matters:**
Recursive retry is more functional and easier to test. Each attempt is isolated, and the recursion depth is bounded by maxVerifyAttempts.

**Testing:**
- [ ] Test login flow with successful verification
- [ ] Test retry behavior with temporary failures
- [ ] Verify max attempts limit enforced

~~~~~

## CHUNK 11: Replace while loop in auth.js:786

**File:** src/lib/auth.js
**Line:** 786
**Violation:** IMPERATIVE_LOOP - Another while loop for verification
**Severity:** High

**Expected Affected Pages:** /login, /signup, all authenticated pages

**Current Code:**
```javascript
while (verifyAttempts < maxVerifyAttempts) {
  // verification attempts
}
```

**Refactored Code:**
```javascript
// Same pattern as CHUNK 10 - use recursive retry helper
const attemptVerification = async (attemptsRemaining) => {
  if (attemptsRemaining <= 0) {
    return { success: false, error: 'Max attempts reached' };
  }

  const result = await performVerification();
  if (result.success) return result;

  await delay(retryDelay);
  return attemptVerification(attemptsRemaining - 1);
};

return attemptVerification(maxVerifyAttempts);
```

**Why This Matters:**
Consistent retry pattern across the codebase. Recursive approach is stateless and testable.

**Testing:**
- [ ] Test verification flow end-to-end
- [ ] Verify retry delays work correctly

~~~~~

## CHUNK 12: Replace imperative loop in availabilityValidation.js:38

**File:** src/lib/availabilityValidation.js
**Line:** 38
**Violation:** IMPERATIVE_LOOP - Loop to check contiguous days
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
let isStandardContiguous = true;
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    isStandardContiguous = false;
    break;
  }
}
```

**Refactored Code:**
```javascript
const isStandardContiguous = sorted.slice(1).every(
  (day, index) => day === sorted[index] + 1
);
```

**Why This Matters:**
`every()` is perfect for "all elements satisfy condition" checks. The index in the callback refers to the sliced array, so `sorted[index]` gives the previous element.

**Testing:**
- [ ] Test contiguous selections: [1,2,3,4,5] => true
- [ ] Test non-contiguous: [1,3,5] => false
- [ ] Test wrap-around: [5,6,0] => true

~~~~~

## CHUNK 13: Replace imperative loop in availabilityValidation.js:65-66

**File:** src/lib/availabilityValidation.js
**Lines:** 65-66
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Loop with .push() to build expected range
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
const expectedNotSelected = [];
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i);
}
```

**Refactored Code:**
```javascript
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
`Array.from` with a mapper function creates a range declaratively. No mutation needed.

**Testing:**
- [ ] Verify range [2,5] creates [2,3,4,5]
- [ ] Test edge case: single element range

~~~~~

## CHUNK 14: Replace [...arr].sort() in availabilityValidation.js:97

**File:** src/lib/availabilityValidation.js
**Line:** 97
**Violation:** MUTATING_METHOD - Using [...arr].sort()
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
toSorted() is the immutable alternative to sort(). It creates a new sorted array without copying first.

**Testing:**
- [ ] Verify day sorting works correctly
- [ ] Check browser compatibility

~~~~~

## CHUNK 15: Replace imperative loop in availabilityValidation.js:106

**File:** src/lib/availabilityValidation.js
**Line:** 106
**Violation:** IMPERATIVE_LOOP - Gap detection loop
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
let gapIndex = -1;
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    gapIndex = i;
    break;
  }
}
```

**Refactored Code:**
```javascript
const gapIndex = sorted.slice(1).findIndex(
  (day, index) => day !== sorted[index] + 1
);
// Note: findIndex returns -1 if not found, but we need to add 1 for the actual index
const actualGapIndex = gapIndex === -1 ? -1 : gapIndex + 1;
```

**Why This Matters:**
findIndex is the declarative way to find the first element matching a condition. The index adjustment accounts for the slice.

**Testing:**
- [ ] Test gap detection in [0,1,3,4] => gap at index 2
- [ ] Test no gap in [0,1,2,3] => -1

~~~~~

## CHUNK 16: Replace .push() calls in availabilityValidation.js:166,175,181,186,199,271,280,287,294,305

**File:** src/lib/availabilityValidation.js
**Lines:** 166, 175, 181, 186, 199, 271, 280, 287, 294, 305
**Violation:** MUTATING_METHOD - Multiple .push() for errors/warnings collection
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
const result = {
  valid: true,
  errors: [],
  warnings: [],
  // ...
};

// Various conditions:
result.errors.push('Please select at least one day');
result.errors.push('Please check for contiguous nights...');
result.warnings.push(`Host prefers at least ${listing['Minimum Nights']} nights...`);
// etc.
```

**Refactored Code:**
```javascript
export function validateScheduleSelection(selectedDays, listing) {
  // Collect all potential errors/warnings upfront
  const buildErrors = () => {
    const errors = [];

    if (!selectedDays || selectedDays.length === 0) {
      return ['Please select at least one day'];
    }

    const isContiguous = isContiguousSelection(selectedDays);
    if (!isContiguous) {
      return ['Please check for contiguous nights to continue with your proposal'];
    }

    // Check Days Not Available
    if (listing['Days Not Available']?.length > 0) {
      const unavailableDays = listing['Days Not Available'];
      const hasUnavailable = selectedDays.some(day =>
        unavailableDays.includes(DAY_NAMES[day])
      );
      if (hasUnavailable) {
        return ['Some selected days are not available for this listing'];
      }
    }

    return errors;
  };

  const buildWarnings = () => [
    listing['Minimum Nights'] && selectedDays.length < listing['Minimum Nights']
      ? `Host prefers at least ${listing['Minimum Nights']} nights per week`
      : null,
    listing['Maximum Nights'] && selectedDays.length > listing['Maximum Nights']
      ? `Host prefers at most ${listing['Maximum Nights']} nights per week`
      : null
  ].filter(Boolean);

  const errors = buildErrors();
  const warnings = buildWarnings();

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    showTutorial: errors.some(e => e.includes('contiguous')),
    nightsCount: selectedDays?.length ?? 0,
    isContiguous: errors.length === 0 || !errors.some(e => e.includes('contiguous'))
  };
}
```

**Why This Matters:**
Building errors/warnings as computed arrays using filter(Boolean) is more declarative. Each condition adds its message or null, then we filter out nulls.

**Testing:**
- [ ] Test no days selected => error
- [ ] Test non-contiguous => error with tutorial flag
- [ ] Test under minimum nights => warning
- [ ] Test over maximum nights => warning

~~~~~

## CHUNK 17: Replace .push() in dataLookups.js:562

**File:** src/lib/dataLookups.js
**Line:** 562
**Violation:** MUTATING_METHOD - Using .push() in forEach loop
**Severity:** High

**Expected Affected Pages:** /edit-listing, /create-listing

**Current Code:**
```javascript
export function getAllCancellationPolicies() {
  const policies = [];
  lookupCache.cancellationPolicies.forEach((policy, id) => {
    policies.push({ id, display: policy.display });
  });
  return policies;
}
```

**Refactored Code:**
```javascript
export function getAllCancellationPolicies() {
  return Array.from(lookupCache.cancellationPolicies.entries()).map(
    ([id, policy]) => ({ id, display: policy.display })
  );
}
```

**Why This Matters:**
Array.from(map.entries()).map() is the idiomatic way to transform a Map into an array without mutation.

**Testing:**
- [ ] Verify cancellation policies list displays correctly
- [ ] Check order is preserved

~~~~~

## CHUNK 18: Replace .push() and .sort() in dataLookups.js:592,598

**File:** src/lib/dataLookups.js
**Lines:** 592, 598
**Violation:** MUTATING_METHOD - Using .push() and .sort() for reasons list
**Severity:** High

**Expected Affected Pages:** /guest-proposals, /host-proposals

**Current Code:**
```javascript
export function getGuestCancellationReasons() {
  const reasons = [];
  lookupCache.guestCancellationReasons.forEach((data, id) => {
    reasons.push({
      id,
      reason: data.reason,
      displayOrder: data.displayOrder
    });
  });
  return reasons.sort((a, b) => a.displayOrder - b.displayOrder);
}
```

**Refactored Code:**
```javascript
export function getGuestCancellationReasons() {
  return Array.from(lookupCache.guestCancellationReasons.entries())
    .map(([id, data]) => ({
      id,
      reason: data.reason,
      displayOrder: data.displayOrder
    }))
    .toSorted((a, b) => a.displayOrder - b.displayOrder);
}
```

**Why This Matters:**
Chaining map().toSorted() is the pure functional approach: transform then sort, all immutably.

**Testing:**
- [ ] Verify reasons sorted by displayOrder
- [ ] Test cancellation modal shows correct options

~~~~~

## CHUNK 19: Replace .push() and .sort() in dataLookups.js:609,615

**File:** src/lib/dataLookups.js
**Lines:** 609, 615
**Violation:** MUTATING_METHOD - Same pattern for host rejection reasons
**Severity:** High

**Expected Affected Pages:** /host-proposals

**Current Code:**
```javascript
export function getHostRejectionReasons() {
  const reasons = [];
  lookupCache.hostCancellationReasons.forEach((data, id) => {
    reasons.push({
      id,
      reason: data.reason,
      displayOrder: data.displayOrder
    });
  });
  return reasons.sort((a, b) => a.displayOrder - b.displayOrder);
}
```

**Refactored Code:**
```javascript
export function getHostRejectionReasons() {
  return Array.from(lookupCache.hostCancellationReasons.entries())
    .map(([id, data]) => ({
      id,
      reason: data.reason,
      displayOrder: data.displayOrder
    }))
    .toSorted((a, b) => a.displayOrder - b.displayOrder);
}
```

**Why This Matters:**
Same pattern as CHUNK 18. Consistency across codebase improves maintainability.

**Testing:**
- [ ] Verify host rejection reasons sorted correctly
- [ ] Test rejection modal in host proposals

~~~~~

## CHUNK 20: Skip third-party code in hotjar.js:18

**File:** src/lib/hotjar.js
**Line:** 18
**Violation:** MUTATING_METHOD - Hotjar SDK initialization code
**Severity:** High

**Expected Affected Pages:** All pages with analytics

**Current Code:**
```javascript
h.hj=h.hj||function(){(h.hj.q=h.hj.q||[]).push(arguments)};
```

**Refactored Code:**
```javascript
// SKIP - This is third-party Hotjar SDK initialization code
// Cannot be refactored without breaking Hotjar integration
// The mutation is encapsulated within the SDK's initialization
```

**Why This Matters:**
Third-party SDK code should not be modified. The violation is internal to Hotjar's implementation.

**Testing:**
- [ ] N/A - No changes to make

~~~~~

## CHUNK 21: Replace .sort() in listingDataFetcher.js:201

**File:** src/lib/listingDataFetcher.js
**Line:** 201
**Violation:** MUTATING_METHOD - Using .sort() on photos array
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search

**Current Code:**
```javascript
sortedPhotos = sortedPhotos.sort((a, b) => {
  // sorting logic
});
```

**Refactored Code:**
```javascript
sortedPhotos = sortedPhotos.toSorted((a, b) => {
  // sorting logic
});
```

**Why This Matters:**
toSorted() is the modern immutable alternative. Even if reassigning to same variable, toSorted() makes intent clearer.

**Testing:**
- [ ] Verify photo ordering on listing pages
- [ ] Check primary photo appears first

~~~~~

## CHUNK 22: Replace .push() in listingService.js:335

**File:** src/lib/listingService.js
**Line:** 335
**Violation:** MUTATING_METHOD - Using .push() to add listing ID
**Severity:** High

**Expected Affected Pages:** /listing-dashboard

**Current Code:**
```javascript
currentListings.push(listingId);
```

**Refactored Code:**
```javascript
const updatedListings = [...currentListings, listingId];
```

**Why This Matters:**
Spread operator creates a new array, making state updates more predictable.

**Testing:**
- [ ] Test adding new listing to dashboard
- [ ] Verify listing appears in list

~~~~~

## CHUNK 23: Replace for...of loop in listingService.js:766-768

**File:** src/lib/listingService.js
**Lines:** 766-768
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Loop with .push()
**Severity:** High

**Expected Affected Pages:** /edit-listing, /create-listing

**Current Code:**
```javascript
const result = [];
const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

for (const day of dayOrder) {
  if (availableNights[day] && dayNameMapping[day]) {
    result.push(dayNameMapping[day]);
  }
}

return result;
```

**Refactored Code:**
```javascript
const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

return dayOrder
  .filter(day => availableNights[day] && dayNameMapping[day])
  .map(day => dayNameMapping[day]);
```

**Why This Matters:**
filter().map() is the canonical FP pattern for "select and transform". Much cleaner than loop + conditional + push.

**Testing:**
- [ ] Verify day mapping works for all days
- [ ] Test partial availability (e.g., Mon-Fri only)

~~~~~

## CHUNK 24: Replace for...of loop in listingService.js:982

**File:** src/lib/listingService.js
**Line:** 982
**Violation:** IMPERATIVE_LOOP - Object.entries iteration
**Severity:** High

**Expected Affected Pages:** /edit-listing

**Current Code:**
```javascript
for (const [key, value] of Object.entries(formData)) {
  // transformation logic
}
```

**Refactored Code:**
```javascript
const transformedData = Object.fromEntries(
  Object.entries(formData).map(([key, value]) => [key, transformValue(value)])
);
```

**Why This Matters:**
Object.fromEntries(Object.entries().map()) is the functional pattern for object transformation.

**Testing:**
- [ ] Verify form data transformation
- [ ] Check all field types handled correctly

~~~~~

## CHUNK 25: Replace for...of loop + .push() in listingService.js:1076-1082

**File:** src/lib/listingService.js
**Lines:** 1076-1082
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Loop, push, and sort
**Severity:** High

**Expected Affected Pages:** /edit-listing, /create-listing

**Current Code:**
```javascript
const result = [];
for (const [day, isSelected] of Object.entries(availableNights)) {
  if (isSelected) {
    result.push(dayMapping[day]);
  }
}
return result.sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
return Object.entries(availableNights)
  .filter(([_, isSelected]) => isSelected)
  .map(([day]) => dayMapping[day])
  .toSorted((a, b) => a - b);
```

**Why This Matters:**
The full chain filter().map().toSorted() replaces three separate imperative operations with one declarative pipeline.

**Testing:**
- [ ] Verify available nights extracted correctly
- [ ] Check sorted order (0=Sun through 6=Sat)

~~~~~

## CHUNK 26: Replace for...of loop in listingService.js:1240

**File:** src/lib/listingService.js
**Line:** 1240
**Violation:** IMPERATIVE_LOOP - Processing days array
**Severity:** High

**Expected Affected Pages:** /edit-listing

**Current Code:**
```javascript
for (const dayNum of daysArray) {
  // processing logic
}
```

**Refactored Code:**
```javascript
const processedDays = daysArray.map(dayNum => ({
  // transformation per day
}));
```

**Why This Matters:**
map() for 1:1 transformations is always cleaner than for...of with mutation.

**Testing:**
- [ ] Verify days array processing
- [ ] Check output format matches expected

~~~~~

## CHUNK 27: Replace imperative loops in photoUpload.js:28,32

**File:** src/lib/photoUpload.js
**Lines:** 28, 32
**Violation:** IMPERATIVE_LOOP - Nested loops for base64 conversion
**Severity:** High

**Expected Affected Pages:** /create-listing, /edit-listing

**Current Code:**
```javascript
for (let offset = 0; offset < byteCharacters.length; offset += 512) {
  const slice = byteCharacters.slice(offset, offset + 512);
  const byteNumbers = new Array(slice.length);
  for (let i = 0; i < slice.length; i++) {
    byteNumbers[i] = slice.charCodeAt(i);
  }
  byteArrays.push(new Uint8Array(byteNumbers));
}
```

**Refactored Code:**
```javascript
// Create chunks using Array.from for declarative chunking
const chunkSize = 512;
const chunks = Array.from(
  { length: Math.ceil(byteCharacters.length / chunkSize) },
  (_, i) => byteCharacters.slice(i * chunkSize, (i + 1) * chunkSize)
);

const byteArrays = chunks.map(slice =>
  new Uint8Array(Array.from(slice, char => char.charCodeAt(0)))
);
```

**Why This Matters:**
Array.from is perfect for creating ranges and transforming iterables. The nested loops become declarative chunk creation + map.

**Testing:**
- [ ] Test photo upload with various file sizes
- [ ] Verify base64 conversion produces valid blobs

~~~~~

## CHUNK 28: Replace .push() calls in photoUpload.js:36,170,184

**File:** src/lib/photoUpload.js
**Lines:** 36, 170, 184
**Violation:** MUTATING_METHOD - Multiple .push() for byte arrays and uploads
**Severity:** High

**Expected Affected Pages:** /create-listing, /edit-listing

**Current Code:**
```javascript
byteArrays.push(new Uint8Array(byteNumbers));
// ...
uploadedPhotos.push({ ... });
// ...
uploadedPhotos.push({ ... });
```

**Refactored Code:**
```javascript
// Covered by CHUNK 27 for byteArrays
// For uploadedPhotos, use Promise.all with map:
const uploadedPhotos = await Promise.all(
  photos.map(async (photo, index) => {
    const result = await uploadPhoto(photo);
    return result.success
      ? { url: result.url, index }
      : { error: result.error, index };
  })
);
```

**Why This Matters:**
Promise.all(photos.map()) is the functional pattern for parallel async operations with collected results.

**Testing:**
- [ ] Test uploading multiple photos
- [ ] Verify error handling for failed uploads

~~~~~

## CHUNK 29: Skip .pop() false positive in photoUpload.js:86

**File:** src/lib/photoUpload.js
**Line:** 86
**Violation:** MUTATING_METHOD - False positive on .split().pop()
**Severity:** High

**Expected Affected Pages:** /create-listing, /edit-listing

**Current Code:**
```javascript
extension = photo.file.name.split('.').pop().toLowerCase() || 'jpg';
```

**Refactored Code:**
```javascript
// This is NOT a mutation - .pop() on a fresh array from split() is fine
// However, we can use at(-1) for clearer intent:
extension = (photo.file.name.split('.').at(-1) || 'jpg').toLowerCase();
```

**Why This Matters:**
While .pop() on a temporary array is safe, .at(-1) is more intent-revealing for "get last element".

**Testing:**
- [ ] Test file extension extraction: "photo.jpg" => "jpg"
- [ ] Test multiple dots: "my.photo.png" => "png"

~~~~~

## CHUNK 30: Replace for loop in photoUpload.js:164

**File:** src/lib/photoUpload.js
**Line:** 164
**Violation:** IMPERATIVE_LOOP - Traditional for loop for photo processing
**Severity:** High

**Expected Affected Pages:** /create-listing, /edit-listing

**Current Code:**
```javascript
for (let i = 0; i < photos.length; i++) {
  // processing with index
}
```

**Refactored Code:**
```javascript
const results = await Promise.all(
  photos.map(async (photo, index) => {
    // processing with index available
    return processedPhoto;
  })
);
```

**Why This Matters:**
map() with index parameter gives you everything for loops provide, but declaratively.

**Testing:**
- [ ] Verify photo order preserved
- [ ] Test index-dependent processing

~~~~~

## CHUNK 31: Replace for loop + .push() in secureStorage.js:233,236

**File:** src/lib/secureStorage.js
**Lines:** 233, 236
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - LocalStorage key collection
**Severity:** High

**Expected Affected Pages:** All pages (storage utility)

**Current Code:**
```javascript
for (let i = 0; i < localStorage.length; i++) {
  const key = localStorage.key(i);
  if (key.startsWith(prefix)) {
    keysToRemove.push(key);
  }
}
```

**Refactored Code:**
```javascript
const keysToRemove = Array.from(
  { length: localStorage.length },
  (_, i) => localStorage.key(i)
).filter(key => key?.startsWith(prefix));
```

**Why This Matters:**
Array.from with mapper + filter is cleaner than index loop + conditional push.

**Testing:**
- [ ] Test secure storage key filtering
- [ ] Verify prefix matching works correctly

~~~~~

## CHUNK 32: Replace for...of loop + .push() in supabaseUtils.js:178,189,203,210

**File:** src/lib/supabaseUtils.js
**Lines:** 178, 189, 203, 210
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Photo URL processing
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search

**Current Code:**
```javascript
const photoUrls = [];

for (const photo of photos) {
  if (typeof photo === 'object' && photo !== null) {
    let photoUrl = photo.url || photo.Photo || null;
    if (photoUrl) {
      if (photoUrl.startsWith('//')) {
        photoUrl = 'https:' + photoUrl;
      }
      photoUrls.push(photoUrl);
    }
    continue;
  }
  // ... more conditions with photoUrls.push()
}
```

**Refactored Code:**
```javascript
const extractUrl = (photo) => {
  if (typeof photo === 'object' && photo !== null) {
    const url = photo.url || photo.Photo;
    return url ? normalizeUrl(url) : null;
  }
  if (typeof photo === 'string') {
    if (photo.startsWith('http://') || photo.startsWith('https://') || photo.startsWith('//')) {
      return normalizeUrl(photo);
    }
    return photoMap[photo] || null;
  }
  return null;
};

const normalizeUrl = (url) =>
  url.startsWith('//') ? 'https:' + url : url;

const photoUrls = photos
  .map(extractUrl)
  .filter(Boolean);
```

**Why This Matters:**
Extract + map + filter is the functional pattern for "transform each, keep valid ones". Helper functions make the logic clear.

**Testing:**
- [ ] Test object format: { url: '//example.com/photo.jpg' }
- [ ] Test string URL format
- [ ] Test legacy ID format with photoMap lookup

~~~~~

## CHUNK 33: Replace for...of loop + .push() in supabaseUtils.js:258,260,269

**File:** src/lib/supabaseUtils.js
**Lines:** 258, 260, 269
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Amenity parsing
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search

**Current Code:**
```javascript
const amenities = [];
const foundAmenities = new Set();

for (const [key, amenity] of Object.entries(amenitiesMap)) {
  if (featureText.includes(key) && !foundAmenities.has(amenity.name)) {
    amenities.push(amenity);
    foundAmenities.add(amenity.name);
  }
}

if (kitchenType?.toLowerCase().includes('kitchen') && !foundAmenities.has('Kitchen')) {
  amenities.push(amenitiesMap['kitchen']);
}
```

**Refactored Code:**
```javascript
const matchedAmenities = Object.entries(amenitiesMap)
  .filter(([key]) => featureText.includes(key))
  .map(([_, amenity]) => amenity);

const uniqueAmenities = [...new Map(
  matchedAmenities.map(a => [a.name, a])
).values()];

const withKitchen = kitchenType?.toLowerCase().includes('kitchen') &&
  !uniqueAmenities.some(a => a.name === 'Kitchen')
    ? [...uniqueAmenities, amenitiesMap['kitchen']]
    : uniqueAmenities;

return withKitchen.toSorted((a, b) => a.priority - b.priority);
```

**Why This Matters:**
Using Map for deduplication is cleaner than tracking a separate Set. Conditional spreading for kitchen avoids mutation.

**Testing:**
- [ ] Test amenity detection from features text
- [ ] Verify deduplication (no duplicate amenities)
- [ ] Check kitchen amenity added when applicable

~~~~~

## CHUNK 34: Replace .sort() in supabaseUtils.js:274

**File:** src/lib/supabaseUtils.js
**Line:** 274
**Violation:** MUTATING_METHOD - Using .sort() to order amenities
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search

**Current Code:**
```javascript
amenities.sort((a, b) => a.priority - b.priority);
```

**Refactored Code:**
```javascript
// Covered by CHUNK 33 - using toSorted() at end of chain
return withKitchen.toSorted((a, b) => a.priority - b.priority);
```

**Why This Matters:**
toSorted() at end of chain maintains immutability throughout.

**Testing:**
- [ ] Verify amenities sorted by priority
- [ ] Check WiFi appears before Parking, etc.

~~~~~

## CHUNK 35: Replace while loop in workflowClient.js:139

**File:** src/lib/workflowClient.js
**Line:** 139
**Violation:** IMPERATIVE_LOOP - Polling loop with timeout
**Severity:** High

**Expected Affected Pages:** AUTO (workflow client)

**Current Code:**
```javascript
while (Date.now() - startTime < timeout) {
  // polling logic
}
```

**Refactored Code:**
```javascript
// Use recursive polling with timeout check
const poll = async (deadline) => {
  if (Date.now() >= deadline) {
    return { success: false, error: 'Timeout' };
  }

  const result = await checkStatus();
  if (result.complete) return result;

  await delay(pollInterval);
  return poll(deadline);
};

return poll(Date.now() + timeout);
```

**Why This Matters:**
Recursive polling with a deadline is more functional than while loop with Date.now() check.

**Testing:**
- [ ] Test workflow completion detection
- [ ] Verify timeout triggers correctly

~~~~~

## CHUNK 36: Replace imperative loop in isScheduleContiguous.js:64

**File:** src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 64
**Violation:** IMPERATIVE_LOOP - Contiguity check loop
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    // found gap
  }
}
```

**Refactored Code:**
```javascript
const hasGap = sorted.slice(1).some(
  (day, index) => day !== sorted[index] + 1
);
```

**Why This Matters:**
some() is perfect for "any element matches condition" checks. More expressive than loop with break.

**Testing:**
- [ ] Test contiguous check with various day combinations
- [ ] Verify wrap-around detection

~~~~~

## CHUNK 37: Replace imperative loop + .push() in isScheduleContiguous.js:95-96

**File:** src/logic/rules/scheduling/isScheduleContiguous.js
**Lines:** 95-96
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Range building
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
const expectedNotSelected = [];
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i)
}
```

**Refactored Code:**
```javascript
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
Array.from is the standard way to create ranges in functional JavaScript.

**Testing:**
- [ ] Verify range generation
- [ ] Test edge cases (single element, full range)

~~~~~

## CHUNK 38: Remove console.error in extractListingCoordinates.js:46

**File:** src/logic/processors/listing/extractListingCoordinates.js
**Line:** 46
**Violation:** IO_IN_CORE - console.error in processor function
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
} catch (error) {
  console.error(
    '❌ extractListingCoordinates: Failed to parse Location - slightly different address:',
    {
      listingId,
      rawValue: locationSlightlyDifferent,
      error: error.message
    }
  )
  parsedSlightlyDifferent = null
}
```

**Refactored Code:**
```javascript
} catch (error) {
  // Return parsing failure in result, let caller decide how to handle
  parsedSlightlyDifferent = null;
  // Note: Error info available via the null value and can be logged at workflow level
}
```

**Why This Matters:**
Processors should be pure. Logging is I/O that belongs in the calling workflow, not the pure processing function.

**Testing:**
- [ ] Verify coordinate extraction still works
- [ ] Check error handling at workflow level

~~~~~

## CHUNK 39: Remove console.error in extractListingCoordinates.js:62

**File:** src/logic/processors/listing/extractListingCoordinates.js
**Line:** 62
**Violation:** IO_IN_CORE - console.error in processor
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
console.error('❌ extractListingCoordinates: Failed to parse Location - Address:', {
  listingId,
  rawValue: locationAddress,
  error: error.message
})
```

**Refactored Code:**
```javascript
// Remove - error handling belongs at workflow layer
// Processor returns null for invalid data, caller logs if needed
```

**Why This Matters:**
Pure functions don't log. The workflow calling this processor can log based on the return value.

**Testing:**
- [ ] Verify null returned for invalid data
- [ ] Check workflow handles null correctly

~~~~~

## CHUNK 40: Remove console.warn in extractListingCoordinates.js:98

**File:** src/logic/processors/listing/extractListingCoordinates.js
**Line:** 98
**Violation:** IO_IN_CORE - console.warn in processor
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
console.warn('⚠️ extractListingCoordinates: No valid coordinates found for listing:', {
  listingId,
  hasSlightlyDifferent: !!parsedSlightlyDifferent,
  hasMainAddress: !!parsedAddress
})
```

**Refactored Code:**
```javascript
// Remove - null return indicates no coordinates
// Caller can decide whether to log or silently handle
return null;
```

**Why This Matters:**
The null return value IS the signal. No need for I/O in a pure processor.

**Testing:**
- [ ] Verify null returned for missing coordinates
- [ ] Check caller handles gracefully

~~~~~

## CHUNK 41: Remove console.warn in processUserData.js:58

**File:** src/logic/processors/user/processUserData.js
**Line:** 58
**Violation:** IO_IN_CORE - console.warn in processor
**Severity:** High

**Expected Affected Pages:** All authenticated pages

**Current Code:**
```javascript
console.warn(`processUserData: User ${rawUser._id} has no name fields, using default`)
```

**Refactored Code:**
```javascript
// Remove - the default value usage is the behavior
// If caller needs to know, they can check the returned value
// Return includes a flag or use a Result type to indicate default was used
return {
  ...processedUser,
  _usedDefaultName: true  // Optional: signal to caller
};
```

**Why This Matters:**
Processors return data, not logs. The return value can include metadata if the caller needs to know defaults were used.

**Testing:**
- [ ] Verify default name still applied
- [ ] Check processed user data structure

~~~~~

## CHUNK 42: Replace [...arr].sort() in calculateCheckInOutDays.js:50

**File:** src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 50
**Violation:** MUTATING_METHOD - Using [...arr].sort()
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
const sorted = [...selectedDays].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
const sorted = selectedDays.toSorted((a, b) => a - b);
```

**Why This Matters:**
toSorted() is cleaner and more intent-revealing than spreading then sorting.

**Testing:**
- [ ] Verify day sorting works
- [ ] Check check-in/out calculation

~~~~~

## CHUNK 43: Replace imperative loop in calculateCheckInOutDays.js:59

**File:** src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 59
**Violation:** IMPERATIVE_LOOP - Gap detection loop
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease, /create-proposal

**Current Code:**
```javascript
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    gapIndex = i;
    break;
  }
}
```

**Refactored Code:**
```javascript
const gapOffset = sorted.slice(1).findIndex(
  (day, index) => day !== sorted[index] + 1
);
const gapIndex = gapOffset === -1 ? -1 : gapOffset + 1;
```

**Why This Matters:**
findIndex() is the declarative way to find the first match. The offset adjustment handles the sliced array indexing.

**Testing:**
- [ ] Test gap detection in various sequences
- [ ] Verify wrap-around handling

~~~~~

## CHUNK 44: Replace [...arr].sort() in calculateNextAvailableCheckIn.js:54

**File:** src/logic/calculators/scheduling/calculateNextAvailableCheckIn.js
**Line:** 54
**Violation:** MUTATING_METHOD - Using [...arr].sort()
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /create-proposal

**Current Code:**
```javascript
const sortedDays = [...selectedDayIndices].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
const sortedDays = selectedDayIndices.toSorted((a, b) => a - b);
```

**Why This Matters:**
Consistent use of toSorted() across the codebase.

**Testing:**
- [ ] Verify next check-in calculation
- [ ] Test with various day selections

~~~~~

## CHUNK 45: Replace .push() in userProposalQueries.js:225

**File:** src/lib/proposals/userProposalQueries.js
**Line:** 225
**Violation:** MUTATING_METHOD - Using .push() to collect listing IDs
**Severity:** High

**Expected Affected Pages:** /guest-proposals, /host-proposals

**Current Code:**
```javascript
listingsNeedingPhotoFetch.push(listing._id);
```

**Refactored Code:**
```javascript
const listingsNeedingPhotoFetch = listings
  .filter(listing => needsPhotoFetch(listing))
  .map(listing => listing._id);
```

**Why This Matters:**
filter().map() is cleaner than conditional push in a loop.

**Testing:**
- [ ] Verify photo fetch logic
- [ ] Check listing IDs collected correctly

~~~~~

## CHUNK 46: Replace [...arr].sort() in dayHelpers.js:44

**File:** src/lib/scheduleSelector/dayHelpers.js
**Line:** 44
**Violation:** MUTATING_METHOD - Using [...arr].sort()
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
return [...days].sort((a, b) => a.dayOfWeek - b.dayOfWeek);
```

**Refactored Code:**
```javascript
return days.toSorted((a, b) => a.dayOfWeek - b.dayOfWeek);
```

**Why This Matters:**
toSorted() is the modern, immutable alternative.

**Testing:**
- [ ] Verify day sorting by dayOfWeek
- [ ] Check schedule selector displays correctly

~~~~~

## CHUNK 47: Replace imperative loop + .push() in dayHelpers.js:112-113

**File:** src/lib/scheduleSelector/dayHelpers.js
**Lines:** 112-113
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Night calculation
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
for (let i = 0; i < sortedDays.length - 1; i++) {
  nights.push(createNight(sortedDays[i].dayOfWeek));
}
```

**Refactored Code:**
```javascript
const nights = sortedDays
  .slice(0, -1)
  .map(day => createNight(day.dayOfWeek));
```

**Why This Matters:**
slice(0, -1) gets all but last element, then map transforms. Clean and declarative.

**Testing:**
- [ ] Verify nights calculated correctly
- [ ] Test edge cases (single day, all days)

~~~~~

## CHUNK 48: Replace imperative loop + .push() in nightCalculations.js:14-15

**File:** src/lib/scheduleSelector/nightCalculations.js
**Lines:** 14-15
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Night creation loop
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
for (let i = 0; i < sorted.length - 1; i++) {
  nights.push(createNight(sorted[i].dayOfWeek));
}
```

**Refactored Code:**
```javascript
const nights = sorted
  .slice(0, -1)
  .map(day => createNight(day.dayOfWeek));
```

**Why This Matters:**
Same pattern as CHUNK 47. Consistency across the codebase.

**Testing:**
- [ ] Verify night calculation
- [ ] Check createNight called correctly

~~~~~

## CHUNK 49: Replace imperative loop in nightCalculations.js:50

**File:** src/lib/scheduleSelector/nightCalculations.js
**Line:** 50
**Violation:** IMPERATIVE_LOOP - Day number processing
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
for (let i = 0; i < dayNumbers.length - 1; i++) {
  // processing
}
```

**Refactored Code:**
```javascript
const processed = dayNumbers
  .slice(0, -1)
  .map((dayNum, index) => {
    // processing with dayNum and index
  });
```

**Why This Matters:**
Consistent use of slice + map pattern for "process all but last" scenarios.

**Testing:**
- [ ] Verify day number processing
- [ ] Check index-dependent logic

~~~~~

## CHUNK 50: Replace imperative loop + .push() in validators.js:101-102

**File:** src/lib/scheduleSelector/validators.js
**Lines:** 101-102
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Range building
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i);
}
```

**Refactored Code:**
```javascript
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
Array.from for range creation is the standard FP pattern.

**Testing:**
- [ ] Verify range generation
- [ ] Test validator edge cases

~~~~~

## CHUNK 51: Replace imperative loop in validators.js:114

**File:** src/lib/scheduleSelector/validators.js
**Line:** 114
**Violation:** IMPERATIVE_LOOP - Day number iteration
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
for (let i = 0; i < dayNumbers.length - 1; i++) {
  // validation logic
}
```

**Refactored Code:**
```javascript
const isValid = dayNumbers
  .slice(0, -1)
  .every((dayNum, index) => {
    // validation logic returning boolean
  });
```

**Why This Matters:**
every() for validation checks, with slice for "all but last" pattern.

**Testing:**
- [ ] Verify validation logic
- [ ] Test various day combinations

~~~~~

## CHUNK 52: Replace .push() in useEmailSmsUnitPageLogic.js:229

**File:** src/islands/pages/useEmailSmsUnitPageLogic.js
**Line:** 229
**Violation:** MUTATING_METHOD - Using .push() to add email field
**Severity:** High

**Expected Affected Pages:** /email-sms-unit

**Current Code:**
```javascript
emails.push('');
```

**Refactored Code:**
```javascript
setEmails(prevEmails => [...prevEmails, '']);
```

**Why This Matters:**
React state updates should use functional updates with spread, never direct mutation.

**Testing:**
- [ ] Test adding new email field
- [ ] Verify form state updates correctly

~~~~~

## CHUNK 53: Replace .push() calls in useSearchPageLogic.js:148-149

**File:** src/islands/pages/useSearchPageLogic.js
**Lines:** 148-149
**Violation:** MUTATING_METHOD - Using .push() for location parts
**Severity:** High

**Expected Affected Pages:** /search

**Current Code:**
```javascript
const locationParts = [];
if (neighborhoodName) locationParts.push(neighborhoodName)
if (boroughName) locationParts.push(boroughName)
```

**Refactored Code:**
```javascript
const locationParts = [
  neighborhoodName,
  boroughName
].filter(Boolean);
```

**Why This Matters:**
Array literal with filter(Boolean) is cleaner than conditional pushes.

**Testing:**
- [ ] Verify location display
- [ ] Test with various location combinations

~~~~~

## CHUNK 54: Replace .push() calls in useEditListingDetailsLogic.js:267-269

**File:** src/islands/shared/EditListingDetails/useEditListingDetailsLogic.js
**Lines:** 267-269
**Violation:** MUTATING_METHOD - Using .push() for address parts
**Severity:** High

**Expected Affected Pages:** /edit-listing

**Current Code:**
```javascript
const parts = [];
if (city) parts.push(city);
if (state) parts.push(state);
if (zip) parts.push(zip);
```

**Refactored Code:**
```javascript
const parts = [city, state, zip].filter(Boolean);
```

**Why This Matters:**
Same pattern as CHUNK 53. filter(Boolean) removes falsy values elegantly.

**Testing:**
- [ ] Verify address formatting
- [ ] Test with partial address data

~~~~~

## CHUNK 55: Replace for...of loop in useEditListingDetailsLogic.js:528

**File:** src/islands/shared/EditListingDetails/useEditListingDetailsLogic.js
**Line:** 528
**Violation:** IMPERATIVE_LOOP - Object entries iteration
**Severity:** High

**Expected Affected Pages:** /edit-listing

**Current Code:**
```javascript
for (const [key, value] of Object.entries(formData)) {
  // processing
}
```

**Refactored Code:**
```javascript
const processedData = Object.fromEntries(
  Object.entries(formData).map(([key, value]) => [key, processValue(value)])
);
```

**Why This Matters:**
Object.fromEntries + Object.entries + map is the functional object transformation pattern.

**Testing:**
- [ ] Verify form data processing
- [ ] Check all fields transformed correctly

~~~~~

## CHUNK 56: Replace imperative loop + .push() in useEditListingDetailsLogic.js:833,837

**File:** src/islands/shared/EditListingDetails/useEditListingDetailsLogic.js
**Lines:** 833, 837
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - File upload loop
**Severity:** High

**Expected Affected Pages:** /edit-listing

**Current Code:**
```javascript
for (let i = 0; i < files.length; i++) {
  // upload logic
  uploadedUrls.push(result.url);
}
```

**Refactored Code:**
```javascript
const uploadedUrls = await Promise.all(
  Array.from(files).map(async (file) => {
    const result = await uploadFile(file);
    return result.url;
  })
);
```

**Why This Matters:**
Promise.all(map()) for parallel async operations is more efficient and declarative.

**Testing:**
- [ ] Test multiple file uploads
- [ ] Verify all URLs collected

~~~~~

## REMAINING CHUNKS (57-347)

Due to the large number of violations (347 total), the remaining chunks follow the same patterns:

### Pattern Categories for Remaining Violations:

**MUTATING_METHOD (.push(), .sort(), .reverse()):**
- Replace `.push()` with spread: `[...arr, item]`
- Replace `.sort()` with `.toSorted()`
- Replace `.reverse()` with `.toReversed()`

**IMPERATIVE_LOOP (for, while, for...of):**
- Replace for loops with `.map()`, `.filter()`, `.reduce()`
- Replace while loops with recursive helpers
- Replace for...of with array methods

**IO_IN_CORE (console.log/warn/error):**
- Remove console statements from processors/calculators/rules
- Return metadata in result objects if caller needs the info
- Move logging to workflow layer

### Files with Multiple Remaining Violations:

| File | Violations | Primary Pattern |
|------|------------|-----------------|
| listingLocalStore.ts | 21 | Store mutations - use Zustand/Immer patterns |
| prepareListingSubmission.ts | 15 | Data transformation - use map/reduce |
| LoggedInAvatar.jsx | 12 | State updates - use functional setState |
| AvailabilitySection.jsx | 11 | Array building - use declarative arrays |
| PricingEditSection.jsx | 10 | Form state - use spread updates |
| Section1SpaceSnapshot.tsx | 10 | Store mutations - use Immer |
| Section5Rules.tsx | 10 | Store mutations - use Immer |
| SearchScheduleSelector.jsx | 9 | Day selection - use filter/map |
| HostScheduleSelector/* | 16 | Schedule utilities - use FP patterns |

---

## Implementation Priority

### Phase 1: Core Logic (High Impact)
1. `availabilityValidation.js` - Critical scheduling validation
2. `isScheduleContiguous.js` - Schedule contiguity rules
3. `calculateCheckInOutDays.js` - Check-in/out calculator
4. `extractListingCoordinates.js` - Remove I/O from processor

### Phase 2: Services (Medium Impact)
5. `listingService.js` - Listing CRUD operations
6. `dataLookups.js` - Lookup utilities
7. `supabaseUtils.js` - Database utilities
8. `photoUpload.js` - Photo handling

### Phase 3: Components (UI Layer)
9. `useSearchPageLogic.js` - Search page state
10. `useEditListingDetailsLogic.js` - Edit listing state
11. `SearchScheduleSelector.jsx` - Schedule UI
12. `HostScheduleSelector/*` - Host schedule UI

### Phase 4: Store Layer
13. `listingLocalStore.ts` - Consider Immer integration
14. `prepareListingSubmission.ts` - Submission processor

---

## Notes for Implementation

1. **Browser Compatibility**: `toSorted()` requires ES2023+. Verify browser support or add polyfill.

2. **Performance**: For large arrays, benchmark functional vs imperative. In most cases, functional is fast enough.

3. **Testing**: Each chunk should have its tests pass before moving to the next.

4. **Gradual Migration**: Implement chunks independently. No need to complete all at once.

5. **Review Checkpoints**: After every 10 chunks, run full test suite and verify no regressions.

---

## References

- [FP Audit Script](/.claude/skills/functional-code/scripts/fp_audit.py)
- [Functional Programming Guide](/.claude/skills/functional-code/README.md)
- [Original Violations JSON](/agents/20260111132021_fp_audit_violations.json)
