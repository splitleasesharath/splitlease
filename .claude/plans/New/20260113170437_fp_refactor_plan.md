# Functional Programming Refactoring Plan

Date: 2026-01-13
Target: agents/20260113170437_fp_audit_violations.json
Severity Filter: high

~~~~~

## CHUNK 1: Replace imperative loop with declarative every() in isScheduleContiguous.js

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 64
**Violation:** ViolationType.IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
  // Check for standard contiguous sequence (no wrap around)
  let isStandardContiguous = true
  for (let i = 1; i < sorted.length; i++) {
    if (sorted[i] !== sorted[i - 1] + 1) {
      isStandardContiguous = false
      break
    }
  }

  if (isStandardContiguous) {
    return true
  }
```

**Refactored Code:**
```javascript
  // Check for standard contiguous sequence (no wrap around)
  const isStandardContiguous = sorted.slice(1).every((day, i) => day === sorted[i] + 1)

  if (isStandardContiguous) {
    return true
  }
```

**Why This Matters:**
Declarative methods like `every()` express the intent of the code more clearly than imperative loops. They avoid manual state management (like the `isStandardContiguous` flag and `break` statement), making the code less prone to off-by-one errors.

**Testing:**
- [ ] Run unit tests for `isScheduleContiguous`
- [ ] Verify contiguous ranges (e.g., [1, 2, 3]) return true
- [ ] Verify non-contiguous ranges (e.g., [1, 3, 4]) return false

~~~~~

## CHUNK 2: Replace imperative loop with Array.from() in isScheduleContiguous.js

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 95
**Violation:** ViolationType.IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = []
    for (let i = minNotSelected; i <= maxNotSelected; i++) {
      expectedNotSelected.push(i)
    }
```

**Refactored Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = Array.from(
      { length: maxNotSelected - minNotSelected + 1 },
      (_, i) => minNotSelected + i
    )
```

**Why This Matters:**
Using `Array.from()` to generate a range is more declarative than initializing an empty array and pushing to it in a loop. It treats the array as a single value being computed rather than a container being mutated.

**Testing:**
- [ ] Run unit tests for `isScheduleContiguous`
- [ ] Verify wrap-around cases (e.g., [5, 6, 0]) return true
- [ ] Verify non-contiguous wrap-around cases return false

~~~~~

## CHUNK 3: Remove mutating .push() in isScheduleContiguous.js

**File:** app/src/logic/rules/scheduling/isScheduleContiguous.js
**Line:** 96
**Violation:** ViolationType.MUTATING_METHOD - Using mutating array method
**Severity:** High

**Expected Affected Pages:** /search, /view-split-lease

**Current Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = []
    for (let i = minNotSelected; i <= maxNotSelected; i++) {
      expectedNotSelected.push(i)
    }
```

**Refactored Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = Array.from(
      { length: maxNotSelected - minNotSelected + 1 },
      (_, i) => minNotSelected + i
    )
```

**Why This Matters:**
Mutation of local variables makes code harder to reason about and can lead to side effects if the variable is shared. Functional style prefers constructing the final value directly.

**Testing:**
- [ ] Run unit tests for `isScheduleContiguous`
- [ ] Verify the generated range correctly includes both min and max values

~~~~~

## CHUNK 4: Remove I/O (console.error) from extractListingCoordinates.js:46

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 46
**Violation:** ViolationType.IO_IN_CORE - I/O operation found in core business logic
**Severity:** High

**Expected Affected Pages:** /search, /listing-details

**Current Code:**
```javascript
  if (typeof locationSlightlyDifferent === 'string') {
    try {
      parsedSlightlyDifferent = JSON.parse(locationSlightlyDifferent)
    } catch (error) {
      console.error(
        '❌ extractListingCoordinates: Failed to parse Location - slightly different address:',
        {
          listingId,
          rawValue: locationSlightlyDifferent,
          error: error.message
        }
      )
      parsedSlightlyDifferent = null
    }
  }
```

**Refactored Code:**
```javascript
  if (typeof locationSlightlyDifferent === 'string') {
    try {
      parsedSlightlyDifferent = JSON.parse(locationSlightlyDifferent)
    } catch (error) {
      // I/O moved to caller/workflow layer
      parsedSlightlyDifferent = null
    }
  }
```

**Why This Matters:**
Pure business logic should not perform I/O like logging. This makes the function easier to test in isolation and ensures it doesn't pollute logs during testing or in environments where logging is handled differently.

**Testing:**
- [ ] Verify coordinates are still extracted correctly from valid JSON
- [ ] Verify invalid JSON still returns null without crashing
- [ ] Confirm no error logs appear in console for invalid JSON

~~~~~

## CHUNK 5: Remove I/O (console.error) from extractListingCoordinates.js:62

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 62
**Violation:** ViolationType.IO_IN_CORE - I/O operation found in core business logic
**Severity:** High

**Expected Affected Pages:** /search, /listing-details

**Current Code:**
```javascript
  if (typeof locationAddress === 'string') {
    try {
      parsedAddress = JSON.parse(locationAddress)
    } catch (error) {
      console.error('❌ extractListingCoordinates: Failed to parse Location - Address:', {
        listingId,
        rawValue: locationAddress,
        error: error.message
      })
      parsedAddress = null
    }
  }
```

**Refactored Code:**
```javascript
  if (typeof locationAddress === 'string') {
    try {
      parsedAddress = JSON.parse(locationAddress)
    } catch (error) {
      // I/O moved to caller/workflow layer
      parsedAddress = null
    }
  }
```

**Why This Matters:**
Separating side effects (I/O) from logic ensures that the core processor is deterministic and predictable. Errors should be handled by returning a Result type or letting the caller handle the failure.

**Testing:**
- [ ] Verify main address coordinates are extracted correctly
- [ ] Verify invalid main address JSON returns null gracefully

~~~~~

## CHUNK 6: Remove I/O (console.warn) from extractListingCoordinates.js:98

**File:** app/src/logic/processors/listing/extractListingCoordinates.js
**Line:** 98
**Violation:** ViolationType.IO_IN_CORE - I/O operation found in core business logic
**Severity:** High

**Expected Affected Pages:** /search, /listing-details

**Current Code:**
```javascript
  // No Fallback: Return null if no valid coordinates found
  console.warn('⚠️ extractListingCoordinates: No valid coordinates found for listing:', {
    listingId,
    hasSlightlyDifferent: !!parsedSlightlyDifferent,
    hasMainAddress: !!parsedAddress
  })

  return null
```

**Refactored Code:**
```javascript
  // No Fallback: Return null if no valid coordinates found
  return null
```

**Why This Matters:**
Core logic should focus on the transformation of data. If no coordinates are found, returning `null` is the expected functional behavior; the decision to log this as a warning belongs to the orchestration or workflow layer.

**Testing:**
- [ ] Verify function returns null when no coordinates are present
- [ ] Confirm no warning logs appear in console

~~~~~

## CHUNK 7: Remove I/O (console.warn) from processUserData.js:58

**File:** app/src/logic/processors/user/processUserData.js
**Line:** 58
**Violation:** ViolationType.IO_IN_CORE - I/O operation found in core business logic
**Severity:** High

**Expected Affected Pages:** /profile, /account, /host-proposals, /guest-proposals

**Current Code:**
```javascript
    } else {
      // Use a default for users without any name fields
      fullName = 'Guest User'
      console.warn(`processUserData: User ${rawUser._id} has no name fields, using default`)
    }
```

**Refactored Code:**
```javascript
    } else {
      // Use a default for users without any name fields
      fullName = 'Guest User'
    }
```

**Why This Matters:**
Logging is a side effect. Removing it from the data processor makes the function pure and easier to test. If tracking users with missing names is required, it should be done at the data ingestion or workflow layer.

**Testing:**
- [ ] Verify user with no name fields gets "Guest User" as full name
- [ ] Confirm no warning logs appear in console

~~~~~

## CHUNK 8: Use toSorted() instead of .sort() in calculateCheckInOutDays.js

**File:** app/src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 50
**Violation:** ViolationType.MUTATING_METHOD - Using mutating array sort/reverse
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /booking

**Current Code:**
```javascript
  const sorted = [...selectedDays].sort((a, b) => a - b)
```

**Refactored Code:**
```javascript
  const sorted = selectedDays.toSorted((a, b) => a - b)
```

**Why This Matters:**
`toSorted()` is the modern, non-mutating alternative to `sort()`. While `[...arr].sort()` avoids mutating the original array, `toSorted()` is more explicitly functional and avoids the need for manual shallow copying.

**Testing:**
- [ ] Run unit tests for `calculateCheckInOutDays`
- [ ] Verify days are sorted correctly before boundary calculation
- [ ] Ensure original `selectedDays` array remains unchanged

~~~~~

## CHUNK 9: Replace imperative loop with findIndex() in calculateCheckInOutDays.js

**File:** app/src/logic/calculators/scheduling/calculateCheckInOutDays.js
**Line:** 59
**Violation:** ViolationType.IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /booking

**Current Code:**
```javascript
    // Find gap to determine actual start/end
    let gapIndex = -1
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] !== sorted[i - 1] + 1) {
        gapIndex = i
        break
      }
    }
```

**Refactored Code:**
```javascript
    // Find gap to determine actual start/end
    const gapIndex = sorted.findIndex((day, i) => i > 0 && day !== sorted[i - 1] + 1)
```

**Why This Matters:**
`findIndex()` is a declarative way to locate an element that meets a condition. It eliminates the need for a mutable `gapIndex` variable and an explicit `break` statement, making the code more concise and readable.

**Testing:**
- [ ] Run unit tests for `calculateCheckInOutDays`
- [ ] Verify wrap-around logic works correctly with identified gap
- [ ] Verify cases with no gap (standard contiguous) still work

~~~~~

## CHUNK 10: Use toSorted() instead of .sort() in calculateNextAvailableCheckIn.js

**File:** app/src/logic/calculators/scheduling/calculateNextAvailableCheckIn.js
**Line:** 54
**Violation:** ViolationType.MUTATING_METHOD - Using mutating array sort/reverse
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /booking

**Current Code:**
```javascript
  // Get the first selected day (check-in day of week)
  // Days should already be sorted, but sort to be safe
  const sortedDays = [...selectedDayIndices].sort((a, b) => a - b)
  const firstDayOfWeek = sortedDays[0]
```

**Refactored Code:**
```javascript
  // Get the first selected day (check-in day of week)
  // Days should already be sorted, but sort to be safe
  const sortedDays = selectedDayIndices.toSorted((a, b) => a - b)
  const firstDayOfWeek = sortedDays[0]
```

**Why This Matters:**
Using `toSorted()` ensures that we never accidentally mutate the input `selectedDayIndices`. It follows the principle of immutability and makes the code more robust against unintended side effects.

**Testing:**
- [ ] Run unit tests for `calculateNextAvailableCheckIn`
- [ ] Verify the correct check-in date is calculated for various schedules
- [ ] Ensure `selectedDayIndices` input array is not mutated
