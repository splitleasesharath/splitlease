# Functional Programming Refactoring Plan

**Date:** 2026-01-10
**Target:** agents/fp_audit_violations.json
**Severity Filter:** high
**Total Violations:** 356

## Summary by Violation Type
| Type | Count | Principle |
|------|-------|-----------|
| MUTATING_METHOD | 270 | IMMUTABILITY |
| IMPERATIVE_LOOP | 81 | DECLARATIVE STYLE |
| IO_IN_CORE | 5 | EFFECTS AT EDGES |

## Top Files by Violation Count
| File | Violations |
|------|------------|
| src/islands/pages/SelfListingPage/store/listingLocalStore.ts | 21 |
| src/lib/availabilityValidation.js | 16 |
| src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts | 15 |
| src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx | 12 |
| src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx | 11 |
| src/islands/pages/ListingDashboardPage/components/PricingEditSection.jsx | 10 |
| src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx | 10 |
| src/islands/pages/SelfListingPage/sections/Section5Rules.tsx | 10 |

---

## CHUNK 1: Replace .push() in listingLocalStore.ts:254

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 254
**Violation:** MUTATING_METHOD - Using .push() to mutate errors array
**Severity:** High

**Current Code:**
```typescript
} catch (error) {
  console.error('❌ ListingLocalStore: Error saving draft:', error);
  this.state.errors.push('Failed to save draft');
  this.notifyListeners();
  return false;
}
```

**Refactored Code:**
```typescript
} catch (error) {
  console.error('❌ ListingLocalStore: Error saving draft:', error);
  this.state.errors = [...this.state.errors, 'Failed to save draft'];
  this.notifyListeners();
  return false;
}
```

**Why This Matters:**
Mutation makes state changes unpredictable and harder to track in debugging. Using spread operator creates a new array reference, making state changes explicit and enabling better React re-render detection.

**Testing:**
- [ ] Verify error messages appear correctly when draft save fails
- [ ] Confirm store listeners are notified properly
- [ ] Test multiple errors accumulate correctly

---

## CHUNK 2: Replace .push() in listingLocalStore.ts:364

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 364
**Violation:** MUTATING_METHOD - Using .push() to mutate errors array
**Severity:** High

**Current Code:**
```typescript
markSubmissionFailed(error: string): void {
  this.state.stagingStatus = 'failed';
  this.state.errors.push(error);
  console.error('❌ ListingLocalStore: Submission failed:', error);
  this.notifyListeners();
}
```

**Refactored Code:**
```typescript
markSubmissionFailed(error: string): void {
  this.state.stagingStatus = 'failed';
  this.state.errors = [...this.state.errors, error];
  console.error('❌ ListingLocalStore: Submission failed:', error);
  this.notifyListeners();
}
```

**Why This Matters:**
Consistent immutable patterns throughout a class make the codebase more predictable. When state.errors is mutated in some places but not others, it creates cognitive overhead.

**Testing:**
- [ ] Test submission failure flow adds error message
- [ ] Verify UI displays the failure error correctly
- [ ] Check retry mechanism after failure

---

## CHUNK 3: Replace .push() with declarative construction in listingLocalStore.ts:387-456

**File:** app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts
**Line:** 387-456
**Violation:** MUTATING_METHOD - Multiple .push() calls in validateForSubmission
**Severity:** High

**Current Code:**
```typescript
validateForSubmission(): string[] {
  const errors: string[] = [];
  const data = this.state.data;

  // Section 1: Space Snapshot
  if (!data.spaceSnapshot.listingName) {
    errors.push('Listing name is required');
  }
  if (!data.spaceSnapshot.typeOfSpace) {
    errors.push('Type of space is required');
  }
  // ... more push calls
  return errors;
}
```

**Refactored Code:**
```typescript
validateForSubmission(): string[] {
  const data = this.state.data;

  // Section 1: Space Snapshot validation
  const spaceSnapshotErrors = [
    !data.spaceSnapshot.listingName && 'Listing name is required',
    !data.spaceSnapshot.typeOfSpace && 'Type of space is required',
    !data.spaceSnapshot.typeOfKitchen && 'Type of kitchen is required',
    !data.spaceSnapshot.typeOfParking && 'Type of parking is required',
    (!data.spaceSnapshot.address.fullAddress || !data.spaceSnapshot.address.validated) && 'Valid NYC address is required',
  ];

  // Section 2: Features validation
  const featureErrors = [
    data.features.amenitiesInsideUnit.length === 0 && 'At least one amenity inside unit is required',
    !data.features.descriptionOfLodging && 'Description of lodging is required',
  ];

  // Section 3: Lease Styles validation
  const leaseStyleErrors = [
    !data.leaseStyles.rentalType && 'Rental type is required',
    data.leaseStyles.rentalType === 'Nightly' &&
      (!data.leaseStyles.availableNights || !Object.values(data.leaseStyles.availableNights).some(v => v)) &&
      'At least one available night must be selected',
    data.leaseStyles.rentalType === 'Weekly' && !data.leaseStyles.weeklyPattern && 'Weekly pattern is required',
  ];

  // Section 4: Pricing validation
  const pricingErrors = [
    data.pricing.damageDeposit < 500 && 'Damage deposit must be at least $500',
    data.leaseStyles.rentalType === 'Monthly' && !data.pricing.monthlyCompensation && 'Monthly compensation is required',
    data.leaseStyles.rentalType === 'Weekly' && !data.pricing.weeklyCompensation && 'Weekly compensation is required',
    data.leaseStyles.rentalType === 'Nightly' && !data.pricing.nightlyPricing?.oneNightPrice && 'Nightly pricing is required',
  ];

  // Section 5: Rules validation
  const rulesErrors = [
    !data.rules.cancellationPolicy && 'Cancellation policy is required',
    !data.rules.checkInTime && 'Check-in time is required',
    !data.rules.checkOutTime && 'Check-out time is required',
  ];

  // Section 6: Photos validation
  const photoErrors = [
    data.photos.photos.length < data.photos.minRequired && `At least ${data.photos.minRequired} photos are required`,
  ];

  return [
    ...spaceSnapshotErrors,
    ...featureErrors,
    ...leaseStyleErrors,
    ...pricingErrors,
    ...rulesErrors,
    ...photoErrors,
  ].filter(Boolean) as string[];
}
```

**Why This Matters:**
Declarative array construction shows all possible validation errors at a glance. The logical grouping by section makes it easier to maintain and extend. Using `.filter(Boolean)` eliminates falsy values cleanly.

**Testing:**
- [ ] Run all listing validation unit tests
- [ ] Test each validation section independently
- [ ] Verify error messages match expected strings exactly

---

## CHUNK 4: Replace for-loop with map/filter in availabilityValidation.js:38-43

**File:** app/src/lib/availabilityValidation.js
**Line:** 38-43
**Violation:** IMPERATIVE_LOOP - for loop checking contiguity
**Severity:** High

**Current Code:**
```javascript
// Check for standard contiguous sequence (no wrap around)
let isStandardContiguous = true;
for (let i = 1; i < sorted.length; i++) {
  if (sorted[i] !== sorted[i - 1] + 1) {
    isStandardContiguous = false;
    break;
  }
}
```

**Refactored Code:**
```javascript
// Check for standard contiguous sequence (no wrap around)
const isStandardContiguous = sorted.every((day, i) =>
  i === 0 || day === sorted[i - 1] + 1
);
```

**Why This Matters:**
The `.every()` method expresses intent clearly: "every element must satisfy this condition." It eliminates mutable `let` variable and early-exit logic that can be error-prone.

**Testing:**
- [ ] Test contiguous selections: [1,2,3,4,5] should return true
- [ ] Test non-contiguous: [1,3,5] should return false
- [ ] Test wrap-around cases: [5,6,0] should return true

---

## CHUNK 5: Replace for-loop and .push() in availabilityValidation.js:64-67

**File:** app/src/lib/availabilityValidation.js
**Line:** 64-67
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - for loop building array with push
**Severity:** High

**Current Code:**
```javascript
// Generate expected contiguous range for not-selected days
const expectedNotSelected = [];
for (let i = minNotSelected; i <= maxNotSelected; i++) {
  expectedNotSelected.push(i);
}
```

**Refactored Code:**
```javascript
// Generate expected contiguous range for not-selected days
const expectedNotSelected = Array.from(
  { length: maxNotSelected - minNotSelected + 1 },
  (_, i) => minNotSelected + i
);
```

**Why This Matters:**
`Array.from()` with a mapping function is a declarative way to create sequences. It clearly shows the intent: create an array of specified length where each element is computed from its index.

**Testing:**
- [ ] Verify range [2, 5] produces [2, 3, 4, 5]
- [ ] Test edge case where min === max produces single element
- [ ] Verify week wrap-around logic still works correctly

---

## CHUNK 6: Replace for-loop with every() in availabilityValidation.js:106-111

**File:** app/src/lib/availabilityValidation.js
**Line:** 106-111
**Violation:** IMPERATIVE_LOOP - for loop checking gap in sorted array
**Severity:** High

**Current Code:**
```javascript
if (hasZero && hasSix) {
  // Find gap to determine actual start/end
  let gapIndex = -1;
  for (let i = 1; i < sorted.length; i++) {
    if (sorted[i] !== sorted[i - 1] + 1) {
      gapIndex = i;
      break;
    }
  }
```

**Refactored Code:**
```javascript
if (hasZero && hasSix) {
  // Find gap to determine actual start/end
  const gapIndex = sorted.findIndex((day, i) =>
    i > 0 && day !== sorted[i - 1] + 1
  );
```

**Why This Matters:**
`.findIndex()` is semantically correct for "find the first index where condition is true." It's self-documenting and eliminates mutable `let` variable.

**Testing:**
- [ ] Test [0, 1, 5, 6] finds gap at index 2
- [ ] Test [0, 1, 2] returns -1 (no gap)
- [ ] Verify check-in/out calculation for wrap-around schedules

---

## CHUNK 7: Replace .push() calls in validateScheduleSelection (availabilityValidation.js:166-199)

**File:** app/src/lib/availabilityValidation.js
**Line:** 166, 175, 181, 186, 199
**Violation:** MUTATING_METHOD - Multiple .push() calls to errors/warnings arrays
**Severity:** High

**Current Code:**
```javascript
export function validateScheduleSelection(selectedDays, listing) {
  const result = {
    valid: true,
    errors: [],
    warnings: [],
    showTutorial: false,
    nightsCount: selectedDays.length,
    isContiguous: false
  };

  if (!selectedDays || selectedDays.length === 0) {
    result.valid = false;
    result.errors.push('Please select at least one day');
    return result;
  }
  // ... more push calls
}
```

**Refactored Code:**
```javascript
export function validateScheduleSelection(selectedDays, listing) {
  // Early return for empty selection
  if (!selectedDays || selectedDays.length === 0) {
    return {
      valid: false,
      errors: ['Please select at least one day'],
      warnings: [],
      showTutorial: false,
      nightsCount: 0,
      isContiguous: false
    };
  }

  const isContiguous = isContiguousSelection(selectedDays);

  // Early return for non-contiguous
  if (!isContiguous) {
    return {
      valid: false,
      errors: ['Please check for contiguous nights to continue with your proposal'],
      warnings: [],
      showTutorial: true,
      nightsCount: selectedDays.length,
      isContiguous: false
    };
  }

  // Build warnings declaratively
  const warnings = [
    listing['Minimum Nights'] && selectedDays.length < listing['Minimum Nights'] &&
      `Host prefers at least ${listing['Minimum Nights']} nights per week`,
    listing['Maximum Nights'] && selectedDays.length > listing['Maximum Nights'] &&
      `Host prefers at most ${listing['Maximum Nights']} nights per week`,
  ].filter(Boolean);

  // Check unavailable days
  const unavailableDays = listing['Days Not Available'] || [];
  const hasUnavailableSelected = Array.isArray(unavailableDays) &&
    selectedDays.some(day => unavailableDays.includes(DAY_NAMES[day]));

  const errors = hasUnavailableSelected
    ? ['Some selected days are not available for this listing']
    : [];

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    showTutorial: false,
    nightsCount: selectedDays.length,
    isContiguous: true
  };
}
```

**Why This Matters:**
Returning new objects at each decision point eliminates all mutation. The declarative warnings array construction makes all possible warnings visible at once. Early returns for validation failures are a common FP pattern.

**Testing:**
- [ ] Test empty selection returns correct error
- [ ] Test non-contiguous selection triggers tutorial
- [ ] Verify min/max night warnings appear correctly
- [ ] Test unavailable day detection

---

## CHUNK 8: Replace .push() calls in validateMoveInDate (availabilityValidation.js:271-305)

**File:** app/src/lib/availabilityValidation.js
**Line:** 271, 280, 287, 294, 305
**Violation:** MUTATING_METHOD - .push() calls in validation function
**Severity:** High

**Current Code:**
```javascript
export function validateMoveInDate(moveInDate, listing, selectedDays) {
  const result = {
    valid: true,
    errors: []
  };

  if (!moveInDate) {
    result.valid = false;
    result.errors.push('Please select a move-in date');
    return result;
  }
  // ... more push calls
}
```

**Refactored Code:**
```javascript
export function validateMoveInDate(moveInDate, listing, selectedDays) {
  // Early return for missing date
  if (!moveInDate) {
    return { valid: false, errors: ['Please select a move-in date'] };
  }

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Validate date is not in past
  if (moveInDate < today) {
    return { valid: false, errors: ['Move-in date cannot be in the past'] };
  }

  // Validate date is within range
  if (!isDateInRange(moveInDate, listing['First Available'], listing['Last Available'])) {
    return { valid: false, errors: ['Move-in date is outside available range'] };
  }

  // Validate date is not blocked
  if (isDateBlocked(moveInDate, listing['Dates - Blocked'])) {
    return { valid: false, errors: ['Selected move-in date is not available'] };
  }

  // Validate day of week matches schedule
  if (selectedDays?.length > 0) {
    const { checkInDay } = calculateCheckInOutDays(selectedDays);
    const moveInDayOfWeek = moveInDate.getDay();

    if (checkInDay !== null && moveInDayOfWeek !== checkInDay) {
      return {
        valid: false,
        errors: [`Move-in date must be on a ${DAY_NAMES[checkInDay]} based on your selected schedule`]
      };
    }
  }

  return { valid: true, errors: [] };
}
```

**Why This Matters:**
Early returns with explicit error objects are cleaner than accumulating errors in a mutable array. Each validation check has a single responsibility and returns immediately on failure.

**Testing:**
- [ ] Test null/undefined moveInDate returns error
- [ ] Test past date validation
- [ ] Test date range validation
- [ ] Test blocked date detection
- [ ] Verify check-in day alignment

---

## CHUNK 9: Replace .push() in prepareListingSubmission.ts:92-100

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Line:** 92-100
**Violation:** MUTATING_METHOD - Building array with conditional .push() calls
**Severity:** High

**Current Code:**
```typescript
function transformAvailableNights(
  nights: ListingFormData['leaseStyles']['availableNights']
): string[] {
  if (!nights) return [];

  const result: string[] = [];
  if (nights.sunday) result.push('sunday');
  if (nights.monday) result.push('monday');
  if (nights.tuesday) result.push('tuesday');
  if (nights.wednesday) result.push('wednesday');
  if (nights.thursday) result.push('thursday');
  if (nights.friday) result.push('friday');
  if (nights.saturday) result.push('saturday');

  return result;
}
```

**Refactored Code:**
```typescript
function transformAvailableNights(
  nights: ListingFormData['leaseStyles']['availableNights']
): string[] {
  if (!nights) return [];

  const dayMapping: Array<[keyof typeof nights, string]> = [
    ['sunday', 'sunday'],
    ['monday', 'monday'],
    ['tuesday', 'tuesday'],
    ['wednesday', 'wednesday'],
    ['thursday', 'thursday'],
    ['friday', 'friday'],
    ['saturday', 'saturday'],
  ];

  return dayMapping
    .filter(([key]) => nights[key])
    .map(([, value]) => value);
}
```

**Why This Matters:**
Data-driven transformation is more maintainable than imperative conditionals. If day order changes or new days are added, you modify the data structure, not the logic.

**Testing:**
- [ ] Test with all nights selected
- [ ] Test with no nights selected (null input)
- [ ] Test with partial selection (Mon, Wed, Fri)
- [ ] Verify output order is correct

---

## CHUNK 10: Replace .push() in validateBubblePayload (prepareListingSubmission.ts:267-289)

**File:** app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts
**Line:** 267-289
**Violation:** MUTATING_METHOD - Building errors array with .push()
**Severity:** High

**Current Code:**
```typescript
export function validateBubblePayload(
  payload: BubbleListingPayload
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];

  // Required fields
  if (!payload.Name) errors.push('Name is required');
  if (!payload['Type of Space']) errors.push('Type of Space is required');
  if (!payload.Address) errors.push('Address is required');
  if (!payload['Rental Type']) errors.push('Rental Type is required');

  // Pricing validation based on rental type
  if (payload['Rental Type'] === 'Monthly' && !payload['Monthly Compensation']) {
    errors.push('Monthly Compensation is required for Monthly rentals');
  }
  // ... more push calls
}
```

**Refactored Code:**
```typescript
export function validateBubblePayload(
  payload: BubbleListingPayload
): { valid: boolean; errors: string[] } {
  const errors = [
    // Required fields
    !payload.Name && 'Name is required',
    !payload['Type of Space'] && 'Type of Space is required',
    !payload.Address && 'Address is required',
    !payload['Rental Type'] && 'Rental Type is required',

    // Pricing validation based on rental type
    payload['Rental Type'] === 'Monthly' && !payload['Monthly Compensation'] &&
      'Monthly Compensation is required for Monthly rentals',
    payload['Rental Type'] === 'Weekly' && !payload['Weekly Compensation'] &&
      'Weekly Compensation is required for Weekly rentals',
    payload['Rental Type'] === 'Nightly' && !payload['Price 1 night selected'] &&
      'Nightly pricing is required for Nightly rentals',

    // Damage deposit minimum
    payload['Damage Deposit'] < 500 && 'Damage Deposit must be at least $500',
  ].filter(Boolean) as string[];

  return {
    valid: errors.length === 0,
    errors,
  };
}
```

**Why This Matters:**
Declarative error collection shows all validation rules in one place. The pattern `condition && errorMessage` is a concise way to conditionally include errors.

**Testing:**
- [ ] Test missing required fields produce errors
- [ ] Test rental type-specific validations
- [ ] Test damage deposit minimum validation
- [ ] Verify empty payload produces multiple errors

---

## CHUNK 11: Replace for-loop in getMenuItems (LoggedInAvatar.jsx:169-332)

**File:** app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx
**Line:** 169-332
**Violation:** MUTATING_METHOD - Building menu items array with conditional .push() calls
**Severity:** High

**Current Code:**
```javascript
const getMenuItems = () => {
  const items = [];

  // 1. My Profile - ALWAYS visible
  if (menuVisibility.myProfile) {
    items.push({
      id: 'profile',
      label: 'My Profile',
      icon: '/assets/icons/user-purple.svg',
      path: `/account-profile/${user.id}`,
    });
  }

  // 2. My Proposals - Visible for all users
  if (menuVisibility.myProposals) {
    items.push({
      id: 'proposals',
      // ...
    });
  }
  // ... 10 more conditional pushes
  return items;
};
```

**Refactored Code:**
```javascript
const getMenuItems = () => {
  const allMenuItems = [
    // 1. My Profile - ALWAYS visible
    menuVisibility.myProfile && {
      id: 'profile',
      label: 'My Profile',
      icon: '/assets/icons/user-purple.svg',
      path: `/account-profile/${user.id}`,
    },

    // 2. My Proposals - Visible for all users
    menuVisibility.myProposals && {
      id: 'proposals',
      label: 'My Proposals',
      icon: '/assets/icons/file-text-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? '/guest-proposals'
        : '/host-proposals',
      badgeCount: effectiveProposalsCount,
      badgeColor: 'purple',
    },

    // 3. Proposals Suggested - GUEST only
    menuVisibility.myProposalsSuggested && {
      id: 'proposals-suggested',
      label: 'Proposals Suggested',
      icon: '/assets/icons/file-text-purple.svg',
      path: '/proposals-suggested',
    },

    // 4. My Listings - HOST and TRIAL_HOST only
    menuVisibility.myListings && {
      id: 'listings',
      label: 'My Listings',
      icon: '/assets/icons/list-purple.svg',
      path: effectiveListingsCount === 1 && effectiveFirstListingId
        ? `/listing-dashboard?id=${effectiveFirstListingId}`
        : '/host-overview',
      badgeCount: effectiveListingsCount,
      badgeColor: 'purple',
    },

    // 5. Virtual Meetings
    menuVisibility.virtualMeetings && {
      id: 'virtual-meetings',
      label: 'Virtual Meetings',
      icon: '/assets/icons/video-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? `/guest-proposals${effectiveVirtualMeetingsCount > 0 ? '?scrollTo=virtual-meetings' : '?highlightVMButton=true'}`
        : `/host-proposals${effectiveVirtualMeetingsCount > 0 ? '?scrollTo=virtual-meetings' : '?highlightVMButton=true'}`,
      badgeCount: effectiveVirtualMeetingsCount,
      badgeColor: 'purple',
    },

    // 6. House Manuals & Visits
    menuVisibility.houseManualsAndVisits && {
      id: 'house-manuals',
      label: 'House manuals & Visits',
      icon: '/assets/icons/book-open-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? '/guest-house-manual'
        : effectiveHouseManualsCount === 1
          ? '/host-house-manual'
          : '/host-overview',
    },

    // 7. My Leases
    menuVisibility.myLeases && {
      id: 'leases',
      label: 'My Leases',
      icon: '/assets/icons/key-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.GUEST
        ? '/guest-leases'
        : '/host-leases',
      badgeCount: effectiveLeasesCount,
      badgeColor: 'purple',
    },

    // 8. My Favorite Listings - GUEST only
    menuVisibility.myFavoriteListings && {
      id: 'favorites',
      label: 'My Favorite Listings',
      icon: '/assets/icons/heart-purple.svg',
      path: '/favorite-listings',
      badgeCount: effectiveFavoritesCount,
      badgeColor: 'purple',
    },

    // 9. Messages
    menuVisibility.messages && {
      id: 'messages',
      label: 'Messages',
      icon: '/assets/icons/message-circle-purple.svg',
      path: '/messages',
      badgeCount: effectiveUnreadMessagesCount,
      badgeColor: 'red',
    },

    // 10. Rental Application
    menuVisibility.rentalApplication && {
      id: 'rental-application',
      label: 'Rental Application',
      icon: '/assets/icons/clipboard-purple.svg',
      path: effectiveUserType === NORMALIZED_USER_TYPES.HOST
        ? '/account'
        : `/account-profile/${user.id}?section=rental-application`,
    },

    // 11. Reviews Manager
    menuVisibility.reviewsManager && {
      id: 'reviews',
      label: 'Reviews Manager',
      icon: '/assets/icons/star-purple.svg',
      path: '/reviews-overview',
    },

    // 12. Referral
    menuVisibility.referral && {
      id: 'referral',
      label: 'Referral',
      icon: '/assets/icons/gift-purple.svg',
      action: () => setShowReferralModal(true),
    },
  ];

  return allMenuItems.filter(Boolean);
};
```

**Why This Matters:**
Declarative array construction shows all menu items at once. Adding/removing items only requires changing the data, not the control flow. `.filter(Boolean)` cleanly removes items where visibility is false.

**Testing:**
- [ ] Test HOST user sees correct menu items
- [ ] Test GUEST user sees correct menu items
- [ ] Verify badge counts display correctly
- [ ] Test referral modal opens on click

---

## CHUNK 12: Replace .push() in AvailabilitySection.jsx:32-51 (getDatesBetween)

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Line:** 32-51
**Violation:** MUTATING_METHOD + IMPERATIVE_LOOP - while loop with .push()
**Severity:** High

**Current Code:**
```javascript
const getDatesBetween = (startDate, endDate) => {
  const dates = [];
  let start = new Date(startDate);
  let end = new Date(endDate);

  // Ensure start is before end
  if (start > end) {
    const temp = start;
    start = end;
    end = temp;
  }

  const current = new Date(start);
  while (current <= end) {
    dates.push(formatDateKey(current));
    current.setDate(current.getDate() + 1);
  }

  return dates;
};
```

**Refactored Code:**
```javascript
const getDatesBetween = (startDate, endDate) => {
  const start = new Date(Math.min(new Date(startDate), new Date(endDate)));
  const end = new Date(Math.max(new Date(startDate), new Date(endDate)));

  const dayCount = Math.floor((end - start) / (1000 * 60 * 60 * 24)) + 1;

  return Array.from({ length: dayCount }, (_, i) => {
    const date = new Date(start);
    date.setDate(start.getDate() + i);
    return formatDateKey(date);
  });
};
```

**Why This Matters:**
`Array.from()` with a length and mapper function is the FP way to generate sequences. The `Math.min/max` pattern eliminates mutable temp variable swapping.

**Testing:**
- [ ] Test date range generation (Jan 1 to Jan 5)
- [ ] Test reversed inputs (Jan 5 to Jan 1) produce same result
- [ ] Test single day range (Jan 1 to Jan 1)
- [ ] Verify blocked dates functionality works

---

## CHUNK 13: Replace for-loops in AvailabilitySection.jsx:96-141 (getCalendarDays)

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Line:** 96-141
**Violation:** IMPERATIVE_LOOP + MUTATING_METHOD - Multiple for loops with .push()
**Severity:** High

**Current Code:**
```javascript
const getCalendarDays = () => {
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();
  // ...
  const days = [];

  // Previous month padding
  for (let i = startPadding - 1; i >= 0; i--) {
    // ...
    days.push({ day: dayNum, isCurrentMonth: false, isPast: date < today, date });
  }

  // Current month days
  for (let i = 1; i <= daysInMonth; i++) {
    // ...
    days.push({ day: i, isCurrentMonth: true, isPast: date < today, date });
  }

  // Next month padding
  for (let i = 1; i <= remaining; i++) {
    // ...
    days.push({ day: i, isCurrentMonth: false, isPast: false, date });
  }

  return days;
};
```

**Refactored Code:**
```javascript
const getCalendarDays = () => {
  const year = currentDate.getFullYear();
  const month = currentDate.getMonth();

  const firstDay = new Date(year, month, 1);
  const lastDay = new Date(year, month + 1, 0);
  const startPadding = firstDay.getDay();
  const daysInMonth = lastDay.getDate();

  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Previous month days
  const prevMonth = new Date(year, month, 0);
  const prevMonthDays = Array.from({ length: startPadding }, (_, i) => {
    const dayNum = prevMonth.getDate() - startPadding + 1 + i;
    const date = new Date(prevMonth.getFullYear(), prevMonth.getMonth(), dayNum);
    return { day: dayNum, isCurrentMonth: false, isPast: date < today, date };
  });

  // Current month days
  const currentMonthDays = Array.from({ length: daysInMonth }, (_, i) => {
    const dayNum = i + 1;
    const date = new Date(year, month, dayNum);
    return { day: dayNum, isCurrentMonth: true, isPast: date < today, date };
  });

  // Next month padding
  const remaining = 42 - startPadding - daysInMonth;
  const nextMonth = month === 11 ? 0 : month + 1;
  const nextYear = month === 11 ? year + 1 : year;
  const nextMonthDays = Array.from({ length: remaining }, (_, i) => {
    const dayNum = i + 1;
    const date = new Date(nextYear, nextMonth, dayNum);
    return { day: dayNum, isCurrentMonth: false, isPast: false, date };
  });

  return [...prevMonthDays, ...currentMonthDays, ...nextMonthDays];
};
```

**Why This Matters:**
Each calendar section is built independently with `Array.from()`, then composed with spread operator. This separation makes each section's logic clear and independently testable.

**Testing:**
- [ ] Verify calendar renders 42 days (6 weeks)
- [ ] Test previous month days show correctly
- [ ] Test current month days are marked correctly
- [ ] Verify past dates are identified

---

## CHUNK 14: Replace .sort() with toSorted() in allFutureBlockedDates (AvailabilitySection.jsx:240-243)

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Line:** 240-243
**Violation:** MUTATING_METHOD - .sort() mutates original array
**Severity:** High

**Current Code:**
```javascript
const allFutureBlockedDates = useMemo(() => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayKey = formatDateKey(today);

  return blockedDates
    .filter((dateKey) => dateKey >= todayKey)
    .sort();
}, [blockedDates]);
```

**Refactored Code:**
```javascript
const allFutureBlockedDates = useMemo(() => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayKey = formatDateKey(today);

  return blockedDates
    .filter((dateKey) => dateKey >= todayKey)
    .toSorted();
}, [blockedDates]);
```

**Why This Matters:**
While `.filter()` already creates a new array so `.sort()` doesn't mutate the original, using `.toSorted()` makes the immutable intent explicit and prevents bugs if code is refactored.

**Testing:**
- [ ] Verify future dates are sorted chronologically
- [ ] Check past dates are filtered out
- [ ] Test with empty blocked dates array

---

## CHUNK 15: Replace .sort().reverse() with toSorted().toReversed() (AvailabilitySection.jsx:250-255)

**File:** app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx
**Line:** 250-255
**Violation:** MUTATING_METHOD - .sort() and .reverse() mutate arrays
**Severity:** High

**Current Code:**
```javascript
const pastBlockedDates = useMemo(() => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayKey = formatDateKey(today);

  return blockedDates
    .filter((dateKey) => dateKey < todayKey)
    .sort()
    .reverse(); // Most recent past dates first
}, [blockedDates]);
```

**Refactored Code:**
```javascript
const pastBlockedDates = useMemo(() => {
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  const todayKey = formatDateKey(today);

  return blockedDates
    .filter((dateKey) => dateKey < todayKey)
    .toSorted()
    .toReversed(); // Most recent past dates first
}, [blockedDates]);
```

**Why This Matters:**
`.toSorted()` and `.toReversed()` are the ES2023 immutable alternatives to `.sort()` and `.reverse()`. Using them signals immutable intent clearly.

**Testing:**
- [ ] Verify past dates are sorted in reverse chronological order
- [ ] Check future dates are filtered out
- [ ] Test display of past blocked dates section

---

## CHUNK 16: Replace .push() in generate-redirects.js:147, 153, 156, 161

**File:** app/scripts/generate-redirects.js
**Line:** 147, 153, 156, 161
**Violation:** MUTATING_METHOD - Building errors array with .push()
**Severity:** High

**Current Code:**
```javascript
function validateRoutes() {
  const errors = [];
  const paths = new Set();

  for (const route of routes) {
    // Check for duplicate paths
    if (paths.has(route.path)) {
      errors.push(`Duplicate path: ${route.path}`);
    }
    paths.add(route.path);

    // Check required fields
    if (!route.path) {
      errors.push(`Route missing path`);
    }
    if (!route.file) {
      errors.push(`Route ${route.path} missing file`);
    }

    // Check cloudflareInternal requires internalName
    if (route.cloudflareInternal && !route.internalName) {
      errors.push(`Route ${route.path} has cloudflareInternal but no internalName`);
    }
  }
  // ...
}
```

**Refactored Code:**
```javascript
function validateRoutes() {
  // Track seen paths for duplicate detection
  const seenPaths = new Set();

  const errors = routes.flatMap(route => {
    const routeErrors = [
      // Check for duplicate paths
      seenPaths.has(route.path) && `Duplicate path: ${route.path}`,
      // Check required fields
      !route.path && `Route missing path`,
      !route.file && `Route ${route.path} missing file`,
      // Check cloudflareInternal requires internalName
      route.cloudflareInternal && !route.internalName &&
        `Route ${route.path} has cloudflareInternal but no internalName`,
    ].filter(Boolean);

    // Side effect: track this path (only after checking for duplicate)
    if (route.path) seenPaths.add(route.path);

    return routeErrors;
  });

  if (errors.length > 0) {
    console.error('❌ Route Registry validation failed:');
    errors.forEach(e => console.error(`   - ${e}`));
    process.exit(1);
  }

  console.log('✅ Route Registry validation passed');
  console.log(`   ${routes.length} routes defined`);
}
```

**Why This Matters:**
`flatMap` allows collecting multiple errors per route while keeping the logic declarative. Note: The Set tracking is a necessary side effect for duplicate detection, but it's isolated to a single line.

**Testing:**
- [ ] Run `bun run generate-routes` with valid routes
- [ ] Test with duplicate path (should fail)
- [ ] Test with missing file (should fail)
- [ ] Test cloudflareInternal without internalName (should fail)

---

## CHUNK 17: Replace for-loop in validateRoutes (generate-redirects.js:144)

**File:** app/scripts/generate-redirects.js
**Line:** 144
**Violation:** IMPERATIVE_LOOP - for...of loop iterating routes
**Severity:** High

**Current Code:**
```javascript
for (const route of routes) {
  // validation logic
}
```

**Refactored Code:**
(Already addressed in CHUNK 16 - the flatMap refactoring eliminates this for loop)

**Testing:**
- [ ] See CHUNK 16 testing

---

## CHUNK 18: Replace .push() in counterofferWorkflow.js:153-198 (getTermsComparison)

**File:** app/src/logic/workflows/proposals/counterofferWorkflow.js
**Line:** 153-198
**Violation:** MUTATING_METHOD - Building changes array with conditional .push()
**Severity:** High

**Current Code:**
```javascript
// Build list of changes
const changes = [];

if (originalTerms.totalPrice !== counterofferTerms.totalPrice) {
  changes.push({
    field: 'totalPrice',
    label: 'Total Price',
    original: originalTerms.totalPrice,
    modified: counterofferTerms.totalPrice
  });
}

if (originalTerms.nightlyPrice !== counterofferTerms.nightlyPrice) {
  changes.push({
    field: 'nightlyPrice',
    label: 'Nightly Rate',
    original: originalTerms.nightlyPrice,
    modified: counterofferTerms.nightlyPrice
  });
}
// ... more conditionals
```

**Refactored Code:**
```javascript
// Build list of changes declaratively
const fieldMappings = [
  { field: 'totalPrice', label: 'Total Price' },
  { field: 'nightlyPrice', label: 'Nightly Rate' },
  { field: 'reservationWeeks', label: 'Duration (Weeks)' },
  { field: 'nightsPerWeek', label: 'Nights per Week' },
];

const scalarChanges = fieldMappings
  .filter(({ field }) => originalTerms[field] !== counterofferTerms[field])
  .map(({ field, label }) => ({
    field,
    label,
    original: originalTerms[field],
    modified: counterofferTerms[field],
  }));

// Special handling for daysSelected (array comparison)
const daysSelectedChanged =
  JSON.stringify(originalTerms.daysSelected) !== JSON.stringify(counterofferTerms.daysSelected);

const changes = daysSelectedChanged
  ? [
      ...scalarChanges,
      {
        field: 'daysSelected',
        label: 'Weekly Schedule',
        original: originalTerms.daysSelected,
        modified: counterofferTerms.daysSelected,
      },
    ]
  : scalarChanges;

return {
  originalTerms,
  counterofferTerms,
  changes,
  hasChanges: changes.length > 0
};
```

**Why This Matters:**
Data-driven change detection makes adding new fields trivial - just add to the `fieldMappings` array. The special case for arrays is handled separately but still declaratively.

**Testing:**
- [ ] Test counteroffer with price change only
- [ ] Test counteroffer with schedule change only
- [ ] Test counteroffer with multiple changes
- [ ] Verify no changes returns empty array

---

## CHUNK 19: Replace .sort() with toSorted() in listingDataFetcher.js:201

**File:** app/src/lib/listingDataFetcher.js
**Line:** 201
**Violation:** MUTATING_METHOD - .sort() mutates array
**Severity:** High

**Current Code:**
```javascript
sortedPhotos = sortedPhotos.sort((a, b) => {
  // sorting logic
});
```

**Refactored Code:**
```javascript
sortedPhotos = sortedPhotos.toSorted((a, b) => {
  // sorting logic
});
```

**Why This Matters:**
`.toSorted()` creates a new sorted array without mutating the original. This is especially important when the source data might be referenced elsewhere.

**Testing:**
- [ ] Verify photos are sorted correctly
- [ ] Check original photo array is unchanged
- [ ] Test with empty photos array

---

## CHUNK 20: Replace .push() in dataLookups.js:562, 592, 609

**File:** app/src/lib/dataLookups.js
**Line:** 562, 592, 609
**Violation:** MUTATING_METHOD - Building arrays with .push()
**Severity:** High

**Note:** These are in lookup functions that build result arrays. The pattern is similar to other validation/collection functions.

**General Refactoring Pattern:**
```javascript
// Before: for loop with push
const results = [];
for (const item of items) {
  if (condition(item)) {
    results.push(transform(item));
  }
}

// After: filter and map
const results = items
  .filter(condition)
  .map(transform);
```

**Testing:**
- [ ] Test getCancellationPolicies returns correct policies
- [ ] Test getReasonsList returns sorted reasons
- [ ] Verify display order is maintained

---

## CHUNK 21: Replace while loops in auth.js:563, 786

**File:** app/src/lib/auth.js
**Line:** 563, 786
**Violation:** IMPERATIVE_LOOP - while loops for retry logic
**Severity:** High

**Note:** These while loops are for authentication retry logic with async operations. While the loop pattern is imperative, this is a case where FP purism may not apply - retry logic with side effects (API calls) is inherently imperative.

**Recommended Approach:**
Consider extracting to a reusable `retry` utility that encapsulates the imperative logic:

```javascript
// Create a reusable retry utility
const retry = async (fn, maxAttempts, delayMs) => {
  for (let attempt = 0; attempt < maxAttempts; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxAttempts - 1) throw error;
      await new Promise(resolve => setTimeout(resolve, delayMs));
    }
  }
};

// Usage
const result = await retry(
  () => verifySession(),
  maxVerifyAttempts,
  500
);
```

**Testing:**
- [ ] Test successful verification on first attempt
- [ ] Test retry after transient failure
- [ ] Test max attempts reached

---

## CHUNK 22-30: Additional .push() violations in form/UI components

The remaining violations follow similar patterns across these files:
- `src/islands/pages/SelfListingPage/sections/Section1SpaceSnapshot.tsx`
- `src/islands/pages/SelfListingPage/sections/Section5Rules.tsx`
- `src/islands/shared/SearchScheduleSelector.jsx`
- `src/islands/shared/HostScheduleSelector/utils.js`
- `src/lib/photoUpload.js`
- `src/lib/supabaseUtils.js`

Each follows the same refactoring pattern:

**Before:**
```javascript
const results = [];
items.forEach(item => {
  if (condition) {
    results.push(transform(item));
  }
});
```

**After:**
```javascript
const results = items
  .filter(item => condition)
  .map(item => transform(item));
```

Or for accumulation:
```javascript
// Before
let total = 0;
for (const item of items) {
  total += item.value;
}

// After
const total = items.reduce((sum, item) => sum + item.value, 0);
```

---

## Implementation Priority

### Phase 1: Core Logic (High Impact, Foundation)
1. CHUNK 3: listingLocalStore.ts validateForSubmission
2. CHUNK 7: availabilityValidation.js validateScheduleSelection
3. CHUNK 8: availabilityValidation.js validateMoveInDate
4. CHUNK 10: prepareListingSubmission.ts validateBubblePayload

### Phase 2: Data Transformation Functions
5. CHUNK 4-6: availabilityValidation.js loop refactoring
6. CHUNK 9: prepareListingSubmission.ts transformAvailableNights
7. CHUNK 18: counterofferWorkflow.js getTermsComparison
8. CHUNK 16: generate-redirects.js validateRoutes

### Phase 3: UI Components
9. CHUNK 11: LoggedInAvatar.jsx getMenuItems
10. CHUNK 12-15: AvailabilitySection.jsx refactoring

### Phase 4: Remaining Violations
11. CHUNK 1-2: listingLocalStore.ts error handling
12. CHUNK 19-21: Miscellaneous file cleanups

---

## References

- **Violations JSON:** `agents/fp_audit_violations.json`
- **FP Guide:** `.claude/skills/functional-code/fp-guide.md`
- **FP Bible:** `.claude/Documentation/Architecture/The Functional Programming Bible.md`

---

## File References for Plan Execution

These files need to be read during implementation:
- `app/src/islands/pages/SelfListingPage/store/listingLocalStore.ts`
- `app/src/lib/availabilityValidation.js`
- `app/src/islands/pages/SelfListingPage/store/prepareListingSubmission.ts`
- `app/src/islands/shared/LoggedInAvatar/LoggedInAvatar.jsx`
- `app/src/islands/pages/ListingDashboardPage/components/AvailabilitySection.jsx`
- `app/src/logic/workflows/proposals/counterofferWorkflow.js`
- `app/scripts/generate-redirects.js`
- `app/src/lib/dataLookups.js`
- `app/src/lib/auth.js`
- `app/src/lib/listingDataFetcher.js`
