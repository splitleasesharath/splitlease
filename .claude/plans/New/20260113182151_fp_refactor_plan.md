# Functional Programming Refactoring Plan

Date: 2026-01-13
Target: agents/20260113182151_fp_audit_violations.json
Severity Filter: high

~~~~~

## CHUNK 1: Replace imperative loop in availabilityValidation.js:59

**File:** app/src/lib/availabilityValidation.js
**Line:** 59
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /self-listing, /edit-listing-details

**Current Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = [];
    for (let i = minNotSelected; i <= maxNotSelected; i++) {
      expectedNotSelected.push(i);
    }

    // If not-selected days are contiguous, then selected days wrap around properly
```

**Refactored Code:**
```javascript
    // Generate expected contiguous range for not-selected days
    const expectedNotSelected = Array.from(
      { length: maxNotSelected - minNotSelected + 1 },
      (_, i) => minNotSelected + i
    );

    // If not-selected days are contiguous, then selected days wrap around properly
```

**Why This Matters:**
Imperative loops with mutation (`.push`) are harder to read and reason about. `Array.from` clearly declares the intent to create an array of a specific range.

**Testing:**
- [ ] Run unit tests for `isContiguousSelection`
- [ ] Verify wrap-around schedule selection (e.g. Fri-Mon) works correctly

~~~~~

## CHUNK 2: Replace mutating sort in availabilityValidation.js:91

**File:** app/src/lib/availabilityValidation.js
**Line:** 91
**Violation:** MUTATING_METHOD - Using mutating array sort/reverse
**Severity:** High

**Expected Affected Pages:** /self-listing, /edit-listing-details

**Current Code:**
```javascript
  const sorted = [...selectedDays].sort((a, b) => a - b);

  // Handle wrap-around case (e.g., Fri, Sat, Sun, Mon)
  const hasZero = sorted.includes(0);
```

**Refactored Code:**
```javascript
  const sorted = selectedDays.toSorted((a, b) => a - b);

  // Handle wrap-around case (e.g., Fri, Sat, Sun, Mon)
  const hasZero = sorted.includes(0);
```

**Why This Matters:**
`toSorted()` is the modern, immutable alternative to `.sort()`. While `[...arr].sort()` is safe, `toSorted()` is more semantic and prevents accidental mutation if the spread is missed.

**Testing:**
- [ ] Run unit tests for `calculateCheckInOutDays`
- [ ] Verify check-in/out calculation for standard and wrapped schedules

~~~~~

## CHUNK 3: Replace imperative loop in availabilityValidation.js:100

**File:** app/src/lib/availabilityValidation.js
**Line:** 100
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /self-listing, /edit-listing-details

**Current Code:**
```javascript
    // Find gap to determine actual start/end
    let gapIndex = -1;
    for (let i = 1; i < sorted.length; i++) {
      if (sorted[i] !== sorted[i - 1] + 1) {
        gapIndex = i;
        break;
      }
    }

    if (gapIndex !== -1) {
```

**Refactored Code:**
```javascript
    // Find gap to determine actual start/end
    const gapIndex = sorted.findIndex((day, i) => i > 0 && day !== sorted[i - 1] + 1);

    if (gapIndex !== -1) {
```

**Why This Matters:**
`findIndex` is a declarative method specifically designed for this purpose. It eliminates the need for a mutable `gapIndex` variable and manual loop control.

**Testing:**
- [ ] Run unit tests for `calculateCheckInOutDays`
- [ ] Verify check-in/out calculation for wrapped schedules (e.g. Fri, Sat, Sun, Mon)

~~~~~

## CHUNK 4: Refactor validateScheduleSelection to avoid mutation in availabilityValidation.js:160

**File:** app/src/lib/availabilityValidation.js
**Line:** 160
**Violation:** MUTATING_METHOD - Using mutating array method
**Severity:** High

**Expected Affected Pages:** /self-listing, /edit-listing-details

**Current Code:**
```javascript
export function validateScheduleSelection(selectedDays, listing) {
  const result = {
    valid: true,
    errors: [],
    warnings: [],
    showTutorial: false,
    nightsCount: selectedDays.length,
    isContiguous: false
  };

  // Check if days are selected
  if (!selectedDays || selectedDays.length === 0) {
    result.valid = false;
    result.errors.push('Please select at least one day');
    return result;
  }

  // Check contiguous requirement (CRITICAL)
  result.isContiguous = isContiguousSelection(selectedDays);
  if (!result.isContiguous) {
    result.valid = false;
    result.showTutorial = true;
    result.errors.push('Please check for contiguous nights to continue with your proposal');
    return result;
  }

  // Check against minimum nights
  if (listing['Minimum Nights'] && selectedDays.length < listing['Minimum Nights']) {
    result.warnings.push(`Host prefers at least ${listing['Minimum Nights']} nights per week`);
  }

  // Check against maximum nights
  if (listing['Maximum Nights'] && selectedDays.length > listing['Maximum Nights']) {
    result.warnings.push(`Host prefers at most ${listing['Maximum Nights']} nights per week`);
  }

  // Check against Days Not Available
  if (listing['Days Not Available'] && Array.isArray(listing['Days Not Available'])) {
    const unavailableDays = listing['Days Not Available'];
    const unavailableSelected = selectedDays.filter(day => {
      const dayName = DAY_NAMES[day];
      return unavailableDays.includes(dayName);
    });

    if (unavailableSelected.length > 0) {
      result.valid = false;
      result.errors.push('Some selected days are not available for this listing');
    }
  }

  return result;
}
```

**Refactored Code:**
```javascript
export function validateScheduleSelection(selectedDays, listing) {
  // Check if days are selected
  if (!selectedDays || selectedDays.length === 0) {
    return {
      valid: false,
      errors: ['Please select at least one day'],
      warnings: [],
      showTutorial: false,
      nightsCount: 0,
      isContiguous: false
    };
  }

  const isContiguous = isContiguousSelection(selectedDays);
  
  if (!isContiguous) {
    return {
      valid: false,
      errors: ['Please check for contiguous nights to continue with your proposal'],
      warnings: [],
      showTutorial: true,
      nightsCount: selectedDays.length,
      isContiguous: false
    };
  }

  const warnings = [
    listing['Minimum Nights'] && selectedDays.length < listing['Minimum Nights']
      ? `Host prefers at least ${listing['Minimum Nights']} nights per week`
      : null,
    listing['Maximum Nights'] && selectedDays.length > listing['Maximum Nights']
      ? `Host prefers at most ${listing['Maximum Nights']} nights per week`
      : null
  ].filter(Boolean);

  const unavailableDays = listing['Days Not Available'];
  const hasUnavailableSelected = Array.isArray(unavailableDays) && selectedDays.some(day => 
    unavailableDays.includes(DAY_NAMES[day])
  );

  const errors = hasUnavailableSelected 
    ? ['Some selected days are not available for this listing'] 
    : [];

  return {
    valid: errors.length === 0,
    errors,
    warnings,
    showTutorial: false,
    nightsCount: selectedDays.length,
    isContiguous: true
  };
}
```

**Why This Matters:**
The original code mutated a `result` object throughout the function. The refactored version returns immutable objects and uses declarative checks (`filter(Boolean)`, `some`), making the data flow clear and predictable.

**Testing:**
- [ ] Run unit tests for `validateScheduleSelection`
- [ ] Verify validation errors appear correctly for empty selection, non-contiguous selection, and unavailable days

~~~~~

## CHUNK 5: Replace mutating push in listingService.js:335

**File:** app/src/lib/listingService.js
**Line:** 335
**Violation:** MUTATING_METHOD - Using mutating array method
**Severity:** High

**Expected Affected Pages:** /self-listing

**Current Code:**
```javascript
  // Add the new listing ID to the array
  const currentListings = userData.Listings || [];
  if (!currentListings.includes(listingId)) {
    currentListings.push(listingId);
  }

  // Update the user with the new Listings array
  const { error: updateError } = await supabase
    .from('user')
    .update({ Listings: currentListings })
    .eq('_id', userData._id);
```

**Refactored Code:**
```javascript
  // Add the new listing ID to the array
  const currentListings = userData.Listings || [];
  const updatedListings = currentListings.includes(listingId)
    ? currentListings
    : [...currentListings, listingId];

  // Update the user with the new Listings array
  const { error: updateError } = await supabase
    .from('user')
    .update({ Listings: updatedListings })
    .eq('_id', userData._id);
```

**Why This Matters:**
Mutating the array `currentListings` can lead to side effects if `userData` is reused elsewhere. Creating a new `updatedListings` array ensures immutability.

**Testing:**
- [ ] Create a new listing and verify it links to the user account
- [ ] Check if the `Listings` array in `user` table is updated correctly

~~~~~

## CHUNK 6: Replace imperative loop in listingService.js:766

**File:** app/src/lib/listingService.js
**Line:** 766
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /self-listing, /edit-listing-details

**Current Code:**
```javascript
  const result = [];
  // Maintain proper day order
  const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

  for (const day of dayOrder) {
    if (availableNights[day] && dayNameMapping[day]) {
      result.push(dayNameMapping[day]);
    }
  }

  return result;
```

**Refactored Code:**
```javascript
  // Maintain proper day order
  const dayOrder = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];

  return dayOrder
    .filter(day => availableNights[day] && dayNameMapping[day])
    .map(day => dayNameMapping[day]);
```

**Why This Matters:**
`filter` and `map` chain clearly expresses the transformation: "keep days that are available and mapped, then extract their names". This is more readable than an imperative loop with `push`.

**Testing:**
- [ ] Verify `mapAvailableNightsToNames` returns correct day names
- [ ] Check listing submission saves correct "Nights Available" string

~~~~~

## CHUNK 7: Replace imperative loop in listingService.js:982

**File:** app/src/lib/listingService.js
**Line:** 982
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /edit-listing-details

**Current Code:**
```javascript
function normalizeDatabaseColumns(formData) {
  // Map of common field names to their actual database column names
  // (handles leading/trailing spaces from Bubble sync)
  const columnNameMap = {
    'First Available': ' First Available', // DB column has leading space
    'Nights Available (List of Nights)': 'Nights Available (List of Nights) ', // DB column has trailing space
    'Not Found - Location - Address': 'Not Found - Location - Address ' // DB column has trailing space
  };

  const normalized = {};

  for (const [key, value] of Object.entries(formData)) {
    // Check if this key needs to be remapped
    if (columnNameMap[key]) {
      normalized[columnNameMap[key]] = value;
    } else {
      normalized[key] = value;
    }
  }

  return normalized;
}
```

**Refactored Code:**
```javascript
function normalizeDatabaseColumns(formData) {
  // Map of common field names to their actual database column names
  // (handles leading/trailing spaces from Bubble sync)
  const columnNameMap = {
    'First Available': ' First Available', // DB column has leading space
    'Nights Available (List of Nights)': 'Nights Available (List of Nights) ', // DB column has trailing space
    'Not Found - Location - Address': 'Not Found - Location - Address ' // DB column has trailing space
  };

  return Object.entries(formData).reduce((acc, [key, value]) => {
    const normalizedKey = columnNameMap[key] || key;
    return { ...acc, [normalizedKey]: value };
  }, {});
}
```

**Why This Matters:**
`reduce` is the standard functional way to transform an object. It avoids creating a mutable `normalized` object and incrementally modifying it.

**Testing:**
- [ ] Verify `normalizeDatabaseColumns` correctly remaps keys
- [ ] Test updating a listing with fields that have spaces in DB column names

~~~~~

## CHUNK 8: Replace imperative loop in listingService.js:1076

**File:** app/src/lib/listingService.js
**Line:** 1076
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /self-listing

**Current Code:**
```javascript
  const result = [];
  for (const [day, isSelected] of Object.entries(availableNights)) {
    if (isSelected && dayMapping[day] !== undefined) {
      result.push(dayMapping[day]);
    }
  }

  return result.sort((a, b) => a - b);
```

**Refactored Code:**
```javascript
  return Object.entries(availableNights)
    .filter(([day, isSelected]) => isSelected && dayMapping[day] !== undefined)
    .map(([day]) => dayMapping[day])
    .sort((a, b) => a - b);
```

**Why This Matters:**
Declarative chain `filter` -> `map` -> `sort` is more expressive than an imperative loop pushing to an array.

**Testing:**
- [ ] Verify `mapAvailableNightsToArray` returns correct array of integers
- [ ] Check listing submission saves correct "Days Available" array

~~~~~

## CHUNK 9: Replace imperative loop in listingService.js:1240

**File:** app/src/lib/listingService.js
**Line:** 1240
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /self-listing (Editing existing listing)

**Current Code:**
```javascript
  const result = {
    sunday: false,
    monday: false,
    tuesday: false,
    wednesday: false,
    thursday: false,
    friday: false,
    saturday: false,
  };

  if (Array.isArray(daysArray)) {
    for (const dayNum of daysArray) {
      const dayName = dayMapping[dayNum];
      if (dayName) {
        result[dayName] = true;
      }
    }
  }

  return result;
```

**Refactored Code:**
```javascript
  const result = {
    sunday: false,
    monday: false,
    tuesday: false,
    wednesday: false,
    thursday: false,
    friday: false,
    saturday: false,
  };

  if (Array.isArray(daysArray)) {
    return daysArray.reduce((acc, dayNum) => {
      const dayName = dayMapping[dayNum];
      if (dayName) {
        return { ...acc, [dayName]: true };
      }
      return acc;
    }, result);
  }

  return result;
```

**Why This Matters:**
Using `reduce` avoids mutating the `result` object inside a loop. It constructs the final state by applying updates for each day.

**Testing:**
- [ ] Verify `mapArrayToAvailableNights` correctly converts DB array to object
- [ ] Load an existing listing and check if available nights are pre-selected correctly

~~~~~

## CHUNK 10: Replace imperative loops in photoUpload.js:28

**File:** app/src/lib/photoUpload.js
**Line:** 28
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /self-listing

**Current Code:**
```javascript
function dataUrlToBlob(dataUrl) {
  const [header, base64Data] = dataUrl.split(',');
  const mimeMatch = header.match(/data:([^;]+)/);
  const mimeType = mimeMatch ? mimeMatch[1] : 'image/jpeg';

  const byteCharacters = atob(base64Data);
  const byteArrays = [];

  for (let offset = 0; offset < byteCharacters.length; offset += 512) {
    const slice = byteCharacters.slice(offset, offset + 512);
    const byteNumbers = new Array(slice.length);

    for (let i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    byteArrays.push(new Uint8Array(byteNumbers));
  }

  return new Blob(byteArrays, { type: mimeType });
}
```

**Refactored Code:**
```javascript
function dataUrlToBlob(dataUrl) {
  const [header, base64Data] = dataUrl.split(',');
  const mimeMatch = header.match(/data:([^;]+)/);
  const mimeType = mimeMatch ? mimeMatch[1] : 'image/jpeg';

  const byteCharacters = atob(base64Data);
  
  // Create chunks of 512 bytes
  const chunkCount = Math.ceil(byteCharacters.length / 512);
  const byteArrays = Array.from({ length: chunkCount }, (_, i) => {
    const offset = i * 512;
    const slice = byteCharacters.slice(offset, offset + 512);
    
    const byteNumbers = new Uint8Array(slice.length);
    for (let j = 0; j < slice.length; j++) {
      byteNumbers[j] = slice.charCodeAt(j);
    }
    return byteNumbers;
  });

  return new Blob(byteArrays, { type: mimeType });
}
```

**Why This Matters:**
Refactoring the outer loop to `Array.from` makes the chunking logic declarative. The inner loop for `charCodeAt` is kept for performance as `map` on potentially large strings/arrays can be slower, but the overall structure is improved.

**Testing:**
- [ ] Verify photo upload works for large images
- [ ] Check if Blob created has correct MIME type and size

~~~~~

## CHUNK 11: Replace imperative loop in photoUpload.js:164

**File:** app/src/lib/photoUpload.js
**Line:** 164
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /self-listing

**Current Code:**
```javascript
export async function uploadPhotos(photos, listingId) {
  if (!photos || photos.length === 0) {
    console.log('[PhotoUpload] No photos to upload');
    return [];
  }

  console.log(`[PhotoUpload] Starting upload of ${photos.length} photos for listing ${listingId}`);

  const uploadedPhotos = [];

  for (let i = 0; i < photos.length; i++) {
    const photo = photos[i];

    try {
      const result = await uploadPhoto(photo, listingId, i);

      uploadedPhotos.push({
        id: photo.id || `photo_${i}_${Date.now()}`,
        url: result.url,
        Photo: result.url, // For compatibility with listing display format
        'Photo (thumbnail)': result.url, // Use same URL for thumbnail
        storagePath: result.path,
        caption: photo.caption || '',
        displayOrder: photo.displayOrder ?? i,
        SortOrder: photo.displayOrder ?? i,
        toggleMainPhoto: i === 0
      });
    } catch (error) {
      console.error(`[PhotoUpload] Failed to upload photo ${i + 1}:`, error);
      // Continue with other photos, don't fail the entire upload
      uploadedPhotos.push({
        id: photo.id || `photo_${i}_${Date.now()}`,
        url: photo.url, // Keep data URL as fallback
        Photo: photo.url,
        'Photo (thumbnail)': photo.url,
        caption: photo.caption || '',
        displayOrder: photo.displayOrder ?? i,
        SortOrder: photo.displayOrder ?? i,
        toggleMainPhoto: i === 0,
        uploadError: error.message
      });
    }
  }

  console.log(`[PhotoUpload] Completed uploading ${uploadedPhotos.length} photos`);
  return uploadedPhotos;
}
```

**Refactored Code:**
```javascript
export async function uploadPhotos(photos, listingId) {
  if (!photos || photos.length === 0) {
    console.log('[PhotoUpload] No photos to upload');
    return [];
  }

  console.log(`[PhotoUpload] Starting upload of ${photos.length} photos for listing ${listingId}`);

  const uploadPromises = photos.map(async (photo, i) => {
    try {
      const result = await uploadPhoto(photo, listingId, i);

      return {
        id: photo.id || `photo_${i}_${Date.now()}`,
        url: result.url,
        Photo: result.url,
        'Photo (thumbnail)': result.url,
        storagePath: result.path,
        caption: photo.caption || '',
        displayOrder: photo.displayOrder ?? i,
        SortOrder: photo.displayOrder ?? i,
        toggleMainPhoto: i === 0
      };
    } catch (error) {
      console.error(`[PhotoUpload] Failed to upload photo ${i + 1}:`, error);
      // Return fallback object on error
      return {
        id: photo.id || `photo_${i}_${Date.now()}`,
        url: photo.url,
        Photo: photo.url,
        'Photo (thumbnail)': photo.url,
        caption: photo.caption || '',
        displayOrder: photo.displayOrder ?? i,
        SortOrder: photo.displayOrder ?? i,
        toggleMainPhoto: i === 0,
        uploadError: error.message
      };
    }
  });

  const uploadedPhotos = await Promise.all(uploadPromises);

  console.log(`[PhotoUpload] Completed uploading ${uploadedPhotos.length} photos`);
  return uploadedPhotos;
}
```

**Why This Matters:**
Using `Promise.all` with `map` allows for parallel uploads, which is significantly faster than sequential `for` loop uploads. It also removes the mutable `uploadedPhotos` array.

**Testing:**
- [ ] Upload multiple photos in self-listing flow
- [ ] Verify all photos are uploaded correctly and returned in the array
- [ ] Verify error handling (simulate one failed upload)

~~~~~

## CHUNK 12: Replace imperative loop in supabaseUtils.js:178

**File:** app/src/lib/supabaseUtils.js
**Line:** 178
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /listing-dashboard, /view-split-lease

**Current Code:**
```javascript
export function extractPhotos(photosField, photoMap = {}, listingId = null) {
  // Handle double-encoded JSONB using the centralized parser
  const photos = parseJsonArray(photosField);

  if (photos.length === 0) {
    return []; // Return empty array - NO FALLBACK
  }

  const photoUrls = [];

  for (const photo of photos) {
    // New embedded format: photo is an object with url/Photo field
    if (typeof photo === 'object' && photo !== null) {
      // Extract URL from object (prefer 'url' then 'Photo')
      let photoUrl = photo.url || photo.Photo || null;

      if (photoUrl) {
        // Add https: protocol if URL starts with //
        if (photoUrl.startsWith('//')) {
          photoUrl = 'https:' + photoUrl;
        }
        photoUrls.push(photoUrl);
      }
      continue;
    }

    // String format: could be a direct URL or a legacy ID
    if (typeof photo === 'string') {
      // Check if it's already a valid URL (starts with http://, https://, or //)
      if (photo.startsWith('http://') || photo.startsWith('https://') || photo.startsWith('//')) {
        let photoUrl = photo;
        // Add https: protocol if URL starts with //
        if (photoUrl.startsWith('//')) {
          photoUrl = 'https:' + photoUrl;
        }
        photoUrls.push(photoUrl);
        continue;
      }

      // Legacy format: photo is an ID string - look up in photoMap
      const url = photoMap[photo];
      if (url) {
        photoUrls.push(url);
      }
      continue;
    }
  }

  if (photoUrls.length === 0) {
    console.warn(`⚠️ Listing ${listingId}: NO VALID PHOTO URLS RESOLVED`);
  }

  return photoUrls; // Return all actual photos
}
```

**Refactored Code:**
```javascript
export function extractPhotos(photosField, photoMap = {}, listingId = null) {
  // Handle double-encoded JSONB using the centralized parser
  const photos = parseJsonArray(photosField);

  if (photos.length === 0) {
    return []; // Return empty array - NO FALLBACK
  }

  const photoUrls = photos.map(photo => {
    // New embedded format: photo is an object with url/Photo field
    if (typeof photo === 'object' && photo !== null) {
      const photoUrl = photo.url || photo.Photo || null;
      return photoUrl && photoUrl.startsWith('//') ? 'https:' + photoUrl : photoUrl;
    }

    // String format: could be a direct URL or a legacy ID
    if (typeof photo === 'string') {
      // Check if it's already a valid URL
      if (photo.startsWith('http://') || photo.startsWith('https://') || photo.startsWith('//')) {
        return photo.startsWith('//') ? 'https:' + photo : photo;
      }
      // Legacy format: photo is an ID string
      return photoMap[photo] || null;
    }

    return null;
  }).filter(Boolean); // Remove nulls

  if (photoUrls.length === 0) {
    console.warn(`⚠️ Listing ${listingId}: NO VALID PHOTO URLS RESOLVED`);
  }

  return photoUrls;
}
```

**Why This Matters:**
`map` and `filter` provide a clean pipeline for transformation and filtering, replacing a complex imperative loop with multiple `push` statements and `continue` guards.

**Testing:**
- [ ] Verify photo extraction for object format (new)
- [ ] Verify photo extraction for string URL format
- [ ] Verify photo extraction for legacy ID format

~~~~~

## CHUNK 13: Replace imperative loop in supabaseUtils.js:258

**File:** app/src/lib/supabaseUtils.js
**Line:** 258
**Violation:** IMPERATIVE_LOOP - Imperative loop found (consider map/filter/reduce)
**Severity:** High

**Expected Affected Pages:** /view-split-lease, /search

**Current Code:**
```javascript
  const amenities = [];
  const foundAmenities = new Set(); // Track which amenities we've already added

  // Check Features field (if it exists as a string or array)
  const features = dbListing['Features'];
  if (features) {
    const featureText = typeof features === 'string' ? features.toLowerCase() : '';

    for (const [key, amenity] of Object.entries(amenitiesMap)) {
      if (featureText.includes(key) && !foundAmenities.has(amenity.name)) {
        amenities.push(amenity);
        foundAmenities.add(amenity.name);
      }
    }
  }

  // Check Kitchen Type field - if it's "Full Kitchen", add kitchen amenity
  const kitchenType = dbListing['Kitchen Type'];
  if (kitchenType && kitchenType.toLowerCase().includes('kitchen') && !foundAmenities.has('Kitchen')) {
    amenities.push(amenitiesMap['kitchen']);
    foundAmenities.add('Kitchen');
  }

  // Sort by priority (lower number = higher priority)
  amenities.sort((a, b) => a.priority - b.priority);

  return amenities;
```

**Refactored Code:**
```javascript
  // Check Features field (if it exists as a string or array)
  const features = dbListing['Features'];
  const featureText = typeof features === 'string' ? features.toLowerCase() : '';

  const featureAmenities = Object.entries(amenitiesMap)
    .filter(([key, amenity]) => featureText.includes(key))
    .map(([_, amenity]) => amenity);

  // Check Kitchen Type field
  const kitchenType = dbListing['Kitchen Type'];
  const hasKitchen = kitchenType && kitchenType.toLowerCase().includes('kitchen');
  
  const kitchenAmenity = hasKitchen ? [amenitiesMap['kitchen']] : [];

  // Combine and deduplicate by name
  const allAmenities = [...featureAmenities, ...kitchenAmenity];
  
  // Deduplicate based on name
  const uniqueAmenities = Array.from(
    new Map(allAmenities.map(item => [item.name, item])).values()
  );

  // Sort by priority (lower number = higher priority)
  return uniqueAmenities.sort((a, b) => a.priority - b.priority);
```

**Why This Matters:**
Refactoring to use `filter`, `map`, and `Set`/`Map` for deduplication removes the need for manual state tracking (`foundAmenities`) and `push` operations.

**Testing:**
- [ ] Verify amenities parsing works for listings with features string
- [ ] Verify kitchen amenity is added correctly
- [ ] Verify duplicates are removed and order is correct

~~~~~
