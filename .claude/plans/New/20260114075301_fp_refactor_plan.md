# Functional Programming Refactoring Plan

Date: 2026-01-14
Target: agents/20260114075301_fp_audit_violations.json
Severity Filter: high

~~~~~

## CHUNK 1: Remove I/O (new Date) from validateMoveInDate

**File:** app/src/lib/availabilityValidation.js
**Line:** 248
**Violation:** IO_IN_CORE - Impure function: dependent on new Date() (current time)
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
export function validateMoveInDate(moveInDate, listing, selectedDays) {
  const result = {
    valid: true,
    errors: []
  };

  if (!moveInDate) {
    result.valid = false;
    result.errors.push('Please select a move-in date');
    return result;
  }

  // Check if date is in the past
  const today = new Date();
  today.setHours(0, 0, 0, 0);
  if (moveInDate < today) {
    result.valid = false;
    result.errors.push('Move-in date cannot be in the past');
    return result;
  }
// ...
```

**Refactored Code:**
```javascript
export function validateMoveInDate(moveInDate, listing, selectedDays, today = new Date()) {
  const result = {
    valid: true,
    errors: []
  };

  if (!moveInDate) {
    result.valid = false;
    result.errors.push('Please select a move-in date');
    return result;
  }

  // Check if date is in the past
  // Ensure today is at midnight
  const todayMidnight = new Date(today);
  todayMidnight.setHours(0, 0, 0, 0);
  
  if (moveInDate < todayMidnight) {
    result.valid = false;
    result.errors.push('Move-in date cannot be in the past');
    return result;
  }
// ...
```

**Why This Matters:**
Using `new Date()` inside a function makes it impure and hard to test (results depend on when the test runs). Injecting the date as a parameter (even with a default) allows tests to be deterministic by passing a fixed date.

**Testing:**
- [ ] Verify `validateMoveInDate` works with default parameter
- [ ] Verify `validateMoveInDate` works when a specific date is passed

~~~~~

## CHUNK 2: Replace .push() mutations in validateMoveInDate

**File:** app/src/lib/availabilityValidation.js
**Line:** 243
**Violation:** MUTATING_METHOD - Using .push() to mutate errors array
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
export function validateMoveInDate(moveInDate, listing, selectedDays, today = new Date()) {
  const result = {
    valid: true,
    errors: []
  };

  if (!moveInDate) {
    result.valid = false;
    result.errors.push('Please select a move-in date');
    return result;
  }

  // Check if date is in the past
  // Ensure today is at midnight
  const todayMidnight = new Date(today);
  todayMidnight.setHours(0, 0, 0, 0);
  
  if (moveInDate < todayMidnight) {
    result.valid = false;
    result.errors.push('Move-in date cannot be in the past');
    return result;
  }

  // Check if date is within available range
  if (!isDateInRange(moveInDate, listing['First Available'], listing['Last Available'])) {
    result.valid = false;
    result.errors.push('Move-in date is outside available range');
    return result;
  }

  // Check if date is blocked
  if (isDateBlocked(moveInDate, listing['Dates - Blocked'])) {
    result.valid = false;
    result.errors.push('Selected move-in date is not available');
    return result;
  }

  // Check if move-in date's day of week matches selected schedule
  if (selectedDays && selectedDays.length > 0) {
    const { checkInDay } = calculateCheckInOutDays(selectedDays);
    const moveInDayOfWeek = moveInDate.getDay();

    if (checkInDay !== null && moveInDayOfWeek !== checkInDay) {
      result.valid = false;
      result.errors.push(`Move-in date must be on a ${DAY_NAMES[checkInDay]} based on your selected schedule`);
    }
  }

  return result;
}
```

**Refactored Code:**
```javascript
export function validateMoveInDate(moveInDate, listing, selectedDays, today = new Date()) {
  if (!moveInDate) {
    return {
      valid: false,
      errors: ['Please select a move-in date']
    };
  }

  const todayMidnight = new Date(today);
  todayMidnight.setHours(0, 0, 0, 0);

  const { checkInDay } = selectedDays && selectedDays.length > 0
    ? calculateCheckInOutDays(selectedDays)
    : { checkInDay: null };
  const moveInDayOfWeek = moveInDate.getDay();

  const errors = [
    moveInDate < todayMidnight && 'Move-in date cannot be in the past',
    !isDateInRange(moveInDate, listing['First Available'], listing['Last Available']) && 'Move-in date is outside available range',
    isDateBlocked(moveInDate, listing['Dates - Blocked']) && 'Selected move-in date is not available',
    (checkInDay !== null && moveInDayOfWeek !== checkInDay) && `Move-in date must be on a ${DAY_NAMES[checkInDay]} based on your selected schedule`
  ].filter(Boolean);

  if (errors.length > 0) {
    return {
      valid: false,
      errors
    };
  }

  return {
    valid: true,
    errors: []
  };
}
```

**Why This Matters:**
Mutation makes state unpredictable. A declarative approach using array construction and filtering makes the validation logic clear, linear, and immutable.

**Testing:**
- [ ] Verify validation returns correct errors for past dates
- [ ] Verify validation returns correct errors for blocked dates
- [ ] Verify valid date returns no errors

~~~~~
