# Functional Programming Refactoring Plan

Date: 2026-01-14
Target: agents/20260114051446_fp_audit_violations.json
Severity Filter: all

~~~~~

## CHUNK 1: Refactor extractPhotos to declarative pipeline

**File:** src/lib/supabaseUtils.js
**Line:** 203
**Violation:** MUTATING_METHOD - Using .push() to mutate array
**Severity:** High

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
export function extractPhotos(photosField, photoMap = {}, listingId = null) {
  // Handle double-encoded JSONB using the centralized parser
  const photos = parseJsonArray(photosField);

  if (photos.length === 0) {
    return []; // Return empty array - NO FALLBACK
  }

  const photoUrls = [];

  for (const photo of photos) {
    // New embedded format: photo is an object with url/Photo field
    if (typeof photo === 'object' && photo !== null) {
      // Extract URL from object (prefer 'url' then 'Photo')
      let photoUrl = photo.url || photo.Photo || null;

      if (photoUrl) {
        // Add https: protocol if URL starts with //
        if (photoUrl.startsWith('//')) {
          photoUrl = 'https:' + photoUrl;
        }
        photoUrls.push(photoUrl);
      }
      continue;
    }

    // String format: could be a direct URL or a legacy ID
    if (typeof photo === 'string') {
      // Check if it's already a valid URL (starts with http://, https://, or //)
      if (photo.startsWith('http://') || photo.startsWith('https://') || photo.startsWith('//')) {
        let photoUrl = photo;
        // Add https: protocol if URL starts with //
        if (photoUrl.startsWith('//')) {
          photoUrl = 'https:' + photoUrl;
        }
        photoUrls.push(photoUrl);
        continue;
      }

      // Legacy format: photo is an ID string - look up in photoMap
      const url = photoMap[photo];
      if (url) {
        photoUrls.push(url);
      }
      continue;
    }
  }

  if (photoUrls.length === 0) {
    console.warn(`⚠️ Listing ${listingId}: NO VALID PHOTO URLS RESOLVED`);
  }

  return photoUrls; // Return all actual photos
}
```

**Refactored Code:**
```javascript
export function extractPhotos(photosField, photoMap = {}, listingId = null) {
  // Handle double-encoded JSONB using the centralized parser
  const photos = parseJsonArray(photosField);

  if (photos.length === 0) {
    return []; // Return empty array - NO FALLBACK
  }

  const photoUrls = photos.map(photo => {
    // New embedded format: photo is an object with url/Photo field
    if (typeof photo === 'object' && photo !== null) {
      const rawUrl = photo.url || photo.Photo || null;
      return rawUrl && rawUrl.startsWith('//') ? 'https:' + rawUrl : rawUrl;
    }

    // String format: could be a direct URL or a legacy ID
    if (typeof photo === 'string') {
      // Check if it's already a valid URL
      if (photo.startsWith('http://') || photo.startsWith('https://') || photo.startsWith('//')) {
        return photo.startsWith('//') ? 'https:' + photo : photo;
      }

      // Legacy format: photo is an ID string - look up in photoMap
      return photoMap[photo] || null;
    }

    return null;
  }).filter(Boolean);

  if (photoUrls.length === 0) {
    console.warn(`⚠️ Listing ${listingId}: NO VALID PHOTO URLS RESOLVED`);
  }

  return photoUrls;
}
```

**Why This Matters:**
Replacing the imperative `for` loop and `push` mutation with `map` and `filter` makes the data transformation explicit and eliminates side effects within the function scope. This is easier to test and reason about.

**Testing:**
- [ ] Verify photo extraction works for object format (new)
- [ ] Verify photo extraction works for string URL format
- [ ] Verify photo extraction works for legacy ID format with photoMap

~~~~~

## CHUNK 2: Refactor fetchPhotoUrls to use reduce

**File:** src/lib/supabaseUtils.js
**Line:** 110
**Violation:** MUTATING_METHOD - Mutation of photoMap object
**Severity:** Medium

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
    // Create a map of photo ID to URL
    const photoMap = {};
    data.forEach(photo => {
      if (photo.Photo) {
        // Add https: protocol if URL starts with //
        let photoUrl = photo.Photo;
        if (photoUrl.startsWith('//')) {
          photoUrl = 'https:' + photoUrl;
        }
        photoMap[photo._id] = photoUrl;
      }
    });

    console.log(`✅ Fetched ${Object.keys(photoMap).length} photo URLs from ${data.length} records`);
    return photoMap;
```

**Refactored Code:**
```javascript
    // Create a map of photo ID to URL
    const photoMap = data.reduce((acc, photo) => {
      if (photo.Photo) {
        const photoUrl = photo.Photo.startsWith('//') 
          ? 'https:' + photo.Photo 
          : photo.Photo;
        return { ...acc, [photo._id]: photoUrl };
      }
      return acc;
    }, {});

    console.log(`✅ Fetched ${Object.keys(photoMap).length} photo URLs from ${data.length} records`);
    return photoMap;
```

**Why This Matters:**
Using `reduce` avoids mutating an external variable (`photoMap`) inside the loop. It creates the result state in a single expression, adhering to immutability principles.

**Testing:**
- [ ] Verify photo map is constructed correctly from DB data
- [ ] Check protocol handling (// -> https://)

~~~~~

## CHUNK 3: Refactor fetchHostData to use reduce

**File:** src/lib/supabaseUtils.js
**Line:** 155
**Violation:** MUTATING_METHOD - Mutation of hostMap object
**Severity:** Medium

**Expected Affected Pages:** AUTO

**Current Code:**
```javascript
    // Process users found by _id
    if (userData && userData.length > 0) {
      userData.forEach(user => {
        let profilePhoto = user['Profile Photo'];
        if (profilePhoto && profilePhoto.startsWith('//')) {
          profilePhoto = 'https:' + profilePhoto;
        }
        hostMap[user._id] = {
          name: user['Name - Full'] || null,
          image: profilePhoto || null,
          verified: false,
          userId: user._id
        };
      });
    }

    console.log(`✅ Fetched host data for ${Object.keys(hostMap).length} hosts`);
    return hostMap;
```

**Refactored Code:**
```javascript
    // Process users found by _id
    const processedHostMap = (userData || []).reduce((acc, user) => {
      let profilePhoto = user['Profile Photo'];
      if (profilePhoto && profilePhoto.startsWith('//')) {
        profilePhoto = 'https:' + profilePhoto;
      }
      
      return {
        ...acc,
        [user._id]: {
          name: user['Name - Full'] || null,
          image: profilePhoto || null,
          verified: false,
          userId: user._id
        }
      };
    }, {});

    Object.assign(hostMap, processedHostMap);

    console.log(`✅ Fetched host data for ${Object.keys(hostMap).length} hosts`);
    return hostMap;
```

**Why This Matters:**
Similar to Chunk 2, `reduce` transforms the array into an object without side effects.

**Testing:**
- [ ] Verify host data is mapped correctly
- [ ] Check profile photo protocol fix

~~~~~

## CHUNK 4: Safe LocalStorage Access

**File:** src/lib/secureStorage.js
**Line:** 50
**Violation:** IO_IN_CORE - Direct localStorage access
**Severity:** High

**Expected Affected Pages:** ALL

**Current Code:**
```javascript
/**
 * Store authentication token
 * @param {string} token - Bearer token from Bubble API
 */
export function setAuthToken(token) {
  if (!token) return;
  localStorage.setItem(SECURE_KEYS.AUTH_TOKEN, token);
}

/**
 * Retrieve authentication token
 * @returns {string|null} Token or null
 */
export function getAuthToken() {
  return localStorage.getItem(SECURE_KEYS.AUTH_TOKEN);
}
```

**Refactored Code:**
```javascript
// Internal safe storage wrapper
const safeStorage = {
  getItem: (key) => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        return window.localStorage.getItem(key);
      }
    } catch (e) {
      console.warn('Storage access failed:', e);
    }
    return null;
  },
  setItem: (key, value) => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.setItem(key, value);
      }
    } catch (e) {
      console.warn('Storage access failed:', e);
    }
  },
  removeItem: (key) => {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        window.localStorage.removeItem(key);
      }
    } catch (e) {
      console.warn('Storage access failed:', e);
    }
  }
};

/**
 * Store authentication token
 * @param {string} token - Bearer token from Bubble API
 */
export function setAuthToken(token) {
  if (!token) return;
  safeStorage.setItem(SECURE_KEYS.AUTH_TOKEN, token);
}

/**
 * Retrieve authentication token
 * @returns {string|null} Token or null
 */
export function getAuthToken() {
  return safeStorage.getItem(SECURE_KEYS.AUTH_TOKEN);
}
```

**Why This Matters:**
Direct access to `localStorage` is an impurity and can crash in certain environments (SSR, restricted iframes, private mode in some browsers). Wrapping it makes the function total (handles all inputs/states without throwing) and safer.

**Testing:**
- [ ] Verify login still works
- [ ] Verify token persistence
- [ ] (Optional) Test in restricted environment (e.g. block cookies/storage)

~~~~~
